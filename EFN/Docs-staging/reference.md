# Fieldmark v3 Field Type Documentation Index

<!-- concat:metadata
version: 3.0.0
last_updated: 2025-01-05
total_field_types: 23
format: LLM_FIRST_CONCATENATABLE
structure: three_tier_depth_tagged
-->

## Documentation Structure

This documentation system serves as both:
1. **Individual Files**: Navigate to specific documents for maintenance and focused editing
2. **Concatenated Reference**: Single comprehensive document for LLM consumption (`reference.md`)

### Depth Tagging System

All content is tagged with one of three depth levels:
- `{essential}` - Core concepts required for basic use (5-minute comprehension target)
- `{important}` - Standard patterns and working knowledge for effective use
- `{comprehensive}` - Complete reference including edge cases, performance implications, and technical details

### Navigation Methods

#### When Using Individual Files
- Click document links below to open specific field category documentation
- Each document contains navigation headers and footers for moving between related content
- Cross-references link to other files in the documentation system

#### When Using Concatenated Reference (reference.md)
- Use section anchors to jump directly to specific field categories
- All cross-references become internal anchor links
- Single file contains complete documentation system

---

## Field Type Catalog

### 1. Text & Input Fields
<!-- concat:section-id="text-input-fields" -->
- **Document**: [text-fields-v05.md](./field-categories/text-fields-v05.md)
- **Anchor**: [#text-input-fields](#text-input-fields) (in concatenated reference)
- **Field Types**: 7 components
  - `TextField` - Single-line text input
  - `FAIMSTextField` - Enhanced text with compute support
  - `MultipleTextField` - Multi-value text entries
  - `TemplatedStringField` - Dynamic string interpolation
  - `AddressField` - Structured address capture
  - `QRCodeFormField` - QR code scanner input
  - `RichText` - Formatted text editor
- **Designer Coverage**: Partial
  - ‚úÖ Designer: TextField, FAIMSTextField, MultipleTextField basic config
  - üîß Enhanced: Validation patterns, helper text, conditional display
  - üìù JSON-only: compute_value, template syntax, regex validation
- **Common Use Cases**: Names, descriptions, codes, addresses, notes, formatted content

### 2. Selection & Choice Fields
<!-- concat:section-id="selection-fields" -->
- **Document**: [select-choice-fields-v05.md](./field-categories/select-choice-fields-v05.md)
- **Anchor**: [#selection-fields](#selection-fields) (in concatenated reference)
- **Field Types**: 5 components
  - `Checkbox` - Multiple choice with checkboxes
  - `Select` - Single choice dropdown
  - `MultiSelect` - Multiple choice dropdown
  - `RadioGroup` - Single choice with radio buttons
  - `AdvancedSelect` - Hierarchical selection with search
- **Designer Coverage**: Full
  - ‚úÖ Designer: All basic configurations including options
  - üîß Enhanced: Dynamic options, dependent selects
  - üìù JSON-only: Option generation, API-driven choices
- **Common Use Cases**: Categories, types, multiple selections, hierarchical data, filters

### 3. Date & Time Fields
<!-- concat:section-id="datetime-fields" -->
- **Document**: [datetime-fields-v05.md](./field-categories/datetime-fields-v05.md)
- **Anchor**: [#datetime-fields](#datetime-fields) (in concatenated reference)
- **Field Types**: 4 components
  - `DateTimeNow` - Auto-populated current timestamp
  - `DateTimePicker` - Date and time selection
  - `DatePicker` - Date-only selection
  - `MonthPicker` - Month/year selection
- **Designer Coverage**: Full
  - ‚úÖ Designer: All date/time configurations
  - üîß Enhanced: Custom formats, validation ranges
  - üìù JSON-only: compute_value for calculated dates
- **Common Use Cases**: Timestamps, event dates, scheduling, date ranges, audit trails

### 4. Numeric Fields
<!-- concat:section-id="number-fields" -->
- **Document**: [number-fields-v05.md](./field-categories/number-fields-v05.md)
- **Anchor**: [#number-fields](#number-fields) (in concatenated reference)
- **Field Types**: 3 components
  - `NumberField` - Numeric input with validation
  - `ControlledNumber` - TextField variant for numbers
  - `BasicAutoIncrementer` - Auto-incrementing counter
- **Designer Coverage**: Partial
  - ‚úÖ Designer: NumberField basic configuration
  - üîß Enhanced: Min/max, decimal places, units
  - üìù JSON-only: Step increments via BasicAutoIncrementer
- **Common Use Cases**: Measurements, counts, IDs, quantities, calculations

### 5. Location & Mapping Fields
<!-- concat:section-id="location-fields" -->
- **Document**: [location-fields-v05.md](./field-categories/location-fields-v05.md)
- **Anchor**: [#location-fields](#location-fields) (in concatenated reference)
- **Field Types**: 2 components
  - `TakePoint` - GPS point capture
  - `MapForm` - Interactive map with geometry drawing
- **Designer Coverage**: Limited
  - ‚úÖ Designer: Basic GPS capture setup
  - üìù JSON-only: Map configuration, geometry types, layers
- **Common Use Cases**: Site locations, GPS coordinates, areas, routes, spatial data

### 6. Media & File Fields
<!-- concat:section-id="media-fields" -->
- **Document**: [media-fields-v05.md](./field-categories/media-fields-v05.md)
- **Anchor**: [#media-fields](#media-fields) (in concatenated reference)
- **Field Types**: 2 components
  - `TakePhoto` - Camera capture and gallery selection
  - `FileUploader` - General file attachment
- **Designer Coverage**: Full
  - ‚úÖ Designer: All media configurations
  - üîß Enhanced: File type restrictions, size limits
  - üìù JSON-only: Custom upload handlers
- **Common Use Cases**: Photos, documents, audio recordings, evidence collection

### 7. Display Fields
<!-- concat:section-id="display-fields" -->
- **Document**: [display-field-v05.md](./field-categories/display-field-v05.md)
- **Anchor**: [#display-fields](#display-fields) (in concatenated reference)
- **Field Types**: 1 component
  - `RichText` - Display-only formatted content
- **Designer Coverage**: Partial
  - ‚úÖ Designer: Basic rich text content
  - üìù JSON-only: HTML content, dynamic generation
- **Common Use Cases**: Instructions, warnings, help text, formatted information display

### 8. Relationship Fields
<!-- concat:section-id="relationship-fields" -->
- **Document**: [relationship-field-v05.md](./field-categories/relationship-field-v05.md)
- **Anchor**: [#relationship-fields](#relationship-fields) (in concatenated reference)
- **Field Types**: 1 component
  - `RelationshipField` - Links between records
- **Designer Coverage**: Partial
  - ‚úÖ Designer: Basic relationship setup
  - üìù JSON-only: Complex relationship rules, cascading
- **Common Use Cases**: Parent-child records, linked entities, hierarchical data

---

## Cross-Field Patterns
<!-- concat:section-id="cross-field-patterns" -->

Documentation covering functionality that spans multiple field types:

### Validation Patterns
- **Document**: [validation.md](./detail-crossfield-docs/validation.md)
- **Anchor**: [#validation-patterns](#validation-patterns) (in concatenated reference)
- **Coverage**: Validation strategies across all field types

### Conditional Logic
- **Document**: [conditional-logic.md](./detail-crossfield-docs/conditional-logic.md)
- **Anchor**: [#conditional-logic](#conditional-logic) (in concatenated reference)
- **Coverage**: Show/hide logic, dependent fields, dynamic behavior

### Form Navigation
- **Document**: [navigation.md](./detail-crossfield-docs/navigation.md)
- **Anchor**: [#form-navigation](#form-navigation) (in concatenated reference)
- **Coverage**: Multi-step forms, progress tracking, navigation patterns

### Notebook Structure
- **Document**: [notebook-structure.md](./detail-crossfield-docs/notebook-structure.md)
- **Anchor**: [#notebook-structure](#notebook-structure) (in concatenated reference)
- **Coverage**: Overall form architecture, sections, organization

### Common Patterns
- **Document**: [patterns.md](./detail-crossfield-docs/patterns.md)
- **Anchor**: [#common-patterns](#common-patterns) (in concatenated reference)
- **Coverage**: Reusable patterns, best practices, common solutions

---

## Technical References
<!-- concat:section-id="technical-references" -->

### Component Reference
- **Documents**: 
  - [component-namespace-reference.md](./reference-docs/component-namespace-reference.md)
  - [meta-properties-reference.md](./reference-docs/meta-properties-reference.md)
  - [formik-integration-reference.md](./reference-docs/formik-integration-reference.md)
- **Anchor**: [#component-reference](#component-reference) (in concatenated reference)
- **Coverage**: Component architecture, properties, integration details

### Platform Reference
- **Documents**:
  - [platform-behaviors-reference.md](./reference-docs/platform-behaviors-reference.md)
  - [performance-thresholds-reference.md](./reference-docs/performance-thresholds-reference.md)
  - [accessibility-reference.md](./reference-docs/accessibility-reference.md)
- **Anchor**: [#platform-reference](#platform-reference) (in concatenated reference)
- **Coverage**: Platform-specific behaviors, performance limits, accessibility

### Operations Reference
- **Documents**:
  - [migration-strategies-reference.md](./reference-docs/migration-strategies-reference.md)
  - [troubleshooting-framework-reference.md](./reference-docs/troubleshooting-framework-reference.md)
  - [data-export-reference.md](./reference-docs/data-export-reference.md)
- **Anchor**: [#operations-reference](#operations-reference) (in concatenated reference)
- **Coverage**: Migration paths, debugging, data management

### Constraints Reference
- **Documents**:
  - [designer-limitations-reference.md](./reference-docs/designer-limitations-reference.md)
  - [security-considerations-reference.md](./reference-docs/security-considerations-reference.md)
  - [validation-timing-reference.md](./reference-docs/validation-timing-reference.md)
- **Anchor**: [#constraints-reference](#constraints-reference) (in concatenated reference)
- **Coverage**: Known limitations, security rules, validation lifecycle

---

## Using This Documentation

### For Individual File Maintenance
1. Navigate to specific documents using the links above
2. Edit individual files for focused updates
3. Use git to track changes per document
4. Cross-references use relative file paths

### For LLM Consumption
1. Run `./scripts/build-reference.sh` to generate `reference.md`
2. Load the single concatenated file into the LLM
3. All documentation is available in one context
4. Cross-references work as internal anchors

### For Human Documentation Generation
Extract subsets based on depth tags:
- **Quick Start Guide**: Extract all `{essential}` sections
- **User Reference**: Extract `{essential}` + `{important}` sections
- **Complete Reference**: Include all sections including `{comprehensive}`

### Documentation Maintenance
1. Always edit individual source files (never edit reference.md directly)
2. Regenerate reference.md after changes using the build script
3. Commit both source files and regenerated reference.md
4. Tag releases when documentation milestones are reached

---

## Quick Reference Matrix

| Field Category | Designer Coverage | Field Count | Primary Use Case |
|---------------|------------------|-------------|------------------|
| Text & Input | Partial | 7 | Text data capture |
| Selection | Full | 5 | Categorical choices |
| Date & Time | Full | 4 | Temporal data |
| Numeric | Partial | 3 | Quantitative data |
| Location | Limited | 2 | Spatial data |
| Media | Full | 2 | File attachments |
| Display | Partial | 1 | Information display |
| Relationship | Partial | 1 | Record linking |

---

## Version History

- **3.0.0** (2025-01-05): Complete reorganization for LLM-first documentation
- **2.0.0** (2024): Addition of NEW format fields (display, location, media, relationship)
- **1.0.0** (2023): Initial documentation for core field types

<!-- ============================================ -->
<!-- FIELD TYPE DOCUMENTATION -->
<!-- ============================================ -->


<!-- concat:document:text-fields-v05 -->
<!-- concat:boundary:start section="text-input-fields" -->
<!-- concat:metadata
document_id: text-fields-v05
category: text_input
field_count: 7
designer_capable: ["FAIMSTextField", "MultipleTextField", "TextField"]
json_only: ["TemplatedStringField.template_syntax", "AddressField.structure", "QRCodeFormField.formats"]
last_updated: 2025-01-05
-->

# Text Input Fields

## Document Navigation
<!-- concat:nav-mode:individual -->
[‚Üê Field Index](../field-type-index.md) | **Text & Input Fields** | [Selection Fields ‚Üí](./select-choice-fields-v05.md)
<!-- concat:nav-mode:concatenated -->
<!-- When viewing in reference.md: [‚Üë Top](#fieldmark-v3-field-type-documentation-index) | [Selection Fields ‚Üì](#selection-fields) -->

## Overview {essential}

The Fieldmark ecosystem provides seven text-related field types for comprehensive data capture and display needs:

### DESIGNER QUICK GUIDE
When using the Designer interface:
- üìù **Single-line text**: Choose **"FAIMS Text Field"**
- üìÑ **Multi-line text**: Choose **"Text Field"**
- ‚úâÔ∏è **Email input**: Choose **"Email"**

### CRITICAL NAMING DISAMBIGUATION
‚ö†Ô∏è **Designer UI names differ from component names**:
- **"FAIMS Text Field"** in Designer = single-line text (component: FAIMSTextField)
- **"Text Field"** in Designer = multi-line text area (component: MultipleTextField)
- **"Email"** in Designer = single-line with validation (component: TextField with email config)

Note: TextField (formik-material-ui) is the base component but is not directly selectable in Designer for plain text input.

This naming inconsistency is a known issue that creates significant confusion. Always verify the component-name in JSON when troubleshooting.

### Field Capabilities Summary
Fieldmark text fields provide comprehensive text capture capabilities spanning single-line inputs, multi-line narratives, templated identifiers, structured addresses, and mobile barcode scanning. The ecosystem includes six data capture components plus one display-only field, supporting everything from brief identifiers to complex structured data entry with mobile-optimized scanning capabilities.

### Component Status
| Component | Status | Platform Support | Primary Use Case |
|-----------|---------|-----------------|------------------|
| FAIMSTextField | Stable | All | Single-line text input |
| MultipleTextField | Stable | All | Multi-line text areas |
| TextField (Email) | Stable | All | Validated email input |
| TemplatedString | Stable | All | Auto-generated identifiers |
| Address Field | Beta | All | Structured address capture |
| QRCodeFormField | Stable | Mobile only | Barcode scanning |
| RichText | Stable | All | Display-only content |

### Data Capture Fields (1-6)

1. **FAIMSTextField** (appears as "FAIMS Text Field" in Designer) - Single-line text input for brief, unconstrained textual data (50 character recommendation). Implemented through the `faims-custom/FAIMSTextField` component with enhanced advanced help capabilities.

2. **MultipleTextField** (appears as "Text Field" in Designer) - Extended text entry for narrative content and detailed observations (10,000 character recommendation). Maintains fixed-height presentation with internal scrolling mechanisms. Despite both using FormikTextField internally, MultipleTextField is configured with `multiline: true` and `rows: 4` parameters.

3. **TextField** (used by "Email" in Designer) - Base single-line component, primarily used with email configuration. When "Email" is selected in Designer, it creates a TextField component with `InputProps: {type: 'email'}` configuration. Not directly accessible through Designer for general text input.

4. **TemplatedString** - Auto-generated text from Mustache templates, critical for Human-Readable Identifiers (HRIDs). **‚ö†Ô∏è CRITICAL REQUIREMENT**: Every notebook MUST include at least one TemplatedString field configured as the `hridField`. Without HRIDs, records display only as cryptic UUIDs (e.g., `a7f3b2c1-d4e5-6789-0abc`), making field data management impossible. **‚ö†Ô∏è SECURITY WARNING**: TemplatedString has HTML escaping DISABLED (formUtilities.ts line 27), creating XSS vulnerabilities if user input is included in templates without sanitization.

5. **Address Field** - Provides structured address capture through a specialised interface storing data in GeocodeJSON-compliant format, facilitating both human-readable display and future geocoding integration. **Beta feature** implementing dual storage ‚Äì maintaining both structured components and concatenated display strings within a JSON object. Currently optimised for Australian address formats with technical users comfortable with JSON data extraction.

6. **QRCodeFormField** - Delivers **mobile-exclusive** barcode scanning functionality through ML Kit barcode scanning, supporting thirteen distinct barcode formats despite its nomenclature suggesting QR-only capability. Uses sophisticated ten-scan validation mechanism ensuring reading accuracy whilst operating without user feedback. **‚ö†Ô∏è PLATFORM WARNING**: Web platform deployment renders the component entirely non-functional, displaying a disabled interface that critically breaks form validation when marked as required.

## Component Name Mapping {essential}

| Designer UI Label | JSON component-name | Namespace | Code File | Description |
|------------------|-------------------|-----------|-----------|-------------|
| FAIMS Text Field | FAIMSTextField | faims-custom | FAIMSTextField.tsx | Single-line text input |
| Text Field | MultipleTextField | formik-material-ui | TextField.tsx | Multi-line text area |
| Email | TextField | formik-material-ui | TextField.tsx | Email with validation |
| Template String | TemplatedStringField | faims-custom | TemplatedString.tsx | Auto-generated text |
| Address | AddressField | faims-custom | Address.tsx | Structured address |
| QR Code Scanner | QRCodeFormField | qrcode | QRCodeFormField.tsx | Barcode scanner |
| Rich Text | RichText | faims-custom | RichText.tsx | Display-only formatted content |

### Critical Naming Issues {important}
- **TextField confusion**: The base TextField component (formik-material-ui) is NOT directly available in Designer
- **MultipleTextField misnomer**: Despite the name suggesting multiple values, this is actually a multi-LINE text area
- **Designer label mismatch**: "Text Field" in Designer creates MultipleTextField, not TextField
- **Component file discrepancy**: TemplatedStringField component is in TemplatedString.tsx (without "Field")

### Display Field (7)

7. **RichText Field** - Provides formatted instructional content and headings within forms through markdown rendering. Purely presentational‚Äîdisplays static content without capturing or storing user input. Exists within field architecture for consistency but does not participate in form validation, data storage, or export operations. Content rendered through markdown-it parser with aggressive DOMPurify sanitization. **Note**: Tables and external images not yet supported, no accessibility implementation, and feature discrepancies between Designer editing and runtime display.


---

## Designer Usage Guide {essential}

### What to Select in Designer

When using the Designer interface, follow these simple rules:

üìù **For single-line text input**: Select **"FAIMS Text Field"**
- Use for: identifiers, names, brief labels, codes
- Creates: FAIMSTextField component
- Helper text in Designer: "Single-line text input for free-form entries"

üìÑ **For multi-line text input**: Select **"Text Field"**  
- Use for: descriptions, notes, observations, narratives
- Creates: MultipleTextField component
- Helper text in Designer: "Multi-line text area for longer notes"

‚úâÔ∏è **For email addresses**: Select **"Email"**
- Use for: validated email input
- Creates: TextField component with email configuration
- Includes automatic email validation

### When JSON Enhancement is Required

You MUST edit JSON directly for:

**TextField/FAIMSTextField**:
- ‚úÖ Required: Character limit enforcement (`inputProps.maxLength`)
- ‚úÖ Required: Pattern validation (regex via `yup.matches`)
- ‚úÖ Required: Advanced helper text with formatting
- ‚ö†Ô∏è Optional: Custom placeholder text
- ‚ö†Ô∏è Optional: Variant styles (outlined, filled, standard)
- `XREF` See [JSON Examples > TextField Examples]

**MultilineText (MultipleTextField)**:
- ‚úÖ Required: Word/character count validation
- ‚úÖ Required: Performance optimization for >10,000 characters
- ‚ö†Ô∏è Optional: Dynamic row adjustment based on content
- ‚ùå Never: Row configuration can be set in Designer (`InputProps.rows`)
- `XREF` See [Common Characteristics > Performance Boundaries]

**TemplatedString**:
- ‚úÖ Required: Complex template logic (Mustache conditionals beyond Designer's Template Builder)
- ‚úÖ Required: Field references from other forms
- ‚úÖ Required: Security patterns to prevent XSS (avoid user input)
- ‚ùå Never: Basic templates with text/variables/conditionals can be built in Designer's Template Builder
- ‚ö†Ô∏è CRITICAL: See [CRITICAL SECURITY VULNERABILITIES] for XSS risks
- `XREF` See [JSON Examples > TemplatedString Examples]

**Email**:
- ‚úÖ Required: Domain-specific validation (e.g., `.edu.au` only)
- ‚úÖ Required: Multiple domain patterns
- ‚ö†Ô∏è Optional: Custom error messages
- `XREF` See [Field Quirks Index > Email]

**Address**:
- ‚úÖ Required: JSON extraction patterns for CSV export
- ‚úÖ Required: Debounce configuration for race condition
- ‚úÖ Required: Custom validation rules
- ‚ö†Ô∏è Beta feature - expect changes
- `XREF` See [Troubleshooting Guide > Address Field Race Condition]

**QRCodeFormField**:
- ‚úÖ Required: Platform conditionals (mobile-only deployment)
- ‚úÖ Required: Manual fallback field pairing
- ‚úÖ Required: Making field optional (never mark as required)
- ‚ùå Never: Basic scanning configuration
- `XREF` See [JSON Examples > QRCodeFormField with Manual Fallback]

**RichText**:
- ‚úÖ Required: Base64 image embedding
- ‚ö†Ô∏è Optional: Complex markdown/MDX (tables won't render)
- ‚ùå Never: Data capture (display only, never exports)
- `XREF` See [Field Quirks Index > RichText]

### Designer Limitations {important}

See [Designer Limitations Reference](designer-limitations-reference.md) for testing, validation, and configuration constraints that apply to all fields.

**Text Field-Specific Limitations**:
- **Character limits**: Cannot enforce maximum character counts or input patterns
- **XSS prevention**: Cannot configure security for TemplatedString user inputs
- **Platform behaviors**: Cannot set QR code fallbacks or mobile-specific settings
- **Address timing**: Cannot configure debounce for Address race conditions
- **Auto-complete**: Cannot enable suggestion lists or auto-formatting

## Field Selection Guide {essential}

### Decision Tree

```
What type of text data do you need?
‚îÇ
‚îú‚îÄ Display-only content?
‚îÇ  ‚îî‚îÄ YES ‚Üí RichText
‚îÇ     ‚îú‚îÄ Returns: None (display only)
‚îÇ     ‚îî‚îÄ Best for: Instructions, headers
‚îÇ
‚îú‚îÄ Auto-generated identifier or derived value?
‚îÇ  ‚îî‚îÄ YES ‚Üí TemplatedString  
‚îÇ     ‚îú‚îÄ Returns: faims-core::String
‚îÇ     ‚îú‚îÄ Configure as hridField for record IDs
‚îÇ     ‚îî‚îÄ ‚ö†Ô∏è XSS vulnerability if used with user input
‚îÇ
‚îú‚îÄ Barcode/QR code scanning?
‚îÇ  ‚îî‚îÄ YES ‚Üí QRCodeFormField
‚îÇ     ‚îú‚îÄ Returns: faims-core::String
‚îÇ     ‚îú‚îÄ Mobile only (web shows disabled)
‚îÇ     ‚îî‚îÄ Pair with TextField for web fallback
‚îÇ
‚îú‚îÄ Structured data capture?
‚îÇ  ‚îú‚îÄ Email address?
‚îÇ  ‚îÇ  ‚îî‚îÄ YES ‚Üí Email (TextField variant)
‚îÇ  ‚îÇ     ‚îú‚îÄ Returns: faims-core::String
‚îÇ  ‚îÇ     ‚îî‚îÄ HTML5 email validation
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Street address?
‚îÇ     ‚îî‚îÄ YES ‚Üí Address
‚îÇ        ‚îú‚îÄ Returns: faims-core::JSON
‚îÇ        ‚îî‚îÄ Google Places autocomplete
‚îÇ
‚îî‚îÄ User-entered text?
   ‚îú‚îÄ Single line (<200 chars)?
   ‚îÇ  ‚îî‚îÄ YES ‚Üí TextField/FAIMSTextField
   ‚îÇ     ‚îú‚îÄ Returns: faims-core::String
   ‚îÇ     ‚îú‚îÄ Designer: "FAIMS Text Field"
   ‚îÇ     ‚îî‚îÄ Consider FAIMSTextField for rich help
   ‚îÇ
   ‚îî‚îÄ Multiple lines or >200 chars?
      ‚îî‚îÄ YES ‚Üí MultilineText
         ‚îú‚îÄ Returns: faims-core::String  
         ‚îú‚îÄ Designer: "Text Field" with multiline
         ‚îî‚îÄ Configure rows (3-10 typical)
```

---

## ‚ö†Ô∏è Critical Security Risks {essential}

See [Security Considerations Reference](security-considerations-reference.md) for comprehensive security guidelines, testing procedures, and mitigation strategies.

**Text Field Critical Security Notes**:
- **TemplatedString**: HTML escaping DISABLED (formUtilities.ts line 27) - NEVER include user input in templates
- **RichText**: Never include user-generated content despite DOMPurify sanitization
- **Address**: JSON injection possible - validate structure server-side
- **All text fields**: No input sanitization by default - implement server-side validation

---

## What This Field Cannot Do {important}

### Content Processing Limitations {important}
- **Rich text editing** - No WYSIWYG editor for users (only static RichText display)
- **Auto-formatting** - No automatic phone/postal code formatting
- **Spell check control** - Cannot disable browser spell check
- **Language detection** - No automatic RTL/LTR switching
- **Character counting** - No live character count display (except MultipleTextField)

### Validation Limitations {important}
- **Cross-field validation** - Cannot validate against other fields
- **Async validation** - No server-side validation during entry
- **Custom error messages** - Limited to predefined messages
- **Format enforcement** - Cannot force uppercase/lowercase

### Display Limitations {important}
- **Dynamic resizing** - TextField cannot auto-expand
- **Custom keyboards** - Cannot specify keyboard layouts
- **Inline editing** - No in-place editing after submission
- **Rich previews** - No URL or media previews


## Common Use Cases {important}

### Field Notes and Observations
- **Brief descriptions** ‚Üí TextField (max 50 chars recommended)
- **Detailed observations** ‚Üí MultipleTextField (narratives)
- **Specimen labels** ‚Üí TemplatedString (auto-generated IDs)
- **Contact emails** ‚Üí Email field with validation

### Location and Context Recording
- **Site addresses** ‚Üí Address field (structured JSON)
- **GPS coordinates as text** ‚Üí TextField with pattern validation
- **QR/Barcode scanning** ‚Üí QRCodeFormField + TextField fallback
- **Context descriptions** ‚Üí MultipleTextField

### Documentation and Metadata
- **Photo captions** ‚Üí TextField (brief)
- **Methodology notes** ‚Üí RichText (static display only)
- **Sample IDs** ‚Üí TemplatedString (e.g., `SITE-{{counter}}-{{date}}`)
- **Field team contacts** ‚Üí Email fields

### Quality Control
- **Validation notes** ‚Üí MultipleTextField
- **Scan verification** ‚Üí QRCodeFormField (10 consecutive reads required)
- **Chain of custody** ‚Üí TemplatedString with timestamps
- **Data entry comments** ‚Üí MultipleTextField with timestamp

---

### Decision Matrix

| Field Type | Returns | Max Length | Designer Name | Critical Issues |
|------------|---------|------------|---------------|----------------|
| **TextField** | String | ~200 chars* | "FAIMS Text Field" | Performance >10K chars |
| **MultilineText** | String | 10,000 chars* | "Text Field" | Browser crash >50K |
| **TemplatedString** | String | Auto-generated | "Templated String Field" | XSS with user input |
| **Email** | String | Email format | "Email Field" | Platform validation varies |
| **Address** | JSON | Complex object | "Address Field" | Requires Google API |
| **QRCodeFormField** | String | Scanned value | "QR Code Field" | Mobile only |
| **RichText** | None | Display only | "RichText" | No data capture |

*Performance degrades significantly beyond these thresholds

### Selection Strategy

1. **Default to TextField** (FAIMSTextField) for most text input
2. **Use MultilineText** only when content exceeds single line
3. **Deploy TemplatedString** as hridField (mandatory for notebooks)
4. **Consider structured fields** (Email, Address) only when validation/structure adds value
5. **Avoid QRCodeFormField** unless mobile-only deployment confirmed

**Platform Considerations**:
- Mobile: All fields work, QRCode camera enabled
- Web: QRCode shows disabled state
- iOS: Email keyboard includes @ symbol
- Android: Address autocomplete may fail in some regions

**Accessibility Requirements**:
- TextField/MultilineText: WCAG AA compliant
- Address: Complex navigation, may confuse screen readers
- QRCode: Camera interface not accessible
- RichText: Ensure semantic HTML for screen readers

---

## Designer Component Mapping {essential}

### Designer UI vs JSON Component Names

| Designer UI Label | JSON component-name | Component Namespace | Description |
|------------------|--------------------|--------------------|-------------|
| FAIMS Text Field | FAIMSTextField | faims-custom | Enhanced single-line with advanced help |
| Text Field | MultipleTextField | formik-material-ui | Multi-line text area |
| Email | TextField | formik-material-ui | Single-line with email validation |
| Templated String Field | TemplatedStringField | faims-custom | Auto-generated text |
| Scan QR Code | QRCodeFormField | qrcode | Mobile-only scanner |
| Address | AddressField | faims-custom | Structured address input |
| RichText | RichText | faims-custom | Display-only markdown content |

‚ö†Ô∏è **Critical Notes**:
- There is NO Designer element that creates a plain TextField without configuration
- "FAIMS Text Field" creates FAIMSTextField (not TextField)
- "Text Field" creates MultipleTextField (not MultilineText)
- Only "Email" uses the base TextField component

This mapping table is essential for:
- Debugging field behaviour issues (see [Troubleshooting Guide > Critical Issues Table])
- Writing JSON configurations manually
- Understanding error messages that reference component names
- Migrating between Designer versions

## Designer Capabilities vs JSON Enhancement {essential}

### What Designer Can Configure

For complete meta properties documentation (annotation, uncertainty, persistence), see [Meta Properties Reference](meta-properties-reference.md).

The Designer interface provides basic field creation for all text fields:

| Field Type | Designer Creates | Designer Configures | JSON-Only Features |
|------------|------------------|---------------------|--------------------|  
| **TextField (FAIMS)** | ‚úÖ Basic field | Label, Required, Helper text | Advanced helper text, character limits (`maxLength`), input patterns |
| **MultilineText** | ‚úÖ Basic field | Label, Required, Helper text, Rows | Word count validation, performance limits, dynamic sizing |
| **TemplatedString** | ‚úÖ Basic field | Label, Template pattern | Security sanitization, complex conditionals, field references |
| **Email** | ‚úÖ Basic field | Label, Required, Helper text | Domain-specific validation, custom regex patterns |
| **Address** | ‚úÖ Basic field | Basic structure | JSON extraction patterns, debouncing, custom validation |
| **QRCodeFormField** | ‚úÖ Basic field | Label | Platform conditionals, manual fallback pairing, scan requirements |
| **RichText** | ‚úÖ Display only | Content (markdown) | Base64 images, memory management, MDX components |


## Component Namespace Errors {important}

See [Component Namespace Reference](component-namespace-reference.md) for complete namespace documentation, error troubleshooting, and case sensitivity rules.

### Text Field-Specific Notes

**Mixed namespaces in text fields**:
- Basic text: `formik-material-ui` (TextField, MultipleTextField)
- Custom text: `faims-custom` (FAIMSTextField, TemplatedStringField, Address)
- Special case: `qrcode` namespace for QRCodeFormField

**Quick Reference for Text Fields**:
| Component | Namespace | Notes |
|-----------|-----------|-------|
| TextField | `formik-material-ui` | Basic single-line |
| MultipleTextField | `formik-material-ui` | Multi-line textarea |
| FAIMSTextField | `faims-custom` | Enhanced single-line |
| TemplatedStringField | `faims-custom` | Auto-generated |
| Address | `faims-custom` | Structured address |
| QRCodeFormField | `qrcode` | Scanner (unique namespace) |

---


## When to Use These Fields {essential}

### Field Selection Matrix

| Use Case | Recommended Field | Why |
|----------|------------------|-----|
| Short identifiers (<50 chars) | FAIMSTextField | Single-line, clean display |
| Long descriptions | MultipleTextField | Multi-line with scrolling |
| Email addresses | TextField (Email) | Built-in validation |
| Auto-generated IDs | TemplatedStringField | Consistent formatting |
| Physical addresses | AddressField | Structured components |
| Barcode scanning | QRCodeFormField | Mobile camera integration |
| Instructions/Help | RichText | Formatted display only |

### Decision Criteria
- **Data length**: <50 chars ‚Üí FAIMSTextField, >50 chars ‚Üí MultipleTextField
- **Validation needed**: Email ‚Üí TextField, Pattern ‚Üí TemplatedStringField
- **User input**: Yes ‚Üí FAIMSTextField/MultipleTextField, No ‚Üí RichText
- **Mobile scanning**: Required ‚Üí QRCodeFormField
- **Address structure**: Needed ‚Üí AddressField

## Common Characteristics {important}

### Security Considerations {important}

See [Security Considerations Reference](security-considerations-reference.md) for detailed security analysis, XSS prevention, and SQL injection mitigation.

**Text Field-Specific Security Requirements**:
- **TemplatedString**: HTML escaping disabled - critical XSS risk with user input
- **QRCodeFormField**: No content validation - verify scanned data server-side
- **RichText**: DOMPurify sanitization present but never trust with user content
- **All fields**: Implement server-side validation and sanitization

### Performance Boundaries {important}

See [Performance Thresholds Reference](performance-thresholds-reference.md) for comprehensive performance limits, testing scenarios, and optimization triggers.

**Text Field-Specific Performance Notes**:
- **TextField**: 50 character recommendation for mobile viewports
- **MultilineText**: Performance degrades >10,000 characters (~1MB CouchDB limit)
- **TemplatedString**: Max 3 per form, 50 variables per template
- **RichText**: Max 10 per notebook, 50 words per field (1000 total)
- **QRCodeFormField**: Performance limited by device memory and camera
- **Address**: No limits but increases JSON payload size significantly

### Common Validation Patterns {important}

#### Standard Validation Rules {important}
| Rule | Schema | Purpose | Fields |
|------|--------|---------|--------|
| required | `["yup.required", "Field required"]` | Mandatory content | TextField, MultipleTextField, TemplatedString, Email, Address |
| min length | `["yup.min", N, "Minimum N characters"]` | Enforce minimum | TextField, MultipleTextField |
| max length | `["yup.max", N, "Maximum N characters"]` | Prevent excess | TextField, MultipleTextField |
| pattern | `["yup.matches", "regex", "message"]` | Format enforcement | TextField, MultipleTextField, TemplatedString |
| email | `["yup.email", "Invalid email"]` | Email validation | TextField with type="email", Email field |
| object | `["yup.object"]` | JSON structure | Address field |

#### Validation Behavior {important}

For universal validation timing behavior, see [Validation Timing Reference](validation-timing-reference.md).

**Text Field-Specific Behaviors**:
- **Keystroke validation**: Text fields validate on EVERY character entry (performance impact)
- **No debouncing**: Each keystroke triggers full validation cycle
- **Complex regex impact**: Pattern matching on every keystroke can cause noticeable lag
- **Touch requirement**: Errors display only after field is "touched" (focused then blurred)

**TemplatedString Specific**:
- Validates output, not template syntax
- Silent failure for invalid templates

**No User Validation (QRCodeFormField, RichText)**:
- QRCodeFormField: 10-scan hardware validation only, no user feedback
- RichText: Display-only, never validates

### Platform Behaviors {important}

#### Cross-Platform Consistency {important}
- **TextField, MultipleTextField, TemplatedString**: Behave identically across iOS, Android, and web
- **Touch targets**: Maintain 44√ó44px minimum (WCAG compliance) except Address edit button
- **Font size**: Minimum 16px prevents iOS zoom on focus
- **Tab navigation**: Follows DOM order
- **TemplatedString**: Evaluation identical on all platforms
- **QRCodeFormField**: Mobile-only, completely non-functional on web
- **RichText**: Stable on desktop, memory issues on mobile

#### iOS Behaviors {comprehensive}
| Field | Keyboard | Auto-correction | Special Features |
|-------|----------|-----------------|------------------|
| TextField/MultilineText/TemplatedString | Standard text | Active, predictive text | Long-press selection, may cover fields |
| Email | Email-optimised, @ key prominent | Disabled | Domain shortcuts (.com, .org, .net) |
| Address | Standard text | Active on all fields | Applies to state abbreviations |
| QRCodeFormField | N/A | N/A | Full-screen ML Kit camera |
| RichText | N/A | N/A | Memory leak with 10+ fields |

#### Android Behaviors {comprehensive}
| Field | Keyboard | Voice Input | Performance Notes |
|-------|----------|-------------|-------------------|
| TextField/MultilineText/TemplatedString | Standard text | Extended dictation, gesture typing | Voice may create run-on text |
| Email | Email layout, @ symbol | Available, struggles with @ | Space bar often hidden |
| Address | Text keyboard | Standard | Validation lag on older devices |
| QRCodeFormField | N/A | N/A | Full-screen scanner |
| RichText | N/A | N/A | Slower parsing than iOS |

#### Web/Desktop Behaviors {important}
- **Full functionality**: TextField, MultipleTextField, TemplatedString
- **Email**: Browser may display envelope icon, native validation supplements Yup
- **Address**: Full keyboard navigation in expanded state
- **QRCodeFormField**: Completely non-functional, shows disabled interface
- **RichText**: Stable rendering, minimal performance impact

### Shared Limitations {important}

#### Designer Interface Constraints {important}
- Cannot switch component variants via GUI (TextField variants)
- Advanced features require JSON editing
- No visual preview of validation behaviour
- Pattern validation requires manual regex entry
- Template syntax not validated (TemplatedString)
- Row count requires numeric input (MultilineText)
- MDX Editor accepts invalid markdown without warning (RichText)
- Table Editor available but tables removed at runtime (RichText)

#### Export Behavior {important}

See [Data Export Reference](data-export-reference.md) for comprehensive export documentation including CSV/JSON formats, special character handling, and Excel issues.

**Text Field-Specific Export Notes**:
- **RichText**: Never exported - for form definition only
- **Address**: CSV exports as JSON string in cell requiring parsing; JSON preserves nested structure  
- **TemplatedString**: Only exports generated value, template not included
- **MultipleTextField**: Line breaks preserved but may break some CSV readers
- **QRCodeFormField**: Exports scanned value only, no scan metadata

#### Component Architecture {comprehensive}

**Standard Components**:
- **TextField/MultilineText**: formik-material-ui components
- **Email**: TextField with `type="email"` configuration

**Custom Components**:
- **TemplatedString**: `faims-custom::TemplatedStringField`
- **Address**: `faims-custom::AddressField` with complex JSON storage
- **QRCodeFormField**: `qrcode::QRCodeFormField` with ML Kit integration
- **RichText**: `faims-custom::RichText` with markdown rendering

**Display-Only Architecture (RichText)**:
- Requires full field definition despite no data operations
- Maintains `type-returned` and `validationSchema` for consistency
- Never participates in form data or validation

#### Accessibility Compliance {important}

**Compliant Fields** (WCAG 2.1 Level AA):
- TextField, MultipleTextField, TemplatedString, Email
- Minimum touch target size (44√ó44px)
- Proper label association
- Keyboard navigation support
- Screen reader compatibility
- Error message announcement
- Sufficient color contrast (3:1 minimum)

**Non-Compliant Fields**:
- Address: Edit button below WCAG minimum touch target
- RichText: Complete absence of ARIA attributes and accessibility features
- QRCodeFormField: No manual entry alternative

#### Testing Guidelines {comprehensive}

**Pre-Deployment Testing Checklist**:
- [ ] Test with empty data (all fields blank)
- [ ] Test with partial data (some fields filled)
- [ ] Test with maximum content length
- [ ] Test special characters and Unicode
- [ ] Test on minimum supported devices
- [ ] Test offline/sync scenarios
- [ ] Verify export formats preserve data
- [ ] Check accessibility with screen reader
- [ ] Test with malicious input (security)
- [ ] Monitor performance with typical load

---

## Field Reference {essential}

### TextField / FAIMSTextField (FAIMS Text Field in Designer) {essential}
<!-- keywords: single-line, text, input, brief -->
**Designer Label**: FAIMS Text Field
**Component Name**: FAIMSTextField (enhanced) or TextField (base - Email only)
**Namespace**: faims-custom (FAIMSTextField) or formik-material-ui (TextField)

Note: Designer's "FAIMS Text Field" creates FAIMSTextField. The base TextField is only accessible through "Email" field configuration.

#### Purpose {essential}
Single-line text input for brief, unconstrained textual data. Primary choice for codes, identifiers, and short annotations.

#### Core Configuration {essential}
```json
{
  "component-namespace": "formik-material-ui",
  "component-name": "TextField",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "site-code",
    "label": "Site Code",
    "helperText": "Enter 3-letter site code",
    "required": true
  },
  "validationSchema": [
    ["yup.string"],
    ["yup.required", "Site code is required"],
    ["yup.matches", "^[A-Z]{3}$", "Must be 3 capital letters"]
  ],
  "initialValue": ""
}
```

#### TextField Variants {important}
1. **Standard TextField** (formik-material-ui): Default with basic features, used for Email
2. **FAIMSTextField** (faims-custom): Enhanced with expandable help, resizable UI
3. **Basic TextField** (core-material-ui): Raw MUI component, rarely used directly

#### TextField-Specific Validation {important}
See [Common Characteristics > Common Validation Patterns] for standard rules

#### TextField-Specific Issues {important}
For solutions, see [Troubleshooting Guide > Quick Fixes Table]
- Users exceed 50 character recommendation
- Mobile keyboards cover input
- Pattern validation errors unclear
- No character counter displayed
- Mobile keyboard wrong type: Configure InputProps.type (`"email"`, `"tel"`, `"url"`)
- FAIMSTextField features missing: Check namespace and advancedHelperText


#### JSON Anti-patterns

‚ùå **NEVER: Wrong initialValue type**
```json
{
  "component-name": "TextField",
  "initialValue": null  // ERROR: "Cannot read property 'length' of null"
}
```
‚úÖ **ALWAYS: Use empty string for text fields**
```json
{
  "initialValue": ""  // Correct for all string-type fields
}
```

‚ùå **NEVER: Validation schema in wrong order**
```json
{
  "validationSchema": [
    ["yup.required", "Required"],  // ERROR: "yup.required is not a function"
    ["yup.string"]
  ]
}
```
‚úÖ **ALWAYS: Type declaration first**
```json
{
  "validationSchema": [
    ["yup.string"],  // Type first
    ["yup.required", "Required"]  // Then constraints
  ]
}
```

‚ùå **NEVER: Wrong component name for enhanced variant**
```json
{
  "component-namespace": "faims-custom",
  "component-name": "TextField"  // ERROR: Component not found
}
```
‚úÖ **ALWAYS: Match namespace to component**
```json
// Option 1: FAIMS enhanced text field
{
  "component-namespace": "faims-custom",
  "component-name": "FAIMSTextField"  // Enhanced version
}
// Option 2: Formik TextField (for Email or basic text)
{
  "component-namespace": "formik-material-ui",
  "component-name": "TextField"  // Standard version
}
// Option 3: Core MUI (rarely needed)
{
  "component-namespace": "core-material-ui",
  "component-name": "TextField"  // Basic MUI component
}
```


#### Common Spec Mappings
- "Enter [identifier/code]" ‚Üí TextField with pattern validation
- "Record [name/label]" ‚Üí TextField with maxLength
- "Input [reference]" ‚Üí TextField with required validation
- "Type [brief description]" ‚Üí TextField (if <50 chars expected)

### MultilineText / MultipleTextField (Text Field in Designer) {essential}
<!-- keywords: multiline, textarea, paragraph, narrative -->
**Designer Label**: Text Field  
**Component Name**: MultipleTextField
**Namespace**: formik-material-ui

Note: Despite the confusing name, Designer's "Text Field" creates a multi-line text area (MultipleTextField component).

#### Purpose {essential}
Extended text entry for narrative content, detailed observations, and interpretative discourse exceeding single-line constraints. Fixed-height field with internal scrolling.

#### Core Configuration {essential}
```json
{
  "component-namespace": "formik-material-ui",
  "component-name": "MultipleTextField",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "site-description",
    "label": "Site Description",
    "multiline": true,
    "InputProps": {
      "rows": 4
    }
  }
}
```

#### Row Configuration {important}
- **Default**: 4 rows
- **Recommended**: 4-6 for general use
- **Maximum practical**: 8-10 for extensive content
- Fixed height - no auto-expansion

#### Content Handling {important}
- Preserves all formatting (tabs, spaces, line breaks)
- Whitespace-only input converts to empty string
- Internal scrolling when content exceeds visible area
- No rich text formatting - plain text only
- Performance degrades beyond 10,000 characters (see [Common Characteristics > Performance Boundaries])

#### MultilineText-Specific Features {important}
- Enter key creates new lines (not form submission)
- Touch scrolling within field boundaries
- Voice dictation supports paragraph breaks
- Can be used in conditional logic despite length

#### MultilineText-Specific Issues {important}
- Users may not notice internal scrollbar
- Fixed height can hide content
- Performance degrades beyond 10,000 characters (see [Common Characteristics > Performance Boundaries])
- Line breaks may not preserve in some exports
- Voice input creates run-on text (Android): Manual paragraph breaks needed (see [Troubleshooting Guide > Common Problems Table])


#### JSON Anti-patterns

‚ùå **NEVER: Wrong component name**
```json
{
  "component-name": "MultilineTextField",  // ERROR: Component doesn't exist
  "component-parameters": {
    "multiline": true
  }
}
```
‚ùå **NEVER: Use "MultilineText" as component name**
```json
{
  "component-name": "MultilineText",  // ERROR: Not the actual component name
}
```
‚úÖ **ALWAYS: Use MultipleTextField**
```json
{
  "component-name": "MultipleTextField",  // Correct component name
  "component-parameters": {
    "multiline": true,
    "InputProps": {"rows": 4}
  }
}
```

‚ùå **NEVER: Missing multiline flag**
```json
{
  "component-name": "MultipleTextField",
  "component-parameters": {
    "rows": 4  // ERROR: rows alone doesn't work
  }
}
```
‚úÖ **ALWAYS: Set multiline and use InputProps.rows**
```json
{
  "component-parameters": {
    "multiline": true,
    "InputProps": {"rows": 4}  // Correct structure
  }
}
```


#### Common Spec Mappings
- "Describe [observation]" ‚Üí MultilineText with 4-6 rows
- "Notes on [subject]" ‚Üí MultilineText with helperText
- "Comments" ‚Üí MultilineText, usually optional
- "Detailed description" ‚Üí MultilineText with 8+ rows

### TemplatedString (Templated String Field in Designer) {essential}
<!-- keywords: hrid, template, mustache, auto-generate, identifier -->
**Designer Label**: Templated String Field
**Component Name**: TemplatedStringField
**Namespace**: faims-custom

Note: Every notebook must have at least one TemplatedString configured as the hridField.

#### Purpose {essential}
Auto-generates text values from other fields using Mustache templates. **MANDATORY** for Human-Readable Identifiers (HRIDs) - every notebook must have at least one configured as `hridField`.

#### Core Configuration {essential}
```json
{
  "component-namespace": "faims-custom",
  "component-name": "TemplatedStringField",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "record-id",
    "template": "{{site}}-{{date}}-{{counter}}",
    "readOnly": true
  }
}
```

#### Template Syntax {important}
- **Variable substitution**: `{{fieldName}}`
- **Conditional sections**: `{{#field}}content{{/field}}`
- **Inverted sections**: `{{^field}}if empty{{/field}}`
- **System variables**: `{{_CREATED_BY}}`, `{{_CREATED_TIME}}`
- **Parent fields**: `{{_PARENT_.fieldname}}`

#### Critical Implementation Notes {important}
- Must be in same form as referenced fields
- Updates automatically when source fields change
- Deep equality comparison for complex fields
- Cannot reference other TemplatedStrings (circular reference)
- HTML escaping disabled - security risk with user input (see [Common Characteristics > Security Considerations])

#### TemplatedString-Specific Troubleshooting {important}
- **Template returns empty**: Verify field names match (case-sensitive), check console
- **Shows [object Object]**: Using complex field types - only use for conditional checking
- **Not updating**: Check for circular references between templates


#### JSON Anti-patterns

‚ùå **NEVER: User text input without sanitization (CRITICAL SECURITY RISK)**
```json
{
  "template": "Record: {{user-text-field}}"
  // If user enters: <script>alert('XSS')</script>
  // HTML escaping is DISABLED (formUtilities.ts line 27) - script WILL execute!
}
```
‚úÖ **ALWAYS: Use controlled vocabularies or sanitize**
```json
{
  "template": "{{record-type}}-{{counter}}"  // record-type is a Select field
  // OR implement sanitization in preprocessing layer

‚ùå **NEVER: Include any user-editable field in templates**
```json
// ALL OF THESE ARE DANGEROUS:
{
  "template": "Site: {{site_name}}"  // XSS if site_name is TextField
}
{
  "template": "{{description}}-{{id}}"  // XSS if description is user input
}
{
  "template": "Notes: {{field_notes}}"  // XSS if field_notes is MultilineText
}
```

‚úÖ **ALWAYS: Use only system-generated or controlled fields**
```json
// SAFE PATTERNS:
{
  "template": "{{_USER}}-{{_YYYY}}-{{auto_increment}}"
}
{
  "template": "{{record_type}}-{{counter}}"  // IF record_type is Select/Radio
}
{
  "template": "SITE-{{_MM}}{{_DD}}-{{_id}}"
}
```
}
```

‚ùå **NEVER: Reference another TemplatedString**
```json
{
  "template": "{{other-template}}-{{number}}"  // ERROR: Circular reference risk
  // where other-template is also a TemplatedString
}
```
‚úÖ **ALWAYS: Reference only non-template fields**
```json
{
  "template": "{{site}}-{{date}}-{{counter}}"  // All are basic input fields
}
```

‚ùå **NEVER: Reference fields from different forms**
```json
{
  "template": "{{parent.field}}-{{local-field}}"  // ERROR: Can't access parent
}
```
‚úÖ **ALWAYS: Keep all referenced fields in same form**
```json
{
  "template": "{{field1}}-{{field2}}"  // Both in same form
}
```


#### Common Spec Mappings
- "Auto-generate ID" ‚Üí TemplatedString with counter
- "Create identifier" ‚Üí TemplatedString with date/user pattern
- "Reference number" ‚Üí TemplatedString with prefix-counter
- "HRID field" ‚Üí TemplatedString (REQUIRED in every notebook)

### Email {essential}
<!-- keywords: email, validation, address, contact -->

#### Core Configuration {essential}
```json
{
  "component-namespace": "formik-material-ui",
  "component-name": "TextField",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "email-field",
    "label": "Email Address",
    "InputProps": {
      "type": "email"
    }
  }
}
```

#### Email-Specific Validation {important}
| Rule | Schema | Purpose | Error Message |
|------|--------|---------|---------------|
| required | `["yup.required", "Email is required"]` | Mandatory field | "Email is required" |
| email format | `["yup.email", "Enter a valid email"]` | Format validation | "Enter a valid email" |
| string type | `["yup.string"]` | Type enforcement | Type error (rare) |

**Accepted Formats**: user@domain.com, user+tag@domain.com, first.last@domain.com, user_name@domain.com, user-name@domain-name.com, user@mail.company.com, user123@domain.com

**Rejected Formats**: Missing @ symbol or domain, spaces within address, double @ symbols, leading/trailing dots, missing top-level domain

#### Email-Specific Limitations {important}
- No multiple emails (array input not supported)
- No domain restrictions without custom validation
- No contact integration (device contacts)
- No verification (format only, not deliverability)
- No auto-lowercase (case preserved as entered)
- No duplicate checking

#### Email-Specific Troubleshooting {important}
Also see [Troubleshooting Guide > Common Problems Table] for general validation issues
- **Validation too strict**: Actually permissive; check for spaces
- **Plus addresses rejected**: Supported; check other issues
- **Keyboard missing @**: Ensure `InputProps.type` set to "email"


#### JSON Anti-patterns

‚ùå **NEVER: Wrong type-returned**
```json
{
  "component-name": "TextField",
  "type-returned": "faims-core::String",  // ERROR: Mismatched types
  "component-parameters": {
    "InputProps": {"type": "email"}
  }
}
```
‚úÖ **ALWAYS: Email fields return String**
```json
{
  "type-returned": "faims-core::String",  // Correct - emails are strings
  "component-parameters": {
    "InputProps": {"type": "email"}
  }
}
```

‚ùå **NEVER: Look for an Email component**
```json
{
  "component-namespace": "ANY-namespace",
  "component-name": "Email"  // ERROR: No Email component exists in ANY namespace
}
```
‚úÖ **ALWAYS: Use TextField with email type**
```json
{
  "component-name": "TextField",
  "component-parameters": {
    "InputProps": {"type": "email"}
  }
}
```


#### Common Spec Mappings
- "Contact email" ‚Üí Email field with validation
- "Researcher email" ‚Üí Email with domain restriction
- "Notification address" ‚Üí Email, often optional
- "Primary contact" ‚Üí Email with required validation

### Address {essential}
<!-- keywords: address, geocode, json, australian, beta -->

#### Core Configuration {essential}
```json
{
  "component-namespace": "faims-custom",
  "component-name": "AddressField",
  "name": "site-address",
  "type-returned": "faims-core::JSON"
}
```

#### Address-Specific Storage {important}
```json
{
  "display_name": "123 Main St, Parramatta, NSW, 2150",
  "address": {
    "house_number": "123",
    "road": "Main St",
    "town": "",
    "suburb": "Parramatta",
    "municipality": "",
    "state": "NSW",
    "postcode": "2150",
    "country": "",
    "country_code": ""
  }
}
```

**CSV Export**: Complete JSON in single column, requires post-processing:
```python
import pandas as pd
import json
df = pd.read_csv('export.csv')
df['address_data'] = df['site_address'].apply(json.loads)
df['postcode'] = df['address_data'].apply(lambda x: x['address']['postcode'])
```

#### Address-Specific Interactions {important}
1. Collapsed field shows current value or "Empty"
2. Click/tap edit icon to expand
3. Enter data across five optional fields
4. System generates display name
5. Field collapses on blur

**‚ö†Ô∏è Race Condition Warning**: Rapid tabbing between fields may trigger data loss. Allow 500ms pause between field entries.

#### Address-Specific Issues {important}
- **Beta Feature Status**: Commissioned functionality for specific client
- **No country field in UI**: Only 5 of 9 data fields exposed
- **JSON expertise required**: Post-processing needed for analysis
- **Touch target concern**: Edit button below WCAG minimum


#### JSON Anti-patterns

‚ùå **NEVER: Wrong initialValue for Address**
```json
{
  "component-name": "AddressField",
  "initialValue": ""  // ERROR: Field shows "Empty" permanently
}
```
‚úÖ **ALWAYS: Use null for Address fields**
```json
{
  "component-name": "AddressField",
  "initialValue": null  // Correct for JSON-type fields
}
```

‚ùå **NEVER: Wrong validation schema**
```json
{
  "validationSchema": [
    ["yup.string"]  // ERROR: Address returns JSON object
  ]
}
```
‚úÖ **ALWAYS: Use object validation**
```json
{
  "validationSchema": [
    ["yup.object"],
    ["yup.nullable"]  // Allow empty state
  ]
}
```

‚ùå **NEVER: Wrong type-returned**
```json
{
  "component-name": "AddressField",
  "type-returned": "faims-core::String"  // ERROR: Returns complex object
}
```
‚úÖ **ALWAYS: Address returns JSON**
```json
{
  "type-returned": "faims-core::JSON"  // Correct type
}
```


#### Common Spec Mappings
- "Site location" ‚Üí Address field with map integration
- "Postal address" ‚Üí Address with validation
- "Physical location" ‚Üí Address with coordinate extraction
- "Office address" ‚Üí Address, usually optional

### QRCodeFormField {essential}
<!-- keywords: barcode, scanner, mobile-only, qrcode -->

#### Core Configuration {essential}
```json
{
  "component-namespace": "qrcode",
  "component-name": "QRCodeFormField",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "label": "Scan Barcode",
    "name": "barcode-field",
    "helperText": "Position barcode within frame",
    "fullWidth": true
  }
}
```

#### Supported Barcode Formats {important}
1. QR Code ‚Äì Most common 2D format
2. Code 128 ‚Äì High-density linear barcode
3. Code 39 ‚Äì Alphanumeric linear format
4. Code 93 ‚Äì Compact linear barcode
5. Codabar ‚Äì Numeric with special characters
6. Data Matrix ‚Äì Compact 2D format
7. EAN-13 ‚Äì European Article Number
8. EAN-8 ‚Äì Shortened EAN variant
9. ITF ‚Äì Interleaved 2 of 5
10. UPC-E ‚Äì Compressed UPC format
11. UPC-A ‚Äì Standard retail barcode
12. PDF417 ‚Äì Multi-row 2D format
13. Aztec ‚Äì Compact 2D format

#### QRCode-Specific Validation {important}
- **10-scan mechanism**: Must read identical value 10 consecutive times
- **No user feedback**: Silent validation process
- **Silent reset**: Different barcode during validation resets counter
- **‚ö†Ô∏è CRITICAL**: Never mark as required (breaks web forms completely)

#### Mobile Scanning Workflow {important}
1. Tap blue "Scan barcode" button
2. Camera permission requested on first use
3. Full-screen scanner launches
4. Position barcode in frame
5. **Hidden**: Scanner validates 10 consecutive identical reads
6. Success: Value captured, returns to form
7. Different barcode: Counter resets silently
8. Cancel: Back button leaves field empty

#### QRCode-Specific Issues {important}
- **Scanner won't complete**: Ensure single barcode visible, hold steady 3-4 seconds
- **Web platform**: Completely non-functional, disabled interface
- **No manual entry**: Pair with TextField for fallback


#### JSON Anti-patterns

‚ùå **NEVER: Mark as required (CRITICAL PLATFORM ISSUE)**
```json
{
  "component-name": "QRCodeFormField",
  "validationSchema": [
    ["yup.string"],
    ["yup.required", "Scan required"]  // ERROR: Breaks ALL web users!
  ]
}
```
‚úÖ **ALWAYS: Keep optional or pair with TextField**
```json
{
  "component-name": "QRCodeFormField",
  "validationSchema": [["yup.string"]]  // Never add required
  // Pair with TextField for web fallback
}
```

‚ùå **NEVER: Assume cross-platform functionality**
```json
{
  "component-name": "QRCodeFormField",
  "component-parameters": {
    "helperText": "Scan or type barcode"  // ERROR: No typing capability
  }
}
```
‚úÖ **ALWAYS: Document platform limitation**
```json
{
  "component-parameters": {
    "helperText": "Scan barcode (mobile only)"
  }
}
```


#### Common Spec Mappings
- "Scan barcode" ‚Üí QRCodeFormField + TextField fallback
- "Equipment ID" ‚Üí QRCodeFormField for mobile scanning
- "Sample code" ‚Üí QRCodeFormField with manual entry option
- "QR code data" ‚Üí QRCodeFormField, never required

### RichText {essential}
<!-- keywords: display, markdown, instructions, static, memory-leak -->

#### Core Configuration {essential}
```json
{
  "component-namespace": "faims-custom",
  "component-name": "RichText",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "field-id",
    "content": "# Heading\n\nInstructional text with **markdown** formatting."
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""
}
```

#### RichText-Specific Behavior {important}

**Rendering Pipeline**:
1. markdown-it processes content with `typographer: true`
2. DOMPurify strips dangerous elements with hardcoded whitelist
3. Sanitized HTML inserted via `dangerouslySetInnerHTML`
4. **No caching**: Re-executes entire pipeline on every render

**Security Filtering** - Allowed Elements:
- Text: `<p>`, `<span>`, `<strong>`, `<em>`, `<u>`, `<s>`, `<code>`, `<pre>`
- Headers: `<h1>` through `<h6>`
- Lists: `<ul>`, `<ol>`, `<li>`
- Links: `<a>` (with href, title, target="_blank")
- Images: `<img>` (Base64 only, external URLs blocked)

**Blocked at Runtime** (despite Designer support):
- Tables: `<table>`, `<tr>`, `<td>`, `<th>`
- Blockquotes: `<blockquote>`
- All scripts, forms, media, styles

#### RichText-Specific Limitations {important}
- **Memory leak**: Never releases parsed HTML, crashes mobile with 10+ fields
- **No accessibility**: Complete absence of ARIA attributes
- **Designer-runtime mismatch**: Tables/blockquotes disappear
- **No memoization**: Reparsed on every render (20-50ms overhead)
- **Error display**: Shows only "Error" with no diagnostics
- **No RTL support**: No bidirectional text handling
- **Export invisibility**: Never appears in any export format
- **No dynamic content**: Cannot reference field values
- **No interactivity**: Pure display component

---


#### JSON Anti-patterns

‚ùå **NEVER: Expect data storage**
```json
{
  "component-name": "RichText",
  "component-parameters": {
    "name": "important-data",  // ERROR: Never stores data
    "content": "Enter notes here"
  }
}
```
‚úÖ **ALWAYS: Use only for display**
```json
{
  "component-name": "RichText",
  "component-parameters": {
    "content": "## Instructions\n\nThis is display-only text"
  }
}
```

‚ùå **NEVER: Include user-generated content in RichText**
```json
// DANGEROUS - XSS RISK:
{
  "content": "User said: {{user_comment}}"  // Script injection risk
}
{
  "content": "# {{title_from_user}}"  // XSS if title contains scripts
}
```

‚úÖ **ALWAYS: Use static, developer-controlled content only**
```json
// SAFE:
{
  "content": "## Field Instructions\n\nPlease complete all required fields"
}
{
  "content": "### Validation Rules\n\n- Minimum 3 characters\n- No special characters"
}
```

‚ùå **NEVER: External image URLs**
```json
{
  "content": "![Diagram](https://example.com/image.png)"  
  // ERROR: External images blocked by security
}
```
‚úÖ **ALWAYS: Use Base64 embedded images**
```json
{
  "content": "![Diagram](data:image/png;base64,iVBORw0KGg...)"
  // Images must be <100KB for performance
}
```

‚ùå **NEVER: Tables in content**
```json
{
  "content": "| Header | Value |\n|--------|-------|\n| Data | 123 |"
  // Tables stripped at runtime despite Designer support
}
```
‚úÖ **ALWAYS: Use lists or embedded images**
```json
{
  "content": "**Data Values:**\n- Header: 123\n- Other: 456"
  // Or embed table as Base64 image
}
```

### The Most Expensive Mistakes

1. **QRCodeFormField with required validation** = Web users permanently blocked from submission
2. **TemplatedString with user text fields** = XSS vulnerability, security breach possible
3. **Circular TemplatedString references** = Form crashes with stack overflow
4. **RichText >10 fields on mobile** = Memory leak causes app crash, data loss
5. **Address with initialValue: ""** = Field becomes permanently invalid, no recovery
6. **MultilineText wrong component name** = Field doesn't render, form incomplete
7. **Email as custom component** = Component not found, form won't load
8. **TextField with null initialValue** = Runtime errors, validation fails
9. **Validation schema wrong order** = No validation applied, data integrity compromised
10. **External images in RichText** = Content missing, user confusion
11. **Designer name as component name** = Component not found, form fails to load
12. **Wrong namespace for component** = Component not found errors, debugging confusion

### Prevention Checklist

Before deploying any notebook:
- [ ] All text fields use `initialValue: ""`
- [ ] Address fields use `initialValue: null`
- [ ] No QRCodeFormField has required validation
- [ ] All TemplatedStrings avoid user text input
- [ ] MultilineText uses "MultipleTextField" component
- [ ] Email fields are TextField with type="email"
- [ ] RichText has no tables or external images
- [ ] Validation schemas have type declaration first
- [ ] No circular template references exist
- [ ] Platform limitations documented in helper text

---


#### Common Spec Mappings
- "Instructions" ‚Üí RichText with markdown formatting
- "Guidelines" ‚Üí RichText with numbered lists
- "Warning text" ‚Üí RichText with bold/emphasis
- "Form header" ‚Üí RichText with heading markdown

## Troubleshooting Guide {important}


### Error Message Reference {important}

**Note**: Most error messages come from Yup validation schemas defined in individual notebooks, not the FAIMS3 codebase itself.

| Common Validation Scenario | Affected Fields | What Happens | Solution |
|---------------------------|-----------------|--------------|----------|
| Required field left empty | All text fields | Yup validation error (message varies by notebook) | Enter value or make field optional |
| Email format invalid | Email field | HTML5 + Yup email validation | Ensure @ symbol and valid domain |
| Pattern mismatch | TextField with regex | Yup.matches validation error | Check pattern defined in notebook |
| Whitespace-only input | All text fields | Saved as empty string (no error) | Enter actual content |
| Invalid Mustache template | TemplatedString | Silent failure - no output generated | Check {{}} syntax, field references |
| QR scan not accepting | QRCodeFormField | Camera needs 10 consecutive identical reads for confidence (~0.3 sec) | Hold steady on code until accepted |
| Address malformed JSON | Address | Field may not save properly | Use Designer interface |
| RichText not exporting | RichText | By design - display only, never exports | Not an error - expected behavior |
| Character limits | TextField/MultipleTextField | No hard limits in code (notebook-specific) | Check notebook's validation schema |
| Form won't submit on web | Required QRCodeFormField | Web platform cannot scan | Remove required validation or add fallback TextField |


### Quick Reference Matrix {important}

| If you see... | First try... | Then try... | Last resort... |
|---------------|--------------|-------------|----------------|
| XSS vulnerability warning | Remove user fields from template | Use static values only | Switch to TextField |
| "Maximum characters" error | Switch to MultipleTextField | Split content | Reduce content |
| QR scan won't complete | Hold steady ~0.3 sec | Check code quality | Use manual entry |
| Email validation fails | Check @ and domain | Remove special characters | Use TextField |
| Address field shows JSON | Expected behavior in CSV | Use JSON parser | Manual extraction |
| RichText not exporting | By design - display only | Document separately | Screenshot |
| Template not generating | Check field references | Verify syntax {{}} | Check field names |
| Whitespace becomes empty | Enter actual content | Check validation | Make field optional |
| Form stuck on web with QR | Remove required from QR field | Add TextField fallback | Mobile-only deployment |
| Multiline text cut off | Increase rows setting | Check CSV reader settings | Export as JSON |
### Validation Issues {important}

#### Validation Not Displaying {important}
**Affects**: TextField, MultipleTextField, TemplatedString, Email, Address  
**Symptom**: Required field not showing error  
**Cause**: Field hasn't been "touched"  
**Solution**: Field must gain focus then blur to show errors  
See [Common Characteristics > Validation Patterns > Validation Behavior]

#### Cannot Submit Form on Web {important}
**Affects**: QRCodeFormField  
**Symptom**: Validation error on web browser  
**Cause**: QRCodeFormField marked required  
**Solution**: Remove required validation or implement manual entry field

### Critical Issues Table {important}

| Symptom | Field Type | Cause | Immediate Action | Fix | Prevent |
|---------|------------|-------|------------------|-----|---------|
| Form cannot be submitted on web | QRCodeFormField | Required validation breaks web platform | Remove required validation | Never mark QRCodeFormField as required | Pair with TextField for web fallback |
| Maximum call stack exceeded | TemplatedString | Circular reference between templates | Remove circular references | Templates cannot reference other TemplatedStrings | Validate template references before deployment |
| App crashes with multiple fields | RichText | Memory leak accumulation (>10 fields) | Restart app immediately | Limit to <10 RichText fields, <1000 total words | Monitor RichText count and content volume |
| XSS vulnerability exposed | TemplatedString | HTML escaping disabled with user input | Remove user text fields from templates | Use controlled vocabularies only | Never include free-text fields in templates |
| Data disappears while typing | Address | Race condition when tabbing quickly | Save form immediately | Allow 500ms pause between field entries | Train users on deliberate entry |
| Form won't load | Any field | Wrong component name or namespace | Check browser console | Verify exact component names and namespaces | Use documentation component mapping |
| Field permanently shows "Empty" | Address | initialValue set to "" instead of null | Change initialValue to null | Address must use null not empty string | Check all JSON field types |
| Scanner never completes | QRCodeFormField | Multiple barcodes or movement during scan | Isolate single barcode | Hold steady 3-4 seconds for 10-scan validation | Train on scanning requirements |
| Validation prevents all edits | Any field | Required added to populated field | Remove required temporarily | Test validation before applying to existing data | Add validation only to new fields |

### Common Problems Table {important}

| Symptom | When | Why | Try This | If That Fails | Long Term |
|---------|------|-----|----------|---------------|-----------|
| Required field not showing error | After form submission attempt | Field hasn't been "touched" | Click field then click away | Check validation schema order | Train users on validation timing |
| Email validation too strict | Entering institutional addresses | Actually permissive - check for spaces | Remove all spaces from email | Check for typos in address | Document accepted formats |
| Content exceeds field boundaries | TextField >50 chars | Single-line limitation | Switch to MultilineText | Reduce content length | Set character limits upfront |
| Tables/blockquotes disappear | RichText at runtime | DOMPurify strips unsupported elements | Use formatted lists or Base64 images | Create image of complex content | Document runtime limitations |
| External images don't display | RichText content | Security blocks external URLs | Convert to Base64 embedded images | Use images <100KB only | Train on image requirements |
| Line breaks lost in export | MultilineText CSV export | Reader settings issue | Configure CSV reader for multiline | Use specific delimiter settings | Document export requirements |
| JSON in single column | Address CSV export | Complex object export behavior | Post-process with Python/scripts | Extract needed fields only | Provide extraction scripts |
| @ symbol missing on keyboard | Email field mobile | Wrong keyboard type | Ensure InputProps.type="email" | Type @ manually | Test on target devices |
| Performance degrades | >30 text fields per section | Form evaluation overhead | Paginate form sections | Reduce fields per section | Design with limits in mind |
| No character counter shown | TextField/MultilineText | Not built into component | Add count to helperText | Use FAIMSTextField variant | Set expectations clearly |

### Quick Fixes Table {important}

| Want To | Use This | Not This | Because | Example |
|---------|----------|----------|---------|---------|
| Single-line text in Designer | FAIMS Text Field | Text Field | "Text Field" creates multiline | FAIMSTextField component |
| Multi-line text in Designer | Text Field | FAIMS Text Field | Despite confusing name | MultipleTextField component |
| Email with validation | Email field | Custom TextField config | Email field pre-configured | Includes type="email" automatically |
| Manual barcode entry | Paired TextField | QRCodeFormField alone | QRCode is mobile-only | Add fallback TextField |
| Display instructions | RichText | TemplatedString | RichText for static content | TemplatedString needs field references |
| Structured address | Address field | Multiple TextFields | Unless JSON complexity an issue | Consider data extraction needs |
| Character limit enforcement | validationSchema with yup.max | inputProps.maxLength alone | Validation provides user feedback | ["yup.max", 50, "Maximum 50 characters"] |
| Template with user input | Controlled vocabulary fields | Free text fields | XSS vulnerability risk | Use Select/RadioGroup in templates |
| Fix "Empty" Address display | initialValue: null | initialValue: "" | Address requires null | JSON fields need null not empty string |
| Prevent race condition | 500ms pause between fields | Rapid tabbing | Address field state updates | Train deliberate data entry |

### Debug Checklists {comprehensive}

#### General Field Checklist {comprehensive}
- [ ] Field name unique within form
- [ ] component-namespace matches component type
- [ ] type-returned is correct type
- [ ] initialValue is "" not null (or null for Address)
- [ ] Label concise and clear

#### Field-Specific Checks {comprehensive}

**TemplatedString**:
- [ ] Template syntax uses `{{field}}`
- [ ] All referenced fields exist
- [ ] hridField configured in viewset
- [ ] No circular template references
- [ ] User input sanitized if included

**TextField/Email**:
- [ ] Correct variant (standard vs FAIMS)
- [ ] InputProps.type appropriate
- [ ] Validation schema complete

**MultilineText**:
- [ ] multiline: true set
- [ ] InputProps.rows configured
- [ ] Content limits documented

**Address**:
- [ ] Component-namespace is "faims-custom"
- [ ] Type-returned is "faims-core::JSON"
- [ ] Team trained in data extraction

**QRCodeFormField**:
- [ ] Never marked as required
- [ ] Manual fallback field provided
- [ ] Platform compatibility documented

**RichText**:
- [ ] Content brief (<50 words per field)
- [ ] No tables or blockquotes
- [ ] Images Base64 encoded
- [ ] Test on mobile for memory issues

### Field-Specific Issues {important}

#### Address Field Race Condition {important}
**Symptom**: Data disappears when quickly tabbing between fields  
**Cause**: State update race condition  
**Solution**: 
- Allow 500ms pause between entries
- Use Tab key rather than mouse
- Save form frequently
- Consider separate TextFields for critical data

#### QRCodeFormField Scanner Issues {important}
**Scanner won't complete**: 
- Ensure single barcode visible
- Hold steady 3-4 seconds
- Clean barcode if dirty
- Isolate from other barcodes

**Permission denied**:
- Settings > Apps > Fieldmark > Permissions > Camera > Enable
- Reload app after permission grant

---

## JSON Examples {comprehensive}

### TextField Examples {important}

#### Basic Site Code {important}
```json
{
  "site-code": {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "site-code",
      "label": "Site Code",
      "helperText": "3-letter site identifier",
      "placeholder": "e.g., SYD",
      "required": true,
      "fullWidth": false,
      "variant": "outlined"
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Site code is required"],
      ["yup.matches", "^[A-Z]{3}$", "Must be exactly 3 capital letters"]
    ],
    "initialValue": ""
  }
}
```

// VARIANT: Email configuration (adds type and email validation)
{
  "contact-email": {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "contact-email",
      "label": "Contact Email",
+     "InputProps": {
+       "type": "email"
+     },
      "required": true
    },
+   "validationSchema": [
+     ["yup.string"],
+     ["yup.email", "Invalid email format"],
+     ["yup.required", "Email is required"]
+   ],
    "initialValue": ""
  }
}

// VARIANT: Pattern validation (adds regex matching)
{
  "specimen-id": {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "specimen-id",
      "label": "Specimen ID",
+     "helperText": "Format: ABC-1234",
      "required": true
    },
+   "validationSchema": [
+     ["yup.string"],
+     ["yup.matches", "^[A-Z]{3}-[0-9]{4}$", "Format must be ABC-1234"],
+     ["yup.required"]
+   ],
    "initialValue": ""
  }
}

// VARIANT: Optional with character limit
{
  "brief-notes": {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "brief-notes",
      "label": "Brief Notes",
+     "helperText": "Optional, max 50 characters",
+     "inputProps": { "maxLength": 50 },
-     "required": true
+     "required": false
    },
+   "validationSchema": [
+     ["yup.string"],
+     ["yup.max", 50, "Maximum 50 characters"]
+   ],
-   "initialValue": ""
+   "initialValue": null
  }
}

#### FAIMSTextField with Advanced Help {comprehensive}
```json
{
  "unit-designation": {
    "component-namespace": "faims-custom",
    "component-name": "FAIMSTextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "unit-designation",
      "label": "Excavation Unit",
      "helperText": "Format: [Area]-T[Trench]-[Unit]",
      "advancedHelperText": "# Unit Designation System\n\nEach excavation unit follows a three-part code:\n\n1. Area: Single letter (A-Z)\n2. Trench: T + number\n3. Unit: 3-digit with leading zeros",
      "required": true
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Unit designation required"],
      ["yup.matches", "^[A-Z]-T\\d+-\\d{3}$", "Invalid format"]
    ],
    "initialValue": ""
  }
}
```

### MultilineText Example {important}

#### Detailed Interpretation Field {important}
```json
{
  "interpretation": {
    "component-namespace": "formik-material-ui",
    "component-name": "MultipleTextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "interpretation",
      "label": "Site Interpretation",
      "helperText": "Provide detailed interpretative narrative (minimum 200 characters)",
      "placeholder": "Describe the site significance, cultural context, and preliminary interpretations...",
      "required": true,
      "fullWidth": true,
      "multiline": true,
      "InputProps": {
        "rows": 6
      }
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Interpretation is required"],
      ["yup.min", 200, "Please provide at least 200 characters"],
      ["yup.max", 10000, "Maximum 10,000 characters"]
    ],
    "initialValue": "",
    "meta": {
      "uncertainty": {
        "include": true,
        "label": "Interpretation confidence"
      }
    }
  }
}
```

### TemplatedString Examples {important}

// VARIANT: Larger text area with word count validation
{
  "extended-notes": {
    "component-namespace": "formik-material-ui",
    "component-name": "MultipleTextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "extended-notes",
      "label": "Extended Field Notes",
-     "InputProps": { "rows": 6 }
+     "InputProps": { "rows": 10 },
+     "helperText": "Maximum 2000 words"
    },
+   "validationSchema": [
+     ["yup.string"],
+     ["yup.test", "word-count", "Maximum 2000 words",
+       "value => !value || value.split(/\\s+/).length <= 2000"]
+   ]
  }
}

#### Complex HRID with System Variables {important}
For security considerations with user variables, see [Common Characteristics > Security Considerations]
```json
{
  "record-identifier": {
    "component-namespace": "faims-custom",
    "component-name": "TemplatedStringField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "record-identifier",
      "template": "{{site}}-{{_CREATED_TIME}}-{{excavator}}-{{counter}}",
      "readOnly": true
    }
  }
}
```


// VARIANT: Safer template without user input (XSS prevention)
{
  "safe-identifier": {
    "component-namespace": "faims-custom",
    "component-name": "TemplatedStringField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "safe-identifier",
-     "template": "{{site}}-{{_CREATED_TIME}}-{{excavator}}-{{counter}}",
+     "template": "{{_USER}}-{{_YYYY}}{{_MM}}{{_DD}}-{{auto_increment}}",
+     "helperText": "Auto-generated ID using system fields only"
    }
  }
}
#### Conditional Template with Boolean Logic {comprehensive}
```json
{
  "_has_photos": {
    "component-namespace": "faims-custom",
    "component-name": "TemplatedStringField",
    "component-parameters": {
      "name": "_has_photos",
      "template": "{{#photos}}true{{/photos}}{{^photos}}false{{/photos}}",
      "hidden": true
    },
    "initialValue": "false"
  }
}
```

### Email Field Pattern {important}
```json
{
  "principal-investigator-email": {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Principal Investigator Email",
      "name": "principal-investigator-email",
      "helperText": "Required for data access requests",
      "required": true,
      "InputProps": {
        "type": "email"
      }
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.email", "Valid email required"],
      ["yup.required", "PI email is mandatory"]
    ],
    "initialValue": ""
  }
}
```

### Address Field Pattern {important}
```json
{
  "site-street-address": {
    "component-namespace": "faims-custom",
    "component-name": "AddressField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Site Street Address",
      "name": "site-street-address",
      "helperText": "Enter the formal street address for site access",
      "required": false,
      "fullWidth": true
    },
    "validationSchema": [["yup.object"], ["yup.nullable"]],
    "initialValue": null,
    "meta": {
      "annotation": {
        "include": true,
        "label": "Address notes (e.g., alternative access points)"
      }
    }
  }
}
```

### QRCodeFormField with Manual Fallback {important}
```json
{
  "artefact-id-scan": {
    "component-namespace": "qrcode",
    "component-name": "QRCodeFormField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Scan Artefact Tag",
      "name": "artefact-id-scan",
      "helperText": "Use mobile scanner for barcode"
    },
    "initialValue": ""
  },
  "artefact-id-manual": {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Or Enter Artefact ID Manually",
      "name": "artefact-id-manual",
      "helperText": "Type ID if scanner unavailable"
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.matches", "^[A-Z]{3}-\\d{4}-\\d{3}$", "Format: ABC-2024-001"]
    ]
  }
}
```

### RichText Conditional Instructions {important}
```json
{
  "excavation-warning": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "excavation-warning",
      "content": "‚ö†Ô∏è **STOP**: Consult heritage officer before excavation.\n\nThis site requires special permits."
    },
    "condition": {
      "field": "heritage-status",
      "operator": "equal",
      "value": "protected"
    }
  }
}
```

---

## Migration Scenarios {comprehensive}

### Migration Decision Tree {comprehensive}

Reviewing existing text fields?
‚îÇ
‚îú‚îÄ Missing HRID field?
‚îÇ  ‚îî‚îÄ YES ‚Üí URGENT: Add TemplatedString as hridField
‚îÇ
‚îú‚îÄ TextField with long content?
‚îÇ  ‚îî‚îÄ YES ‚Üí Migrate to MultilineText
‚îÇ     ‚îî‚îÄ Update rows parameter
‚îÇ
‚îú‚îÄ MultilineText with brief content?
‚îÇ  ‚îî‚îÄ YES ‚Üí Consider TextField for efficiency
‚îÇ
‚îú‚îÄ QRCodeFormField on web?
‚îÇ  ‚îî‚îÄ YES ‚Üí Add paired TextField fallback
‚îÇ
‚îî‚îÄ RichText with data capture need?
‚îî‚îÄ YES ‚Üí Replace with appropriate input field

### Migration Warnings Index

#### Safe Migrations (No Data Loss)
- `SAFE` TextField ‚Üí MultilineText when content exceeds limits
- `SAFE` Adding TemplatedString to existing notebook
- `SAFE` Adding validation patterns to TextField
- `SAFE` Increasing MultilineText rows parameter

#### Breaking Changes (Data Loss Risk)  
- `BREAKS` Changing field names (orphans all data)
- `BREAKS` MultilineText ‚Üí TextField if content >200 chars
- `BREAKS` Adding required validation to populated fields
- `BREAKS` Modifying TemplatedString pattern after data collection

### Migration Procedures
For ready-to-use scripts, see [Migration Script Templates] below

#### Designer Version Migration {comprehensive}

**Component Architecture Clarification**:
- FAIMSTextField: Enhanced single-line (Designer: "FAIMS Text Field")
- TextField: Base component, only via Email field in Designer
- MultipleTextField: Multi-line text area (Designer: "Text Field")

**Legacy Patterns to Avoid**:
```json
// ‚ùå Old pattern - TextField with multiline:true
{
  "component-namespace": "formik-material-ui",
  "component-name": "TextField",
  "component-parameters": {
    "multiline": true  // Deprecated approach
  }
}

// ‚úÖ Current pattern - Use MultipleTextField
{
  "component-namespace": "formik-material-ui", 
  "component-name": "MultipleTextField",
  "component-parameters": {
    "multiline": true,
    "InputProps": {"rows": 4}
  }
}
```

**Pre-2024 Notebooks**: May use different component naming:
- Legacy "TextFormField" ‚Üí migrate to "FAIMSTextField"  
- Legacy "TextArea" ‚Üí migrate to "MultipleTextField"
- Legacy plain "TextField" ‚Üí migrate to "FAIMSTextField" or configure as Email

#### TextField to MultilineText Migration
When content regularly exceeds 50 characters:
1. Change component-name to "MultipleTextField"
2. Add `multiline: true`
3. Set appropriate `InputProps.rows`
4. Adjust validation thresholds
5. Update helper text expectations

#### Adding TemplatedString to Existing Notebook {comprehensive}
1. Define HRID pattern based on existing data
2. Add TemplatedString field configuration
3. Set as `hridField` in viewset
4. Test with sample data
5. Note: Existing records won't auto-update

### Training Requirements {important}

#### Basic Training (All Users)
- Platform-specific keyboard behaviors
- Understanding validation timing
- When to use annotations vs main field
- Character limit awareness

#### Advanced Training (Data Managers)
- JSON structure of Address fields
- TemplatedString pattern design
- Export format handling
- QRCodeFormField platform limitations

#### Field Supervisor Training
- Choosing appropriate text field types
- Vocabulary development strategies
- Quality assurance protocols

### Migration Script Templates {comprehensive}

Ready-to-use migration scripts for common text field conversions:

#### Template 1: TextField to MultilineText Migration
```javascript
// Complete migration script for expanding single-line to multi-line fields
const migrateTextFieldToMultiline = (records, fieldName) => {
  const migrated = [];
  const oversized = [];
  
  records.forEach((record, index) => {
    const content = record[fieldName];
    if (content && content.length > 50) {
      oversized.push({
        index,
        recordId: record._id,
        length: content.length,
        preview: content.substring(0, 100) + '...'
      });
    }
    // Content migrates as-is, just the field config changes
    migrated.push(record);
  });
  
  console.log(`Total records: ${records.length}`);
  console.log(`Oversized content (>50 chars): ${oversized.length}`);
  
  // Update field configuration
  const newConfig = {
    "component-namespace": "formik-material-ui",
    "component-name": "MultipleTextField",  // Changed from TextField
    "component-parameters": {
      "multiline": true,
      "InputProps": {
        "rows": 4  // Adjust based on average content length
      }
    }
  };
  
  return {migrated, oversized, newConfig};
};

// Usage
const results = migrateTextFieldToMultiline(allRecords, 'description_field');
if (results.oversized.length > 0) {
  console.log('Records with long content:', results.oversized);
}
```

#### Template 2: Adding TemplatedString HRID to Existing Notebook
```javascript
// Script to generate HRIDs for existing records without them
const addHRIDsToExistingRecords = (records, pattern) => {
  const updated = [];
  const conflicts = [];
  const usedHRIDs = new Set();
  
  // First pass: collect existing HRIDs if any
  records.forEach(record => {
    if (record.hrid_field) {
      usedHRIDs.add(record.hrid_field);
    }
  });
  
  // Second pass: generate HRIDs for records without them
  records.forEach((record, index) => {
    if (!record.hrid_field) {
      // Generate HRID based on pattern and existing fields
      let hrid = pattern
        .replace('{{site}}', record.site || 'UNKNOWN')
        .replace('{{date}}', record.date || new Date().toISOString().split('T')[0])
        .replace('{{counter}}', String(index + 1).padStart(4, '0'));
      
      // Check for conflicts
      let suffix = 1;
      const baseHRID = hrid;
      while (usedHRIDs.has(hrid)) {
        hrid = `${baseHRID}-${suffix}`;
        suffix++;
        conflicts.push({recordId: record._id, attemptedHRID: baseHRID, finalHRID: hrid});
      }
      
      record.hrid_field = hrid;
      usedHRIDs.add(hrid);
      updated.push({recordId: record._id, newHRID: hrid});
    }
  });
  
  console.log(`Generated HRIDs for ${updated.length} records`);
  if (conflicts.length > 0) {
    console.log(`Resolved ${conflicts.length} HRID conflicts`);
  }
  
  return {records, updated, conflicts};
};

// Usage
const hridPattern = '{{site}}-{{date}}-{{counter}}';
const results = addHRIDsToExistingRecords(allRecords, hridPattern);
```

#### Template 3: Address Field JSON Data Extraction
```python
import pandas as pd
import json

def extract_address_components(csv_file, address_field='site_address'):
    """
    Extract structured address data from JSON-stored Address fields
    """
    # Read CSV with Address field as string
    df = pd.read_csv(csv_file, dtype={address_field: str})
    
    # Initialize component columns
    components = ['house_number', 'road', 'suburb', 'state', 'postcode', 'display_name']
    for component in components:
        df[f'addr_{component}'] = ''
    
    # Process each row
    processed = 0
    errors = []
    
    for idx, row in df.iterrows():
        try:
            if pd.notna(row[address_field]) and row[address_field]:
                # Parse JSON
                addr_data = json.loads(row[address_field])
                
                # Extract display name
                if 'display_name' in addr_data:
                    df.at[idx, 'addr_display_name'] = addr_data['display_name']
                
                # Extract address components
                if 'address' in addr_data:
                    addr = addr_data['address']
                    for component in ['house_number', 'road', 'suburb', 'state', 'postcode']:
                        if component in addr:
                            df.at[idx, f'addr_{component}'] = addr[component]
                
                processed += 1
        except json.JSONDecodeError as e:
            errors.append({'row': idx, 'error': str(e)})
        except Exception as e:
            errors.append({'row': idx, 'error': str(e)})
    
    print(f"Successfully processed {processed} address fields")
    if errors:
        print(f"Errors in {len(errors)} rows: {errors[:5]}")  # Show first 5 errors
    
    # Save processed data
    output_file = csv_file.replace('.csv', '_addresses_extracted.csv')
    df.to_csv(output_file, index=False)
    print(f"Saved to: {output_file}")
    
    return df

# Usage
df = extract_address_components('export.csv', 'site_address')

# Additional analysis examples
print("\nAddress Statistics:")
print(f"Records with addresses: {df['addr_display_name'].notna().sum()}")
print(f"Unique suburbs: {df['addr_suburb'].nunique()}")
print(f"State distribution:\n{df['addr_state'].value_counts()}")
```

#### Template 4: Sanitizing User Input for TemplatedString
```javascript
// Sanitize user text fields before including in templates
const sanitizeForTemplate = (record, fieldName) => {
  let value = record[fieldName] || '';
  
  // Remove HTML/Script tags
  value = value.replace(/<[^>]*>/g, '');
  
  // Remove potential template injection
  value = value.replace(/{{.*?}}/g, '');
  
  // Remove SQL injection characters
  value = value.replace(/['";\\]/g, '');
  
  // Keep only alphanumeric, spaces, and basic punctuation
  value = value.replace(/[^a-zA-Z0-9\s\-_.,]/g, '');
  
  // Trim and limit length
  value = value.trim().substring(0, 50);
  
  return value;
};

// Batch sanitization before template evaluation
const sanitizeAllTextFields = (records, textFields) => {
  const sanitized = records.map(record => {
    const clean = {...record};
    textFields.forEach(field => {
      if (clean[field]) {
        clean[`${field}_raw`] = clean[field];  // Keep original
        clean[field] = sanitizeForTemplate(clean, field);
      }
    });
    return clean;
  });
  
  return sanitized;
};

// Usage
const textFieldsToSanitize = ['user_notes', 'description', 'comments'];
const safeRecords = sanitizeAllTextFields(records, textFieldsToSanitize);

// Now safe to use in templates:
// "{{site}}-{{sanitized_user_notes}}-{{counter}}"
```

#### Template 5: Character Limit Validation Check
```javascript
// Pre-migration check for character limits
const validateCharacterLimits = (records, limits) => {
  const violations = [];
  
  Object.entries(limits).forEach(([fieldName, maxLength]) => {
    records.forEach((record, index) => {
      const value = record[fieldName];
      if (value && value.length > maxLength) {
        violations.push({
          recordId: record._id || index,
          field: fieldName,
          currentLength: value.length,
          maxLength: maxLength,
          preview: value.substring(0, 100) + '...',
          overflow: value.length - maxLength
        });
      }
    });
  });
  
  // Group violations by field
  const byField = violations.reduce((acc, v) => {
    if (!acc[v.field]) acc[v.field] = [];
    acc[v.field].push(v);
    return acc;
  }, {});
  
  // Summary report
  console.log('\n=== Character Limit Validation Report ===');
  Object.entries(byField).forEach(([field, items]) => {
    console.log(`\n${field} (max: ${limits[field]} chars):`);
    console.log(`  - Violations: ${items.length}`);
    console.log(`  - Max overflow: ${Math.max(...items.map(i => i.overflow))} chars`);
    console.log(`  - Affected records: ${items.slice(0, 3).map(i => i.recordId).join(', ')}...`);
  });
  
  return violations;
};

// Usage
const fieldLimits = {
  'site_code': 50,      // TextField recommended
  'description': 10000, // MultilineText maximum
  'email': 254,         // RFC compliance
  'identifier': 30      // Custom limit
};

const violations = validateCharacterLimits(allRecords, fieldLimits);
if (violations.length > 0) {
  console.log(`\nAction required for ${violations.length} field values`);
}

## Best Practices {comprehensive}

### Design Principles
- Choose field types based on expected content length and structure
- Consider mobile user experience when configuring scanning fields
- Implement fallback patterns for platform-specific components
- Use TemplatedString for all human-readable identifiers

### Performance Optimization
- Monitor character limits for MultilineText performance
- Consider field pairing for QR scanning with manual fallbacks
- Implement proper debouncing for Address autocomplete
- Use appropriate row configurations for multi-line fields

### Data Quality Strategies
- Implement server-side validation for all text inputs
- Use validation patterns to prevent data inconsistencies
- Apply proper sanitization for TemplatedString templates
- Configure appropriate helper text for user guidance

### Common Patterns
- Pair QRCodeFormField with TextField for cross-platform support
- Use FAIMSTextField for enhanced help capabilities
- Configure Address fields with proper debouncing
- Implement proper HRID patterns with TemplatedString

### Field-Specific Best Practices {comprehensive}

#### Email Field {comprehensive}
- Provide clear helper text indicating email purpose
- Use placeholder sparingly to avoid confusion
- Consider privacy implications
- Document retention policies
- Test validation with institution-specific formats
- Include data protection notices where appropriate

#### Address Field {comprehensive}
**For Australian Projects**:
- Leverage optimised Australian format
- Use annotation fields for access notes
- Standardise state abbreviations (NSW, VIC, QLD)
- Include postcode for regional analysis

**For International Projects**:
- Add separate country TextField
- Document country codes in guidelines
- Consider separate TextFields for flexibility
- Establish clear data entry conventions

**For High-Volume Entry**:
- Enter data deliberately to avoid race conditions
- Use desktop platforms when possible
- Implement regular save routines
- Consider bulk import via JSON

#### QRCodeFormField {comprehensive}
- Consider pairing with TextField for manual entry fallback
- Never mark as required (web compatibility)
- Document scanning requirements explicitly
- Employ manual platform selection if needed
- Design recovery workflows for permission denial
- Test on all target platforms
- Provide clear helper text about mobile-only functionality
- Consider value transformation needs early
- Plan data reconciliation for paired fields
- Train field teams on 10-scan requirement

#### RichText {comprehensive}
**Content Guidelines**:
- Keep content brief: <50 words per field, <1000 total
- Use semantic headers: h2/h3 for navigation
- Embed critical images: Base64 for essential diagrams
- Write accessible content: Clear language, logical flow
- Test in runtime: Verify Designer content displays

**Performance Optimization**:
- Limit field count: Maximum 10 RichText fields
- Avoid conditional toggling: Minimize visibility changes
- Monitor mobile memory: Test on lowest-spec devices
- Batch related content: Combine instructions

**Common Anti-Patterns to Avoid**:
- ‚ùå Using RichText for dynamic content
- ‚ùå Creating tables (won't display)
- ‚ùå Embedding large images (>100KB)
- ‚ùå Writing documentation essays
- ‚ùå Conditional visibility on frequently-changing fields
- ‚ùå Assuming external images will work
- ‚ùå Ignoring memory accumulation on mobile

### Implementation Notes {comprehensive}

#### TextField/MultilineText Implementation {comprehensive}
Standard formik-material-ui components with predictable behavior across platforms.

#### TemplatedString Implementation {comprehensive}
Critical for notebook functionality. Must be in same form as referenced fields. Updates automatically when source fields change. Deep equality comparison for complex fields. Cannot reference other TemplatedStrings.

#### Email Field Implementation {comprehensive}
Not a distinct component but rather a TextField with email-specific configuration. This design pattern reduces code duplication whilst maintaining consistent behaviour across text input variants.

#### Address Field Implementation {comprehensive}
**Beta Feature Status**: Commissioned functionality for specific client requirements. Prioritises structured data capture over analytical convenience. Technical users can extract components through post-processing.

**Performance Considerations**:
- Form validation triggers on every keystroke
- Deep cloning occurs during updates
- Large addresses increase JSON payload size
- No character limits may impact database performance

#### QRCodeFormField Implementation {comprehensive}
Architecture reflects fundamental tension between data integrity and user experience. Ten-scan validation ensures exceptional accuracy but operates without user feedback.

**Critical considerations**:
- Platform Strategy: Design separate mobile and web form variants, or pair with TextField
- Validation Design: Never use required validation due to web incompatibility
- Error Recovery: Implement comprehensive fallback patterns
- User Training: Document the hidden 10-scan requirement
- Data Processing: Plan for external value transformation

Component name "QRCodeFormField" is a misnomer ‚Äì scanner processes thirteen barcode formats with equal capability.

#### RichText Implementation {comprehensive}
Requirement for full field definition despite non-participation in data operations reveals fundamental tensions in Fieldmark's architecture. Treating display elements as fields ensures consistent handling but imposes unnecessary overhead.

**Rendering Inconsistencies**: Synchronous parsing and sanitisation pipeline executes on every render without memoisation, prioritising security over performance.

**Export Invisibility**: Exclusion from all export formats creates documentation gaps when notebooks serve as methodological records.

**Image Restrictions**: External image whitelist configuration (empty by default) effectively prohibits external image embedding.

### Cross-References Between Fields {comprehensive}
- **TextField** ‚Üî **MultilineText**: Migration when content exceeds 50 chars
- **TextField** ‚Üí **Email**: Configuration for email capture
- **TextField** ‚Üî **FAIMSTextField**: Enhanced variant with advanced help
- **TemplatedString** ‚Üí **All fields**: Can reference any field for templates
- **QRCodeFormField** ‚Üí **TextField**: Essential pairing for manual fallback
- **Address** ‚Üí **TextField**: Alternative for simple address storage
- **RichText** ‚Üí **TemplatedString**: For dynamic vs static content

### External Documentation {comprehensive}
- BasicAutoIncrementer - Sequential numbering for templates
- Select/RadioGroup - Controlled vocabularies for templates
- TakePhoto - Referenced in TemplatedString examples
- Conditional Logic Guide - Visibility patterns
- Form Design Best Practices - Optimizing form performance
- Memory Management Guide - Mobile optimization strategies
- Accessibility Compliance - WCAG requirements and workarounds

---

## Field Quirks Index (2025-08) {comprehensive}

### TextField
- `RULE` Maximum 50 characters recommended for optimal display
- `RULE` 254 character limit for Shapefile DBF export compatibility
- `QUIRK` No character counter displayed to users
- `QUIRK` iOS keyboard may cover fields with predictive text
- `QUIRK` Voice input creates run-on text without punctuation
- `FIX` Implement character counter in helperText:
  ```json
  "component-parameters": {
    "helperText": "Site identifier (max 50 characters)",
    "inputProps": { "maxLength": 50 }  // Hard limit
  }
  ```
  For dynamic counter, use FAIMSTextField with: `"helperText": "Enter description (recommended: 20-50 characters)"`
- `TEST` Character limit: If notebook defines maxLength, verify enforcement at configured limit
- `TEST` Whitespace handling: Enter only spaces - should save as empty string (no error shown)
- `TEST` Special characters: Enter <>&"\x27 - verify proper display in form and export
- `TEST` Voice input: Use device voice input - verify text appears without formatting
- `VERSION` 2025-08

### MultilineText  
- `RULE` Component name is "MultipleTextField" not "MultilineTextField"
- `RULE` Use InputProps.rows to set visible height
- `QUIRK` Fixed height display - no auto-expansion
- `QUIRK` Performance degrades beyond 10,000 characters
- `QUIRK` CSV export may need specific reader settings for line breaks
- `FIX` Configure rows based on content type:
  - Brief notes (100-200 chars): `rows: 3`
  - Descriptions (200-500 chars): `rows: 5`
  - Detailed observations (500-1000 chars): `rows: 8`
  - Extensive narratives (1000+ chars): `rows: 10`
  - Set as: `"InputProps": { "rows": 5 }`  // Most common
- `FIX` Add validation for content length:
  ```json
  "validationSchema": [
    ["yup.string"],
    ["yup.max", 10000, "Content exceeds 10,000 character recommendation"],
    ["yup.test", "word-count", "Maximum 2000 words", 
      "value => !value || value.split(/\\s+/).length <= 2000"]
  ]
  ```
  Monitor in browser console: `formik.values['field-name'].length`
- `TEST` Auto-expansion: Enter text exceeding visible rows - field should NOT auto-expand
- `TEST` Line break export: Enter multi-line text, export to CSV - verify line breaks preserved or escaped
- `TEST` Performance limit: Paste 10,000+ characters - check for lag or freezing
- `TEST` Word count validation: If configured, enter 2001 words - should show validation error
- `VERSION` 2025-08

### TemplatedString
- `RULE` Must exist as hridField in every notebook
- `RULE` Cannot reference other TemplatedString fields
- `RULE` Must be in same form as referenced fields
- `QUIRK` HTML escaping disabled (formUtilities.ts line 27) [Security Risk]
- `QUIRK` Shows [object Object] for complex fields
- `QUIRK` Shows [object Blob] for file/photo fields
- `QUIRK` Template syntax not validated in Designer
- `QUIRK` Silent failure for invalid templates
- `FIX` Handle complex fields with Mustache conditionals:
  - Photos: `{{#photos}}has-photos{{/photos}}{{^photos}}no-photos{{/photos}}`
  - Relationships: `{{#relationship}}linked{{/relationship}}`
  - Files: `{{#attachment}}attached{{/attachment}}`
  - Never direct reference: `{{photos}}` shows "[object Blob]"
  - Alternative: Create hidden boolean field for complex logic
- `FIX` Sanitize user input before template inclusion:
  - Basic HTML escape: `.replace(/[<>'"&]/g, '')`
  - Alphanumeric only: `.replace(/[^a-zA-Z0-9\s-]/g, '')`
  - SQL-safe: `.replace(/['";\\]/g, '')`
  - Best practice: Use Select/RadioGroup instead of free text
  - Never use TextField values directly in templates
- `FIX` Test templates systematically:
  1. In Designer > Preview, enter test values:
     - Empty fields: verify fallback behavior
     - Special chars: test with &, <, >, ", '
     - Max length: use expected maximum values
  2. Export test records to verify output format
  3. Document expected outputs: `"{{site}}-{{date}}"` ‚Üí `"SITE01-2025-08"`
- `TEST` XSS vulnerability: Create template with `{{user_field}}`, enter `<script>alert("XSS")</script>` - WARNING: script WILL execute (HTML escaping disabled)
- `TEST` HRID presence: Run `grep "hrid_field_name" notebook.json` - must return exactly one result
- `TEST` Template generation: Create record, export, verify HRID format matches template pattern
- `TEST` Reference validation: Try referencing field from different form - should fail or show empty
  4. Test edge cases: null, undefined, empty string
- `VERSION` 2025-08

### Email
- `RULE` Is TextField configuration with type="email", not separate component
- `RULE` Uses HTML5 email validation plus Yup patterns
- `QUIRK` Space bar often hidden on mobile keyboards
- `QUIRK` Voice input struggles with @ symbol
- `QUIRK` Browser may display envelope icon inconsistently
- `FIX` Use explicit email helper text:
  ```
  "helperText": "Institutional email only (e.g., name@university.edu.au)"
  // Or for specific requirements:
  "helperText": "Project contact email (no spaces, lowercase recommended)"
  // For multiple domains:
  "helperText": "Accepted domains: @uni.edu.au, @museum.gov.au"
  ```
- `FIX` Add domain-specific email validation:
  ```json
  // Australian institutions:
  ["yup.matches", "@[\\w.-]+\\.edu\\.au$", "Must be .edu.au email"]
  // Government only:
  ["yup.matches", "@[\\w.-]+\\.gov\\.au$", "Must be .gov.au email"]
  // Multiple allowed domains:
  ["yup.matches", "@(uni\\.edu|museum\\.gov|dept\\.org)\\.au$", 
    "Must be institutional email"]
  ```
- `TEST` Basic validation: Enter "test@" - should fail; "test@example.com" - should pass
- `TEST` Space handling: Enter "test @example.com" - should fail validation
- `TEST` Domain restriction: If configured for .edu.au, test with .com - should fail
- `TEST` Mobile keyboard: Verify @ symbol accessible on mobile email keyboard
- `VERSION` 2025-08

### QRCodeFormField
- `RULE` Mobile-only functionality - no web support
- `RULE` Never mark as required (breaks web forms completely)
- `RULE` Supports 13 barcode formats despite name
- `QUIRK` Requires 10 consecutive identical camera reads for confidence (automatic, ~0.3 sec)
- `QUIRK` Web platform shows disabled interface that breaks validation
- `QUIRK` Silent counter reset if camera reads different barcode during validation
- `QUIRK` No manual entry option built-in
- `FIX` Implement scanner/manual field pairing:
  ```json
  {
    "barcode-scan": {
      "component-namespace": "qrcode",
      "component-name": "QRCodeFormField",
      "component-parameters": {
        "label": "Scan Barcode (Mobile Only)",
        "name": "barcode-scan"
      }
    },
    "barcode-manual": {
      "component-namespace": "formik-material-ui",
      "component-name": "TextField",
      "component-parameters": {
        "label": "Or Enter Barcode Manually",
        "name": "barcode-manual",
        "helperText": "Type if scanner unavailable"
      }
    }
  }
  ```
  Data reconciliation: Check both fields, prefer scan if present
- `FIX` Add explicit scanning instructions:
  ```
  "helperText": "Hold device steady for 3-4 seconds. Ensure single barcode visible. Mobile app only - use manual entry on web."
  ```
  For training materials: `"helperText": "Scanner requires: 1) Mobile device 2) Camera permission 3) Good lighting 4) Clean barcode 5) Steady hold"`
- `FIX` Implement platform-aware conditional display:
  ```json
  // Add platform detection field:
  {
    "is-mobile": {
      "component-name": "RadioGroup",
      "component-parameters": {
        "label": "Device Type",
        "options": [
          {"value": "mobile", "label": "Mobile (iOS/Android)"},
          {"value": "web", "label": "Web Browser"}
        ]
      }
    }
  }
  // Then use conditions:
  "condition": {"field": "is-mobile", "operator": "equal", "value": "mobile"}
  ```
- `TEST` Scan confidence: Hold camera steady on code - should accept after ~0.3 seconds (10 consecutive reads)
- `TEST` Web platform behavior: Open on desktop browser - verify field shows disabled state with message
- `TEST` Different code interference: While scanning code A, briefly show code B - validation counter resets
- `TEST` Required field validation: Set as required, open on web - form should be unsubmittable
- `TEST` Barcode format support: Test with QR, Code128, EAN13 - all should scan successfully
- `VERSION` 2025-08

### Address
- `RULE` Beta feature - prioritises structure over convenience
- `RULE` Stores data as GeocodeJSON-compliant format
- `QUIRK` Edit button below WCAG minimum touch target (44√ó44px)
- `QUIRK` Exports as complete JSON in single CSV column
- `QUIRK` Race condition when quickly tabbing between fields
- `QUIRK` No character limits may impact database performance
- `QUIRK` Validation triggers on every keystroke
- `FIX` Prevent Address race condition:
  1. Train users: "Tab once, pause, continue"
  2. Or implement debounced saving: Designer > Advanced > Set debounce: 500
  3. Alternative workaround: Enter all data in one field first, copy-paste to others
  4. For bulk entry: Use CSV import instead
- `FIX` Extract Address components from CSV:
  ```python
  import pandas as pd
  import json
  
  # Read CSV
  df = pd.read_csv('export.csv')
  
  # Parse JSON column
  df['addr'] = df['site_address'].apply(
      lambda x: json.loads(x) if pd.notna(x) else {}
  )
  
  # Extract nested fields
  df['street'] = df['addr'].apply(
      lambda x: x.get('address', {}).get('road', '')
  )
  df['suburb'] = df['addr'].apply(
      lambda x: x.get('address', {}).get('suburb', '')
  )
  df['postcode'] = df['addr'].apply(
      lambda x: x.get('address', {}).get('postcode', '')
  )
  
  # Save processed data
  df.to_csv('processed_addresses.csv', index=False)
  ```
- `FIX` Replace Address field with TextFields for international use:
  ```json
  {
    "addr-line-1": {
      "component-name": "TextField",
      "label": "Address Line 1"
    },
    "addr-line-2": {
      "component-name": "TextField",
      "label": "Address Line 2"
    },
    "addr-city": {
      "component-name": "TextField",
      "label": "City/Town"
    },
    "addr-state": {
      "component-name": "TextField",
      "label": "State/Province/Region"
    },
    "addr-postcode": {
      "component-name": "TextField",
      "label": "Post/ZIP Code"
    },
    "addr-country": {
      "component-name": "Select",
      "label": "Country",
      "options": [/* country list */]
    }
  }
  ```
- `TEST` JSON export: Enter address, export CSV - verify JSON structure in single column
- `TEST` Race condition: Tab quickly through fields - check for lost data or errors
- `TEST` Component extraction: Use Python script above to extract postcode from JSON
- `TEST` Edit button size: On mobile, verify edit button is tappable (may be <44px)
- `VERSION` 2025-08

### RichText
- `RULE` Display-only component - no data capture
- `RULE` Never exported in any format
- `RULE` Requires full field definition despite no data operations
- `QUIRK` Memory leak on mobile - never releases parsed HTML
- `QUIRK` Tables/blockquotes disappear at runtime despite Designer support
- `QUIRK` External images blocked (hardcoded empty whitelist)
- `QUIRK` No accessibility implementation (missing ARIA)
- `QUIRK` Re-parses content on every render without memoization
- `QUIRK` Shows only "Error" with no diagnostics on failure
- `FIX` Monitor and limit RichText content:
  - Word count: `content.split(/\s+/).length`
  - Character count: `content.length`
  - Limits: Per field: 50 words (350 characters), Per form: 1000 words total (7000 characters), Mobile safe: 10 fields maximum
  - Designer helper: `"content": "## Instructions (35 words)\n\nYour content here..."`
- `FIX` Convert images to Base64 for RichText:
  1. Check size first: image should be <100KB (ideally <50KB)
  2. Online tool: https://base64.guru/converter/encode/image
  3. Command line: Mac/Linux: `base64 -i image.png | pbcopy`, Windows: `certutil -encode image.png tmp.b64 && type tmp.b64`
  4. In RichText content: `"content": "![Diagram](data:image/png;base64,iVBORw0KGgo...)"`
  5. Size calculation: Base64 length √ó 0.75 = approx bytes
  6. Optimize first: Use tinypng.com to reduce size
- `FIX` Optimize RichText for memory:
  1. Count RichText fields: Designer > Field List > Filter by "RichText"
  2. If >10 fields needed, use pagination: Section 1: Fields 1-5 (page 1), Section 2: Fields 6-10 (page 2)
  3. Or use conditional visibility: `"condition": {"field": "show-instructions", "value": "true"}`
  4. Monitor in mobile app: iOS: Settings > Fieldmark > Documents & Data, Android: Settings > Apps > Fieldmark > Storage
  5. Clear cache if >100MB
- `FIX` Replace tables with structured lists:
  ```
  // Instead of table:
  | Column1 | Column2 |
  
  // Use formatted list:
  "content": "**Data Summary**\n\n‚Ä¢ **Item 1**: Value 1\n‚Ä¢ **Item 2**: Value 2\n\n---\n\n"
  
  // Or use preformatted text:
  "content": "```\nColumn1    Column2\n-------    -------\nValue1     Value2\n```"
  
  // Or create image of table and embed as Base64
  ```
- `TEST` Data storage: Add RichText field, save record, export - verify no data exported
- `TEST` Table rendering: Include table in markdown - verify it does NOT display
- `TEST` External images: Try external image URL - should NOT load
- `TEST` Base64 images: Embed Base64 image - should display correctly
- `TEST` Memory leak: On mobile, navigate to/from RichText form 10 times - check memory usage
- `VERSION` 2025-08

---

## Performance Thresholds Summary {essential}

See [Performance Thresholds Reference](performance-thresholds-reference.md) for detailed metrics and testing scenarios.

**Text Field Critical Thresholds**:
- **TextField**: 50 chars (mobile viewport), 254 chars (shapefile limit)
- **MultilineText**: 10,000 chars degradation, ~1MB CouchDB limit
- **TemplatedString**: Max 3 per form, 50 variables per template
- **RichText**: 10 per notebook, 50 words per field, 1000 total words
- **QRCodeFormField**: 10 scans for validation, 3-4 second hold time
- **Address**: <500ms between updates to avoid race conditions
- **Form limits**: 30 text fields per section, 50 total per form

---

## JSON Patterns Cookbook (2025-08) {comprehensive}

### TextField Patterns

```json
// BASE PATTERN (all TextField variants inherit this)
{
  "component-namespace": "formik-material-ui",
  "component-name": "TextField",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "field-name",
    "label": "Field Label"
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""
}

// VARIANT: Required with validation
+ "component-parameters": {
+   "required": true,
+   "helperText": "This field is mandatory"
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.required", "Field is required"]
+ ]

// VARIANT: Pattern validation (e.g., site codes)
+ "component-parameters": {
+   "helperText": "Format: ABC-123",
+   "placeholder": "e.g., SYD-001"
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.matches", "^[A-Z]{3}-\\d{3}$", "Invalid format"]
+ ]

// VARIANT: Email configuration
+ "component-parameters": {
+   "InputProps": {"type": "email"}
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.email", "Invalid email address"]
+ ]

// VARIANT: FAIMSTextField with rich help
- "component-namespace": "formik-material-ui"
+ "component-namespace": "faims-custom"
- "component-name": "TextField"
+ "component-name": "FAIMSTextField"
+ "component-parameters": {
+   "advancedHelperText": "## Detailed Instructions\n\nMarkdown formatted help..."
+ }

// VARIANT: Length constraints
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.min", 3, "Minimum 3 characters"],
+   ["yup.max", 50, "Maximum 50 characters"]
+ ]
```

### MultilineText Patterns

```json
// BASE PATTERN (using MultipleTextField component)
{
  "component-namespace": "formik-material-ui",
  "component-name": "MultipleTextField",  // Note the component name!
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "description",
    "label": "Description",
    "multiline": true,
    "InputProps": {
      "rows": 4  // Default rows
    }
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""
}

// VARIANT: Extended text with validation
+ "component-parameters": {
+   "InputProps": {
-     "rows": 4
+     "rows": 8  // More rows for longer content
+   },
+   "required": true,
+   "helperText": "Provide detailed description (200-10000 chars)"
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.required", "Description required"],
+   ["yup.min", 200, "Minimum 200 characters"],
+   ["yup.max", 10000, "Maximum 10,000 characters"]
+ ]

// VARIANT: With uncertainty metadata
+ "meta": {
+   "uncertainty": {
+     "include": true,
+     "label": "Confidence level"
+   }
+ }

// VARIANT: With annotation capability
+ "meta": {
+   "annotation": {
+     "include": true,
+     "label": "Additional notes"
+   }
+ }
```

### TemplatedString Patterns

```json
// BASE: Human-Readable Identifier (HRID)
{
  "component-namespace": "faims-custom",
  "component-name": "TemplatedStringField",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "record-id",
    "label": "Record ID",
    "template": "{{field1}}-{{field2}}"
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""
}

// VARIANT: With auto-incrementer
  "template": "{{site}}-{{year}}-{{counter}}"
  // where counter is BasicAutoIncrementer field

// VARIANT: System variables
  "template": "{{_CREATOR_NAME}}-{{_CREATED_TIME}}-{{id}}"

// VARIANT: Conditional sections
  "template": "{{#type}}{{type}}-{{/type}}{{^type}}UNTYPED-{{/type}}{{number}}"

// VARIANT: Complex nested conditionals
  "template": "{{project}}{{#location}}-{{location}}{{/location}}{{#specimen}}-{{specimen}}{{#subspecimen}}/{{subspecimen}}{{/specimen}}{{/specimen}}"

// VARIANT: Hidden boolean for complex logic
+ "component-parameters": {
+   "hidden": true,  // Not shown in UI
+   "template": "{{#photos}}true{{/photos}}{{^photos}}false{{/photos}}"
+ }

// VARIANT: With validation on generated value
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.required", "ID generation failed"],
+   ["yup.min", 10, "ID too short"]
+ ]
```

### Email Patterns

```json
// EMAIL is a TextField variant with type="email"
{
  "component-namespace": "formik-material-ui",
  "component-name": "TextField",  // Still TextField!
  "type-returned": "faims-core::String",  // Note: NOT Email type
  "component-parameters": {
    "name": "contact-email",
    "label": "Contact Email",
    "InputProps": {
      "type": "email"  // This makes it an email field
    }
  },
  "validationSchema": [
    ["yup.string"],
    ["yup.email", "Invalid email format"]
  ],
  "initialValue": ""
}

// VARIANT: Required institutional email
+ "component-parameters": {
+   "required": true,
+   "helperText": "Use institutional email only"
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.required", "Email is required"],
+   ["yup.email", "Invalid email format"],
+   ["yup.matches", "@(uni\\.edu|gov\\.au)$", "Must use institutional email"]
+ ]
```

### Address Patterns

```json
// BASE: Australian-optimized address
{
  "component-namespace": "faims-custom",
  "component-name": "AddressField",
  "type-returned": "faims-core::JSON",  // Returns JSON not String!
  "component-parameters": {
    "name": "site-address",
    "label": "Site Address",
    "fullWidth": true
  },
  "validationSchema": [
    ["yup.object"],
    ["yup.nullable"]  // Allow null/empty
  ],
  "initialValue": null  // Not empty string!
}

// VARIANT: Required address
+ "component-parameters": {
+   "required": true,
+   "helperText": "Physical address required for access"
+ }
- "validationSchema": [
-   ["yup.object"],
-   ["yup.nullable"]
- ]
+ "validationSchema": [
+   ["yup.object"],
+   ["yup.required", "Address is required"]
+ ]

// VARIANT: With annotation
+ "meta": {
+   "annotation": {
+     "include": true,
+     "label": "Access notes (gate codes, etc.)"
+   }
+ }
```

### QRCodeFormField Patterns

```json
// BASE: Scanner only (mobile-only!)
{
  "component-namespace": "qrcode",
  "component-name": "QRCodeFormField",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "barcode-scan",
    "label": "Scan Barcode"
  },
  "validationSchema": [["yup.string"]],  // NEVER add required!
  "initialValue": ""
}

// VARIANT: With helper text
+ "component-parameters": {
+   "helperText": "Position barcode in frame (mobile only)",
+   "fullWidth": true
+ }

// PAIRED PATTERN: Scanner + Manual fallback (recommended)
{
  "barcode-scan": {
    "component-namespace": "qrcode",
    "component-name": "QRCodeFormField",
    "component-parameters": {
      "name": "barcode-scan",
      "label": "Scan Barcode (Mobile)"
    },
    "initialValue": ""
  },
  "barcode-manual": {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "component-parameters": {
      "name": "barcode-manual",
      "label": "Or Enter Manually",
      "helperText": "Type barcode if scanner unavailable"
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.matches", "^[A-Z0-9]{8,12}$", "Invalid barcode format"]
    ],
    "initialValue": ""
  }
}
```

### RichText Patterns

```json
// BASE: Display-only instructional content
{
  "component-namespace": "faims-custom",
  "component-name": "RichText",
  "type-returned": "faims-core::String",  // Required but never used
  "component-parameters": {
    "name": "instructions",
    "content": "# Instructions\n\n**Important**: Follow these steps..."
  },
  "validationSchema": [["yup.string"]],  // Required but never validates
  "initialValue": ""  // Required but never stores data
}

// VARIANT: Conditional display warning
+ "component-parameters": {
+   "content": "‚ö†Ô∏è **WARNING**: Heritage site - requires permits"
+ }
+ "condition": {
+   "field": "site-type",
+   "operator": "equal",
+   "value": "heritage"
+ }

// VARIANT: With embedded image (Base64 only!)
+ "component-parameters": {
+   "content": "![Diagram](data:image/png;base64,iVBORw0KGg...)"
+ }

// VARIANT: Complex markdown formatting
  "content": "## Section Header\n\n1. First item\n2. Second item\n\n```\nCode block\n```\n\n> Note: Blockquote (won't render at runtime!)"
```

### Common Patterns Across Types

```json
// CONDITIONAL VISIBILITY (any field)
+ "condition": {
+   "field": "trigger-field",
+   "operator": "equal",  // or: not-equal, contains, not-contains
+   "value": "specific-value"
+ }

// METADATA EXTENSIONS (text fields)
+ "meta": {
+   "uncertainty": {
+     "include": true,
+     "label": "Confidence"
+   },
+   "annotation": {
+     "include": true,
+     "label": "Notes"
+   }
+ }

// FULL WIDTH LAYOUT
+ "component-parameters": {
+   "fullWidth": true
+ }

// VISUAL VARIANTS (Material-UI fields)
+ "component-parameters": {
+   "variant": "outlined"  // or: filled, standard
+ }

// DISABLED/READ-ONLY
+ "component-parameters": {
+   "disabled": true  // or InputProps: { readOnly: true }
+ }
```

### Inheritance Hierarchy

```
TextField (base)
‚îú‚îÄ‚îÄ Email (type="email" variant)
‚îú‚îÄ‚îÄ FAIMSTextField (namespace change)
‚îî‚îÄ‚îÄ URL (type="url" variant - undocumented)

MultipleTextField
‚îî‚îÄ‚îÄ (no variants, but supports rows configuration)

TemplatedStringField
‚îî‚îÄ‚îÄ (no variants, template complexity varies)

AddressField
‚îî‚îÄ‚îÄ (no variants, beta feature)

QRCodeFormField
‚îî‚îÄ‚îÄ (no variants, mobile-only)

RichText
‚îî‚îÄ‚îÄ (no variants, display-only)
```

---

## JSON Anti-patterns Quick Index {comprehensive}

Anti-patterns have been distributed to their respective field sections for better context locality. This index provides a quick reference:

### Anti-pattern Categories by Field

- **TextField**: Pattern validation, length constraints, special characters ‚Üí [TextField Anti-patterns](#textfield)
- **MultilineText**: Row configuration, text overflow, voice input ‚Üí [MultilineText Anti-patterns](#multilinetext)
- **TemplatedString**: Template syntax, variable access, counters ‚Üí [TemplatedString Anti-patterns](#templatedstring)
- **Email**: Validation patterns, domain restrictions, format checking ‚Üí [Email Anti-patterns](#email)
- **Address**: Geocoding, validation, component extraction ‚Üí [Address Anti-patterns](#address)
- **QRCodeFormField**: Mobile-only usage, fallback handling, required fields ‚Üí [QRCodeFormField Anti-patterns](#qrcodeformfield)
- **RichText**: Markdown limitations, table handling, formatting ‚Üí [RichText Anti-patterns](#richtext)

### Common Anti-pattern Themes

1. **Component Naming**: Designer UI names vs JSON component names
2. **Validation**: Pattern matching, format constraints, custom rules
3. **Platform Limitations**: Mobile-specific features, browser constraints
4. **Data Types**: String vs object storage, format conversions
5. **User Experience**: Helper text, error messages, default values

## Quick Diagnosis Tables (2025-08) {important}

### When Designer Labels Don't Match Behaviour

| Designer Shows | Expected | Actual Behaviour | Diagnosis | Fix |
|---------------|----------|------------------|-----------|-----|
| FAIMS Text Field | Single line | Multi-line area | Wrong component | Check JSON: should be FAIMSTextField not MultipleTextField |
| Text Field | Multi-line | Single line | Wrong component | Check JSON: should be MultipleTextField not FAIMSTextField |
| Text Field | Multi-line | Nothing renders | Invalid component name | Ensure component-name is "MultipleTextField" |
| FAIMS Text Field | Single line | Error: component not found | Namespace issue | Ensure namespace is "faims-custom" for FAIMSTextField |
| Email | Email validation | Plain text | Missing configuration | TextField needs email-specific parameters |

### When Generation Fails

| Symptom | Field Type | Likely Cause | Quick Fix | Version |
|---------|------------|--------------|-----------|---------|
| Empty HRID displayed | TemplatedString | Missing referenced field | Check field names (case-sensitive) | 2025-08 |
| Shows [object Object] | TemplatedString | Using relationship/complex field | Use only for conditionals {{#field}} | 2025-08 |
| Shows [object Blob] | TemplatedString | Photo/file field in template | Use only for existence checking | 2025-08 |
| Shows "Unknown User" | TemplatedString | System variable null | _CREATOR_NAME may be undefined | 2025-08 |
| Template not updating | TemplatedString | Circular reference | Templates can't reference each other | 2025-08 |
| Template shows literal {{}} | TemplatedString | Field not in same form | All referenced fields must be in same form | 2025-08 |
| Scanner won't complete | QRCodeFormField | Multiple barcodes visible | Isolate single barcode in frame | 2025-08 |
| Scanner won't complete | QRCodeFormField | Not holding steady | Hold 3-4 seconds for 10 scans | 2025-08 |
| Scanner disabled | QRCodeFormField | Web platform | Mobile-only - pair with TextField | 2025-08 |
| Address shows "Empty" | Address | Wrong initialValue | Use null not "" for Address field | 2025-08 |

### When Validation Fails

| Symptom | Field Type | Pattern | Fix | Version |
|---------|------------|---------|-----|---------|
| Required not showing error | All text inputs | Field not "touched" | Field must gain focus then blur | 2025-08 |
| Required field not validating | All text inputs | Wrong schema order | Use [["yup.string"], ["yup.required"]] | 2025-08 |
| Email always invalid | Email | Missing email validation | Add ["yup.email", "Invalid email"] | 2025-08 |
| Email rejecting valid addresses | Email | Actually permissive | Check for spaces or typos | 2025-08 |
| Pattern never matches | TextField | Regex not escaped | Double-escape in JSON: "\\\\d" for \d | 2025-08 |
| Pattern validation on template | TemplatedString | Validates output not template | Pattern applies to generated value | 2025-08 |
| Form won't submit on web | QRCodeFormField | Field marked required | Never use required on QRCodeFormField | 2025-08 |
| Address validation fails | Address | Wrong type | Use [["yup.object"], ["yup.nullable"]] | 2025-08 |
| Validation on empty template | TemplatedString | Template evaluates to "" | Add fallback values in template | 2025-08 |
| Max length exceeded | TextField | >254 chars for Shapefile | Enforce 254 char limit if using Shapefile | 2025-08 |

### When Display Issues Occur

| Symptom | Field Type | Cause | Solution | Version |
|---------|------------|-------|----------|---------|
| Field cut off on mobile | TextField | >50 characters | Switch to MultilineText | 2025-08 |
| No scrollbar visible | MultilineText | Content exceeds rows | Increase InputProps.rows value | 2025-08 |
| Keyboard covers field | TextField | iOS predictive text | Configure InputProps.type | 2025-08 |
| Tables disappear | RichText | DOMPurify strips tables | Use image or formatted list | 2025-08 |
| Blockquotes missing | RichText | Runtime sanitization | Use indented paragraphs instead | 2025-08 |
| Images don't load | RichText | External URLs blocked | Use Base64 embedded images only | 2025-08 |
| Address shows "Empty" | Address | initialValue is "" | Set initialValue to null | 2025-08 |
| @ symbol missing | Email | Wrong keyboard type | Set InputProps.type = "email" | 2025-08 |
| Wrong component name shown | MultilineText | Common confusion | Component is "MultipleTextField" | 2025-08 |
| Edit button too small | Address | Below WCAG minimum | Known issue - use desktop | 2025-08 |

### When Export Issues Occur

| Symptom | Field Type | Format | Issue | Solution | Version |
|---------|------------|--------|-------|----------|---------|
| Leading zeros lost | TemplatedString | CSV in Excel | Excel converts to number | Prefix with letters: "ID-0001" | 2025-08 |
| Line breaks lost | MultilineText | CSV | Reader settings | Configure CSV reader for multiline | 2025-08 |
| JSON in single column | Address | CSV | Complex object export | Post-process with Python/script | 2025-08 |
| Field missing from export | RichText | Any format | Display-only field | Content only in notebook definition | 2025-08 |
| Data truncated | TextField | Shapefile | 254 char DBF limit | Keep under 254 characters | 2025-08 |
| Email truncated | Email | Shapefile | 254 char limit | Use abbreviated addresses | 2025-08 |
| Template shows formula | TemplatedString | CSV | Not the issue | Exports generated value correctly | 2025-08 |
| Special chars corrupted | All text | CSV | Encoding issue | Use UTF-8 encoding | 2025-08 |
| Commas break columns | TextField | CSV | Delimiter conflict | Values auto-quoted if contains comma | 2025-08 |
| Barcode values missing | QRCodeFormField | Any format | No scan metadata | Only raw value exported | 2025-08 |

### When Performance Issues Occur

| Symptom | Field Type | Threshold | Solution | Version |
|---------|------------|-----------|----------|---------|
| Form lag on input | TextField/MultilineText | >30 per section | Paginate form sections | 2025-08 |
| Typing lag | MultilineText | >10,000 chars | Reduce content or use attachments | 2025-08 |
| Mobile app crashes | RichText | >10 fields | Limit to <10 RichText fields | 2025-08 |
| Mobile app crashes | RichText | >1000 total words | Reduce to <1000 words total | 2025-08 |
| Template evaluation slow | TemplatedString | >50 variables | Simplify template logic | 2025-08 |
| Template evaluation slow | TemplatedString | >3 complex templates | Reduce template count per form | 2025-08 |
| Address entry lag | Address | Every keystroke | Known issue - type slowly | 2025-08 |
| Sync fails | All text fields | >5MB total | Reduce content or split forms | 2025-08 |
| Form freezes | All fields | >50 total fields | Implement pagination | 2025-08 |
| Memory exhaustion | RichText | Frequent toggling | Avoid conditional visibility | 2025-08 |

### When Input Issues Occur

| Symptom | Field Type | Context | Solution | Version |
|---------|------------|---------|----------|---------|
| Cannot type value | QRCodeFormField | Any platform | No text input - add TextField | 2025-08 |
| Cannot type value | RichText | Any platform | Display-only - working as designed | 2025-08 |
| Cannot edit template | TemplatedString | Any platform | Read-only - edit source fields | 2025-08 |
| Voice input fails | Email | Android | @ symbol issue - type manually | 2025-08 |
| Voice creates run-on text | MultilineText | Mobile | Add punctuation manually | 2025-08 |
| Data disappears | Address | Fast typing | Race condition - pause 500ms | 2025-08 |
| Space bar hidden | Email | Mobile keyboard | Known issue - use @ key | 2025-08 |
| Auto-caps unwanted | TextField | iOS | Configure autocapitalize attribute | 2025-08 |
| Scanner won't start | QRCodeFormField | First use | Grant camera permission | 2025-08 |
| Permission stuck | QRCodeFormField | After denial | Settings > Apps > Camera > Enable | 2025-08 |

### When Security Issues Occur

| Symptom | Field Type | Risk | Mitigation | Version |
|---------|------------|------|------------|---------|
| XSS vulnerability | TemplatedString | HTML injection | Never include user text fields | 2025-08 |
| Script in template | TemplatedString | Code execution | HTML escaping disabled - sanitize | 2025-08 |
| Malicious barcode | QRCodeFormField | No validation | Add pattern validation to paired field | 2025-08 |
| External content blocked | RichText | Not a bug | Security feature - use Base64 | 2025-08 |
| SQL injection risk | All text inputs | Backend vulnerability | Implement backend validation | 2025-08 |
| Data exposure | Email | Privacy concern | Add retention policy notice | 2025-08 |

---

## Field Interaction Matrix (2025-08) {important}

### Critical Incompatibilities
- `BREAKS` QRCodeFormField + Required validation = Web forms become permanently unsubmittable
- `BREAKS` Multiple RichText (>10) + Mobile = Memory leak accumulation causes app crash
- `BREAKS` TemplatedString referencing another TemplatedString = Circular reference error, silent failure
- `BREAKS` RichText with conditional visibility + Frequent toggling = Memory accumulation crash
- `BREAKS` Address field + Rapid tabbing = Race condition data loss
- `BREAKS` QRCodeFormField + Web platform = Complete functionality loss, disabled interface
- `VERSION` 2025-08

### Required Pairings
- `REQUIRED` Every notebook MUST have at least one TemplatedString configured as hridField
- `REQUIRED` QRCodeFormField MUST pair with TextField for web platform fallback
- `REQUIRED` TemplatedString MUST be in same form as all referenced fields
- `RECOMMENDED` Address field should pair with annotation field for access notes
- `RECOMMENDED` Email field should pair with privacy notice (RichText)
- `VERSION` 2025-08

### Data Type Interactions
- `FORMAT` TemplatedString + BasicAutoIncrementer = String format "0001" not number
- `FORMAT` TemplatedString + Select/RadioGroup = Uses value not label in template
- `FORMAT` TemplatedString + MultiSelect = Shows comma-separated values
- `FORMAT` TemplatedString + Checkbox = String "true"/"false" not boolean
- `FORMAT` TemplatedString + TakePhoto/FileUploader = Shows "[object Blob]" - use only for conditionals
- `FORMAT` TemplatedString + RelationshipField = Shows "[object Object]" - use only for conditionals
- `FORMAT` TemplatedString + Address = Shows full JSON string - requires post-processing
- `FORMAT` TemplatedString + DateTimeField = ISO 8601 format string
- `VERSION` 2025-08

### Platform-Specific Combinations
- `MOBILE-ONLY` QRCodeFormField functional only on iOS/Android
- `WEB-ISSUE` RichText + Tables = Tables stripped at runtime despite Designer support
- `WEB-ISSUE` RichText + External images = Blocked by hardcoded empty whitelist
- `PERFORMANCE` Multiple TemplatedStrings (>3) = Form evaluation lag on all platforms
- `PERFORMANCE` TextField + MultilineText (>30 total) = Form lag begins
- `PERFORMANCE` RichText (>1000 total words) + Mobile = Critical performance impact
- `MOBILE-ISSUE` Email keyboard + Voice input = @ symbol recognition failure
- `MOBILE-ISSUE` TextField predictive text + Short forms = Keyboard covers fields
- `VERSION` 2025-08

### Validation Cascades
- `CASCADE` Required TemplatedString + Empty referenced field = Form submission blocked
- `CASCADE` Required QRCodeFormField on web = Form permanently invalid
- `CASCADE` Pattern validation on TemplatedString = Validates output not template
- `CASCADE` Email validation + Institution formats = May reject valid institutional addresses
- `CASCADE` Address validation + Every keystroke = Performance impact
- `VERSION` 2025-08

### Export Interactions
- `EXPORT` Address in CSV = Complete JSON in single column, requires post-processing
- `EXPORT` MultilineText in CSV = Line breaks may require specific reader settings
- `EXPORT` TemplatedString = Exports generated value, not template
- `EXPORT` RichText = Never exported, content only in notebook definition
- `EXPORT` TextField > 254 chars in Shapefile = Data truncation
- `VERSION` 2025-08

---

## Migration Warnings Index (2025-08) {comprehensive}

### Safe Migrations (No Data Loss)
- `SAFE` TextField ‚Üí MultilineText when all existing content <10,000 chars
- `SAFE` TextField ‚Üí FAIMSTextField variant (enhanced help features)
- `SAFE` Adding optional fields to existing forms
- `SAFE` Increasing MultilineText row count (display only)
- `SAFE` Adding helperText to any field
- `SAFE` Removing pattern validation (makes validation less strict)
- `SAFE` Adding TemplatedString as new hridField (doesn't affect existing records)
- `VERSION` 2025-08

### Breaking Changes (Data Loss or Corruption Risk)
- `BREAKS` String type ‚Üí Number type = Existing string data becomes invalid
- `BREAKS` Adding required validation to populated field = Blocks editing existing records
- `BREAKS` Changing field name/id = Orphans all existing data
- `BREAKS` TextField ‚Üí Email with strict validation = May invalidate existing entries
- `BREAKS` Removing hridField designation = Records become UUID-only, unidentifiable
- `BREAKS` QRCodeFormField ‚Üí Any other type = No migration path exists
- `BREAKS` Any field ‚Üí QRCodeFormField = Manual data cannot be migrated
- `BREAKS` Adding pattern validation to populated field = May invalidate existing data
- `BREAKS` MultilineText ‚Üí TextField with data >50 chars = Display issues, possible truncation
- `BREAKS` Changing TemplatedString template = New format only for new records
- `BREAKS` Component namespace change = Complete field incompatibility
- `VERSION` 2025-08

### Conditional Migrations (Context Dependent)
- `CONDITIONAL` MultilineText ‚Üí TextField = Safe only if ALL content <50 characters
- `CONDITIONAL` Changing validation patterns = Safe if all existing data passes new pattern
- `CONDITIONAL` Address field restructuring = Requires JSON transformation scripts
- `CONDITIONAL` Email validation tightening = Test against all institutional formats first
- `CONDITIONAL` Adding character limits = Safe if no existing data exceeds limit
- `CONDITIONAL` TextField type="text" ‚Üí type="email" = Safe if all entries are valid emails
- `CONDITIONAL` Removing fields from TemplatedString = Safe but changes future HRIDs
- `CONDITIONAL` Adding fields to TemplatedString = Only affects new records
- `VERSION` 2025-08

---

## See Also {comprehensive}

- **Number Fields**: For numeric-only input with validation
- **DateTime Fields**: For structured temporal data capture
- **Select/Choice Fields**: For controlled vocabularies and predefined options
- **Reference Documents**:
  - [Validation Timing Reference](validation-timing-reference.md) - Universal validation behavior
  - [Security Considerations Reference](security-considerations-reference.md) - XSS prevention for TemplatedString
  - [Data Export Reference](data-export-reference.md) - CSV/JSON export handling
  - [Accessibility Reference](accessibility-reference.md) - Touch targets and WCAG compliance

---

## Error Message Quick Reference (2025-08) {important}

### Critical Errors (Form Breaking)

| Error Message | Field Type(s) | Root Cause | Quick Fix | Prevention |
|---------------|---------------|------------|-----------|------------|
| "Maximum call stack size exceeded" | TemplatedString | Circular template reference | Remove circular refs between templates | Never reference other TemplatedStrings |
| "Form cannot be submitted" | QRCodeFormField | Required validation on web platform | Remove ["yup.required"] from schema | Never mark QRCodeFormField as required |
| "Cannot read property 'length' of null" | TextField, MultipleTextField, Email | initialValue is null instead of string | Change to initialValue: "" | Always use "" for string-type fields |
| "Cannot read property 'address' of undefined" | Address | initialValue is "" or undefined | Change to initialValue: null | Always use null for Address fields |
| "yup.required is not a function" | All fields | Validation schema wrong order | Put ["yup.string"] before ["yup.required"] | Type declaration must come first |
| "Component not found" | All fields | Wrong component name | Check exact component name | Reference documentation for names |
| "Memory quota exceeded" | RichText | >10 fields or >1000 words total | Reduce RichText count/content | Monitor total RichText usage |
| "IndexedDB quota exceeded" | TakePhoto, FileUploader | Storage full | Clear app cache or delete records | Monitor device storage |
| "UI Spec had an undefined field" | All fields | Field ID doesn't exist | Create field or remove from section | Validate all field references |

### Validation Errors (User Facing)

| Error Message | Field Type(s) | Root Cause | Quick Fix | Prevention |
|---------------|---------------|------------|-----------|------------|
| "Field is required" | All input fields | Empty required field | Fill in the field | Clear labeling of required fields |
| "Invalid email" or "Invalid email format" | Email | Missing @ or malformed | Check for spaces and format | Provide format example in helper |
| "Must be 3 capital letters" | TextField | Pattern mismatch | Match specified regex | Show pattern example in placeholder |
| "Minimum N characters" | TextField, MultipleTextField | Content too brief | Add more content | Set realistic minimums |
| "Maximum N characters" | TextField, MultipleTextField | Content too long | Reduce content | Display character counter |
| "At least one photo required" | TakePhoto | Empty photo array | Capture at least one photo | Clear requirement in label |
| "Invalid format" | TextField, Email | Regex pattern failure | Match expected pattern | Document pattern in helperText |

### Component Errors (Configuration)

| Error Message | Field Type(s) | Root Cause | Quick Fix | Prevention |
|---------------|---------------|------------|-----------|------------|
| "Unknown component MultilineTextField" | MultilineText | Wrong component name | Use "MultipleTextField" | Check documentation |
| "Component EmailField not found" | Email | No EmailField component exists | Use TextField with type="email" | Email is TextField variant |
| "Component FAIMSTextField not found" | TextField | Wrong namespace | Use namespace: "faims-custom" | Match namespace to component |
| "LocationPermissionIssue" (wrong error) | TakePhoto | Shows location instead of camera error | Known bug - ignore message | Grant camera permission |

### Display Errors (Visual Issues)

| Error Message | Field Type(s) | Root Cause | Quick Fix | Prevention |
|---------------|---------------|------------|-----------|------------|
| "[object Object]" | TemplatedString | Complex field in template | Use conditionals {{#field}} only | Document field return types |
| "[object Blob]" | TemplatedString | File/photo field in template | Use for existence check only | Mark binary fields clearly |
| "Unknown User" | TemplatedString | System variable is null | Check _CREATOR_NAME exists | Handle null in template |
| "Unknown Time" | TemplatedString | System variable is null | Check _CREATED_TIME exists | Provide fallback values |
| "Error" (literal text) | RichText | Invalid markdown syntax | Fix markdown in Designer | Validate markdown syntax |

### Silent Failures (No Error Message Shown)

| Symptom (No Error) | Field Type(s) | Root Cause | Quick Fix | Prevention |
|--------------------|---------------|------------|-----------|------------|
| Template shows {{field}} literally | TemplatedString | Field doesn't exist | Check field name spelling | Validate all references |
| Red field, no text | RadioGroup, Select, others (14 types) | Missing error display component | Known bug - check console | Manual validation check |
| Scanner never completes | QRCodeFormField | Multiple barcodes or unstable | Isolate single barcode | Train proper scanning |
| Validation doesn't trigger | All fields | Field not "touched" | Focus then blur field | Explain validation timing |
| Address shows "Empty" with data | Address | Display issue with stored data | Check data structure | Test with sample data |
| Tables disappear | RichText | DOMPurify strips tables | Use lists or images instead | Document runtime limits |
| Images don't load | RichText | External URLs blocked | Use Base64 embedding | Only embed images <100KB |
| Form won't save (no error) | Any field | Hidden required field | Check all required fields | Avoid required on conditional |

---

## Metadata {comprehensive}

**Documentation Version**: 2025-08-29 v0.2 
**Components**: TextField, MultipleTextField, TemplatedString, Email, Address, QRCodeFormField, RichText  
**Platform Version**: Fieldmark 2025  
**Last Updated**: August 2025  
**Status**: Complete consolidated, deduplicated, structured, and tagged documentation for all text input fields

### Component Status Summary
- **Production Ready**: TextField, MultipleTextField, TemplatedString
- **Stable Configuration**: Email (TextField variant)
- **Beta Feature**: Address (JSON storage complexity)
- **Mobile-Only**: QRCodeFormField (platform limitations)
- **Display-Only**: RichText (no data capture, memory issues)

### Quality Verification
- ‚úî All 7 fields documented completely with keywords
- ‚úî Every section has appropriate depth tags
- ‚úî Security warnings prominent at top
- ‚úî Platform limitations clearly marked
- ‚úî Beta status noted for Address field
- ‚úî Structure matches template exactly
- ‚úî Common characteristics properly tagged
- ‚úî All field names tagged {essential}
- ‚úî Keywords added for each field (3-5 terms)
- ‚úî No content lost during restructuring
- ‚úî Clear navigation with depth indicators
- ‚úî Testing guidelines tagged {comprehensive}
- ‚úî Designer disambiguation complete

### Revision History
- **v0.1**: Initial consolidated documentation with Designer disambiguation
- **v0.2**: Added migration patterns and training requirements (2025-08)
- **v0.3**: Added concatenation boundaries and navigation (2025-01)

---

## Related Documentation
<!-- concat:references -->

### Within Field Categories
- **Next Category**: [Selection Fields](./select-choice-fields-v05.md) | [#selection-fields](#selection-fields)
- **Similar Fields**: [Display Fields - RichText](./display-field-v05.md#richtext) | [#display-fields](#display-fields)

### Cross-Field Patterns
- **Validation**: [Validation Patterns](../detail-crossfield-docs/validation.md#text-validation) | [#validation-patterns](#validation-patterns)
- **Conditional Logic**: [Conditional Display](../detail-crossfield-docs/conditional-logic.md#text-conditions) | [#conditional-logic](#conditional-logic)
- **Best Practices**: [Field Selection](../detail-crossfield-docs/field-selection-best-practices.md#text-fields) | [#field-selection](#field-selection)

### Technical References
- **Designer Limitations**: [Text Field Constraints](../reference-docs/designer-limitations-reference.md#text-fields) | [#designer-limitations](#designer-limitations)
- **Security**: [XSS Prevention](../reference-docs/security-considerations-reference.md#text-input) | [#security-considerations](#security-considerations)
- **Performance**: [Text Field Limits](../reference-docs/performance-thresholds-reference.md#text-fields) | [#performance-thresholds](#performance-thresholds)

<!-- /concat:references -->
<!-- concat:boundary:end section="text-input-fields" -->


<!-- concat:document:select-choice-fields-v05 -->
<!-- concat:boundary:start section="selection-fields" -->
<!-- concat:metadata
document_id: select-choice-fields-v05
category: selection_choice
field_count: 5
designer_capable: ["Checkbox", "Select", "MultiSelect", "RadioGroup", "AdvancedSelect"]
json_only: ["dynamic_options", "dependent_selects", "option_generation"]
last_updated: 2025-01-05
-->

# Selection and Choice Fields

## Document Navigation
<!-- concat:nav-mode:individual -->
[‚Üê Text Fields](./text-fields-v05.md) | **Selection & Choice Fields** | [Date & Time Fields ‚Üí](./datetime-fields-v05.md)
<!-- concat:nav-mode:concatenated -->
<!-- When viewing in reference.md: [‚Üë Top](#fieldmark-v3-field-type-documentation-index) | [Date & Time Fields ‚Üì](#datetime-fields) -->

## Overview {essential}

### DESIGNER QUICK GUIDE

Selection and choice fields provide controlled vocabulary input through various interface patterns, returning structured data for standardized recording workflows. Five field types serve different selection patterns: **Checkbox** for boolean states, **Select** for single dropdown selection, **MultiSelect** for multiple choices, **RadioGroup** for visible single selection (deprecated), and **AdvancedSelect** for hierarchical vocabularies (beta).

All fields share static vocabulary requirements‚Äîoptions must be predefined at design time with no dynamic loading capability due to offline operation requirements. Critical limitations include no error message display (except Checkbox), limited accessibility support, and various platform-specific interaction issues.

### CRITICAL NAMING DISAMBIGUATION

**Designer Interface Labels vs JSON Component Names:**
- **"Checkbox"** in Designer ‚Üí `faims-custom::Checkbox`
- **"Select Multiple"** in Designer ‚Üí `faims-custom::MultiSelect`  
- **"Select one option"** in Designer ‚Üí `faims-custom::RadioGroup
- **"Select Field"** in Designer ‚Üí `faims-custom::Select`
- **"Select Field (Hierarchical)"** in Designer ‚Üí `faims-custom::AdvancedSelect` üî¥ BETA

### Field Capabilities Summary

1. **Checkbox** ‚úÖ PRODUCTION - Boolean states, returns `faims-core::Bool`
2. **Select** ‚úÖ PRODUCTION - Single dropdown selection, returns `faims-core::String`  
3. **MultiSelect** ‚úÖ PRODUCTION - Multiple selection, returns `faims-core::Array`
4. **RadioGroup - Single visible selection, returns `faims-core::String`
5. **AdvancedSelect üîü NEW - Hierarchical trees, returns `faims-core::String`

## Component Name Mapping {essential}

| Designer UI Label | JSON component-name | Namespace | Code File | Description |
|------------------|-------------------|-----------|-----------|-------------|
| Checkbox | Checkbox | formik-material-ui | Checkbox.tsx | Boolean checkbox |
| Select Field | Select | formik-material-ui | Select.tsx | Single dropdown |
| Select Multiple | MultiSelect | formik-material-ui | MultiSelect.tsx | Multiple dropdown |
| Select one option | RadioGroup | formik-material-ui | RadioGroup.tsx | Radio buttons |
| Select Field (Hierarchical) | AdvancedSelect | faims-custom | AdvancedSelect.tsx | Tree selection (beta) |

### Critical Naming Issues {important}
- **MultiSelect label**: Designer shows "Select Multiple" but component is MultiSelect
- **RadioGroup deprecation**: Still available in Designer but deprecated - use Select instead
- **AdvancedSelect stability**: Beta feature with JSON builder but incomplete Designer support
- **Namespace consistency**: Most use formik-material-ui except AdvancedSelect (faims-custom)

### Component Status

| Component | Status | Error Display | Mobile Support | Primary Use Case |
|-----------|--------|---------------|----------------|------------------|
| Checkbox | ‚úÖ Production | ‚úÖ Full messages | ‚ö†Ô∏è Label not clickable | Binary states, consent |
| Select | ‚úÖ Production | ‚ùå None | ‚úÖ Good | Single choice dropdown |
| MultiSelect | ‚úÖ Production | ‚ùå None | ‚ö†Ô∏è Performance limits | Multiple selections |
| RadioGroup | ‚úÖ Production | ‚ùå Color only | ‚ùå Accessibility issues | Single visible options |
| AdvancedSelect | üîü New | ‚ùå Limited | ‚ö†Ô∏è In progress | Hierarchical vocabularies |

## Designer Usage Guide {essential}

### What to Select in Designer

**For Binary Decisions (True/False)**:
- Use **"Checkbox"** when false state is meaningful
- Returns boolean values for programmatic logic
- Best for consent, presence/absence, feature flags

**For Single Selection from 2-7 Options**:
- Use **"Select Field"** for reliable implementation
- Avoid **"Select one option"** (RadioGroup) - deprecated due to critical bugs

**For Single Selection from 8+ Options**:
- Use **"Select Field"** - space-efficient dropdown
- Designer enforces value = label for human-readable exports

**For Multiple Selections**:
- Use **"Select Multiple"** (MultiSelect) for arrays of values
- Choose expanded checklist for ‚â§15 options or dropdown for more

**For Hierarchical Classifications**:
- **Avoid "Select Field (Hierarchical)"** (AdvancedSelect) - beta status
- Use cascading Select fields or Select with prefixed options instead

### When JSON Enhancement is Required

**Always Requires JSON Editing**:
- **AdvancedSelect**: Hierarchy structure (`optiontree`) not configurable in Designer
- Complex validation beyond basic `required` checkbox
- Initial values other than defaults
- Performance-critical properties (`fullWidth`, `variant`)

**Designer Sufficient For**:
- Basic Select fields with value = label
- Checkbox with standard validation
- MultiSelect with simple options
- Standard conditional logic (visibility only)

### Quick Use Case Examples

- **Site present/absent** ‚Üí Checkbox (boolean output)
- **Site type from 10 options** ‚Üí Select Field (dropdown)
- **Multiple damage types** ‚Üí Select Multiple (array output)
- **Condition: Good/Fair/Poor** ‚Üí Select Field (not RadioGroup)
- **Species taxonomy** ‚Üí Multiple Select Fields (not AdvancedSelect)

## Field Selection Guide {essential}

### Decision Tree

```
What type of selection do you need?
‚îÇ
‚îú‚îÄ Boolean/binary state?
‚îÇ  ‚îú‚îÄ YES ‚Üí Checkbox
‚îÇ  ‚îÇ  ‚îú‚îÄ Returns: faims-core::Bool  
‚îÇ  ‚îÇ  ‚îú‚îÄ Best for: Consent, presence/absence
‚îÇ  ‚îÇ  ‚îî‚îÄ ‚ö†Ô∏è Label not clickable (bug)
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue
‚îÇ
‚îú‚îÄ Single selection needed?
‚îÇ  ‚îú‚îÄ YES ‚Üí How many options?
‚îÇ  ‚îÇ  ‚îú‚îÄ 2-7 options ‚Üí Select Field
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ Returns: faims-core::String
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ Space efficient, reliable
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ ‚ùå No error display
‚îÇ  ‚îÇ  ‚îú‚îÄ 8+ options ‚Üí Select Field  
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ Dropdown handles many options
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ Performance acceptable to ~50 options
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ Designer enforces readable exports
‚îÇ  ‚îÇ  ‚îî‚îÄ Hierarchical? ‚Üí Multiple Select Fields
‚îÇ  ‚îÇ     ‚îú‚îÄ NOT AdvancedSelect (beta/broken)
‚îÇ  ‚îÇ     ‚îî‚îÄ Use cascading or prefixed options
‚îÇ  ‚îî‚îÄ NO ‚Üí Multiple selection needed
‚îÇ
‚îî‚îÄ Multiple selections ‚Üí MultiSelect
   ‚îú‚îÄ Returns: faims-core::Array
   ‚îú‚îÄ ‚â§15 options: Expanded checklist mode
   ‚îú‚îÄ >15 options: Dropdown mode  
   ‚îî‚îÄ ‚ö†Ô∏è No error display, CSV comma issues
```

### Decision Matrix

| Need | Field Type | Returns | Pros | Critical Issues |
|------|------------|---------|------|----------------|
| True/False | Checkbox | Boolean | Only boolean type, error display | Label not clickable |
| 1 from few | Select | String | Reliable, space efficient | No error display |
| 1 from many | Select | String | Handles 50+ options well | No error display |
| Many from list | MultiSelect | Array | Group validation, exclusive options | CSV export issues |
| Hierarchy | Multiple Selects | String each | Mobile compatible, reliable | More complex setup |

### Selection Strategy

1. **Default to Select** for single selection (most reliable)
2. **Use Checkbox** only for true boolean states  
3. **Deploy MultiSelect** for multiple selection from same vocabulary
4. **Avoid RadioGroup** (deprecated) and AdvancedSelect (beta)
5. **Prioritize Checkbox** for critical workflows needing error display

**Platform Considerations**:
- Mobile: Train users to tap checkbox icon (not label)
- Select: Excellent mobile dropdown experience
- MultiSelect: Limit to ‚â§20 options for performance
- RadioGroup: Accessibility violations, avoid entirely
- AdvancedSelect: Mobile broken, desktop only

**Accessibility Requirements**:
- Checkbox: Only field with error display, but label not clickable
- Select/MultiSelect: No error display, use clear helper text
- RadioGroup: Multiple WCAG violations, use Select instead
- AdvancedSelect: Not accessible, use cascading Selects instead

## ‚ö†Ô∏è Critical Security Risks {essential}

### Input Sanitization Issues

**HTML Content in Labels** [affects: All fields]:
- All field labels process HTML through DOMPurify sanitization
- **Risk**: Malformed HTML in option labels can break form rendering
- **Mitigation**: Validate all option text during configuration
- **Markdown parsing** in RadioGroup creates additional XSS vectors through markdown-it processing

**Option Value Injection** [affects: All fields]:
- No validation that selected values match defined options
- **Risk**: Malicious clients can submit arbitrary values
- **Impact**: Database pollution, conditional logic bypass
- **Mitigation**: Server-side validation required for all choice field data

### Data Integrity Vulnerabilities

**Conditional Logic Bypass** [affects: All fields]:
- Client can disable conditional field logic and submit hidden data  
- **Risk**: Required dependent fields bypassed
- **Example**: "Other" text field required when "Other" selected, but submission possible without text
- **Mitigation**: Server must validate all conditional requirements

**Validation Schema Bypass** [affects: All fields except Checkbox]:
- Error messages never displayed to users in Select, MultiSelect, RadioGroup, AdvancedSelect
- **Risk**: Users unaware of validation failures, submit invalid data
- **Impact**: Silent data corruption, workflow failures
- **Mitigation**: Implement server-side validation, add explicit instructions in helper text

### Export Data Tampering

**CSV Injection via Option Values** [affects: MultiSelect primarily]:
- Option values containing commas, quotes, or formulas can break CSV parsing
- **Risk**: Excel formula injection, data corruption during export
- **Example**: Option value `=SUM(1+1)` could execute in spreadsheets
- **Mitigation**: Sanitize all option values, avoid special characters

**Path Traversal in AdvancedSelect** [affects: AdvancedSelect]:
- Node names with " > " delimiters can break path parsing
- **Risk**: Hierarchy corruption, data integrity loss
- **Mitigation**: Validate node names exclude path delimiters

### Authentication and Session Issues

**State Persistence Vulnerabilities** [affects: All fields with meta.persistent]:
- Persistent field values carry across records without user awareness
- **Risk**: Sensitive selections propagated inappropriately  
- **Example**: "Contains human remains" checkbox persisting to non-burial contexts
- **Mitigation**: Audit persistent field configurations, clear documentation

**Cross-Form Data Leakage** [affects: All fields]:
- Form navigation can preserve field values between different record types
- **Risk**: Confidential classifications appearing in wrong contexts
- **Mitigation**: Implement proper form state cleanup

## What This Field Cannot Do {important}

### Selection Processing Limitations {important}

**Dynamic Vocabularies** [affects: All fields]:
- **Cannot load options from APIs** - All options must be predefined in JSON configuration. This limitation exists because fields are statically defined at form load time and must function offline. No integration with external taxonomies, databases, or web services is possible.

**Real-time Option Filtering** [affects: All fields]:  
- **Cannot modify option lists based on other fields** - Option sets are static. Cannot implement cascading dropdowns where second field options depend on first field selection. Workaround requires separate forms or conditional field display.

**Computed or Generated Options** [affects: All fields]:
- **Cannot create options from user input** - Options cannot be generated from calculations, string manipulation, or other field values. All possibilities must be enumerated at design time.

**Cross-Field Option Validation** [affects: All fields]:
- **Cannot validate option combinations across fields** - No support for rules like "If Material=Metal, then Technique cannot be Fired". Each field validates independently without awareness of other selections.

### Validation Limitations {important}

**User Feedback Display** [affects: Select, MultiSelect, RadioGroup, AdvancedSelect]:
- **No error message display** - Validation runs but error text never appears in UI. Users receive no feedback about what's wrong or how to fix validation failures. Form submission simply fails silently.

**Complex Validation Logic** [affects: All fields]:
- **No conditional validation** - Cannot make fields conditionally required based on other selections. Cannot implement logic like "Material field required only if Type=Artifact". Limited to static required/optional states.

**Empty State Detection** [affects: RadioGroup, AdvancedSelect]:
- **Cannot check if field is unselected** - No `isEmpty` operator for conditional logic. Cannot distinguish between "never touched" and "explicitly deselected" states. Must check for specific values only.

**Cross-Field Dependencies** [affects: All fields]:
- **No relational validation** - Cannot enforce relationships between field values. Cannot validate that selected combinations make logical sense or meet domain-specific rules.

### Display Limitations {important}

**Search and Filtering** [affects: All fields]:
- **No search within options** - Users must scroll through entire option lists. No type-ahead, filtering, or search capability even for vocabularies with hundreds of terms.

**Dynamic Presentation** [affects: All fields]:
- **No conditional option display** - Cannot show/hide specific options based on other field values. All defined options always appear regardless of context appropriateness.

**Responsive Layout Control** [affects: RadioGroup, AdvancedSelect]:
- **Fixed layout patterns** - RadioGroup only vertical, AdvancedSelect fixed width causes mobile horizontal scrolling. Cannot adapt presentation to screen size or content needs.

**Progressive Disclosure** [affects: AdvancedSelect]:
- **No lazy loading of hierarchies** - Entire tree structure rendered immediately. Cannot load branches on demand, causing performance issues with large taxonomies.

### Interaction Limitations {important}

**Multi-Selection Patterns** [affects: RadioGroup, Select, Checkbox, AdvancedSelect]:
- **Single selection fields cannot become multi-select** - No way to allow multiple selections from RadioGroup or Select options. Must use separate MultiSelect field with data structure changes.

**Deselection Control** [affects: Select, AdvancedSelect]:
- **Cannot clear selections** - Select has no clear button, AdvancedSelect cannot deselect once chosen. Must include empty options or reload forms to reset. RadioGroup deselection only works via mouse, not keyboard.

**Keyboard Navigation** [affects: RadioGroup, AdvancedSelect]:
- **Limited keyboard support** - RadioGroup cannot deselect via keyboard after selection. AdvancedSelect has poor keyboard navigation through hierarchies. Accessibility barriers for non-mouse users.

**Gesture Support** [affects: All fields]:
- **No touch gestures** - No swipe, pinch, long-press, or other mobile-specific interactions. All fields rely on basic tap/click patterns only.

## Common Use Cases {important}

### Archaeological and Heritage Recording

**Site Classification and Typology**:
- **Site types** ‚Üí Select with 10-50 controlled vocabulary options (e.g., "Aboriginal scarred tree"). Include empty option "-- Not classified --". Set required validation only if mandatory classification workflow exists.
- **Artifact materials** ‚Üí MultiSelect with expanded checklist for composite objects (ceramic with metal inlay, bone with shell decoration). Use exclusive options for "Unknown" or "Not applicable" states.
- **Condition assessment** ‚Üí Select with 4-6 standardized levels (Excellent/Good/Fair/Poor/Destroyed). Always include "Not assessed" option for incomplete records.
- **Feature presence/absence** ‚Üí Checkbox for binary archaeological indicators (charcoal present, bioturbation observed). Boolean return type enables programmatic logic for analysis and reporting.

**Heritage Compliance Workflows**:
- **Permit requirements** ‚Üí MultiSelect for multiple concurrent permits (heritage/environmental/landowner). Use exclusive "None required" option that clears all other selections.
- **Stakeholder notifications** ‚Üí MultiSelect for required consultations (Traditional Owners, Council, State Heritage). Include annotation field for contact details and dates.
- **Assessment confidence** ‚Üí Select with epistemological categories (Certain/Probable/Possible/Speculative). Pair with uncertainty metadata for qualification.

### Scientific Data Collection

**Taxonomic and Species Recording**:
- **Species identification** ‚Üí Select for single species per observation record. Use standardized taxonomic names as both value and label for immediate data interpretability. Include "Unknown" and "Multiple species" options.
- **Multiple species present** ‚Üí MultiSelect for ecological transects or mixed assemblages. Limit to ‚â§20 most common species for performance, use "Other" with conditional TextField for rare species.
- **Taxonomic hierarchy** ‚Üí Multiple cascading Select fields rather than AdvancedSelect (Kingdom ‚Üí Phylum ‚Üí Class ‚Üí Order). Better mobile support and error handling than hierarchical field.

**Environmental Monitoring**:
- **Sampling methods used** ‚Üí MultiSelect with exclusive options for quality control. "GPS coordinates taken", "Photographs captured", "Specimens collected" as discrete trackable actions.
- **Weather conditions** ‚Üí MultiSelect for multiple concurrent conditions (rain/wind/cloud cover). Include "Excellent visibility" as exclusive option when conditions are optimal.
- **Equipment validation** ‚Üí Checkbox series for procedural confirmation (instruments calibrated, GPS accuracy verified, protocols followed). Boolean logic supports quality assurance reporting.

### Administrative Workflows

**Project and Team Management**:
- **Project phases** ‚Üí Select with controlled workflow states (Planning/Fieldwork/Analysis/Reporting/Complete). Include "On hold" and "Cancelled" for project lifecycle management.
- **Team member assignments** ‚Üí MultiSelect for multiple specialists involved. Use "Team leader" option as exclusive when single responsibility model applies.
- **Institutional affiliations** ‚Üí Select with organization codes. Use Designer value=label pattern to maintain human-readable exports without lookup tables.

**Quality Assurance and Review**:
- **Data quality flags** ‚Üí Checkbox series for quality indicators (peer reviewed, supervisor approved, external validation completed). Boolean states enable automated workflow triggers.
- **Review status** ‚Üí Select with review workflow states (Draft/Under review/Approved/Rejected/Requires revision). Include reviewer assignment through conditional TextField.

### Field Research Scenarios

**Site Access and Safety**:
- **Access permissions obtained** ‚Üí MultiSelect for multiple permit types with exclusive "Access denied" option. Include conditional TextField for denial reasons and alternative approaches.
- **Safety protocols followed** ‚Üí Checkbox series for procedural compliance (risk assessment completed, emergency contacts notified, first aid available). Boolean logic supports safety audit trails.
- **Site accessibility** ‚Üí Select with accessibility categories for planning return visits. Include "Requires special equipment" or "Seasonal access only" options.

**Recording Methodology Documentation**:
- **Recording methods employed** ‚Üí MultiSelect for multiple concurrent techniques (photography/drawing/GPS/photogrammetry/total station). Enable comprehensive methodology documentation.
- **Data collection completeness** ‚Üí Select with completion levels (Complete/Partial/Preliminary/Incomplete). Include conditional annotation for explaining partial records.

### Data Entry Patterns

**Conditional Field Triggers**:
- **Recording detail level** ‚Üí Select with workflow options (Rapid assessment/Standard recording/Detailed analysis). Each option triggers different conditional field groups through operators.
- **"Other" specification patterns** ‚Üí Select with "Other" option triggering conditional TextField. Standard pattern for extending controlled vocabularies without losing structure.
- **Workflow branching** ‚Üí Select for process decisions (Continue recording/Skip section/Mark for later/Complete record). Each selection changes available fields and required validations.

**Data Export and Integration**:
- **Export filtering** ‚Üí Checkbox series for data subset selection (Include photographs/Export GPS coordinates/Generate report/Share with team). Boolean states enable flexible export configuration.
- **Data sharing permissions** ‚Üí Select with privacy levels (Public/Restricted/Confidential/No sharing). Include conditional text for access restriction details.

## Designer Component Mapping {essential}

### Designer UI vs JSON Component Names

The Designer interface uses human-readable labels that don't match the technical JSON component names, creating confusion during configuration and troubleshooting. This mapping is critical for JSON editing and error diagnosis:

| Designer Display | JSON Component | Namespace | Notes |
|------------------|----------------|-----------|-------|
| "Checkbox" | `Checkbox` | `faims-custom` | Matches exactly |
| "Select Multiple" | `MultiSelect` | `faims-custom` | Different names |
| "Select one option" | `RadioGroup |
| "Select Field" | `Select` | `faims-custom` | Different names |
| "Select Field (Hierarchical)" | `AdvancedSelect` | `faims-custom` | üî¥ BETA status |

### Designer Limitations Requiring JSON

**Complete JSON Requirement** [affects: AdvancedSelect]:
- **Hierarchy definition**: While Designer provides a JSON template builder for `optiontree` structure, complex hierarchies may require manual JSON editing for complete tree structure including all nodes and relationships.

**Advanced Properties** [affects: All fields]:
- **Validation schemas**: Beyond basic `required` checkbox, all validation rules require JSON editing (`yup.oneOf`, `yup.min`, custom messages)
- **Initial values**: Designer enforces defaults (Checkbox: false, others: empty), though "copy value to new records" provides persistence after first entry
- **Performance properties**: `fullWidth`, `variant`, `disabled` states not exposed in Designer
- **MUI component props**: `FormControlLabelProps`, `SelectProps`, etc. only accessible via JSON

**Complex Option Configuration** [affects: RadioGroup, Select]:
- **Value vs Label separation**: Designer enforces value=label. JSON editing required if you need different internal values from display labels (e.g., store "arch_site" while displaying "Archaeological Site")
- **Option validation**: `yup.oneOf` validation against defined options requires JSON configuration

### Technical Implementation Note

**Designer-JSON Interaction Warning**:
When switching between Designer and JSON editing, **Designer changes can overwrite manual JSON configurations**. This affects:
- Custom validation schemas beyond required checkbox
- Modified initial values 
- Advanced component properties
- Complex option configurations

**Recommended Workflow**:
1. Configure basic properties in Designer first
2. Export to JSON for advanced configuration  
3. Make all further changes in JSON only
4. Do not return to Designer after JSON customization

## Designer Capabilities vs JSON Enhancement {essential}

### What Designer CAN Configure

For complete meta properties documentation, see [Meta Properties Reference](meta-properties-reference.md).

**Checkbox**:
- ‚úÖ Label, helper text, and advanced helper text
- ‚úÖ Required validation (checkbox adds `yup.required`)
- ‚úÖ Field name and ID assignment
- ‚úÖ Annotation and uncertainty toggles (see Meta Properties Reference)
- ‚úÖ Basic conditional logic for field visibility

**Select**:
- ‚úÖ Option list management (add, remove, reorder options)
- ‚úÖ Label, helper text configuration
- ‚úÖ Required field checkbox
- ‚úÖ Enforces value = label for human-readable exports
- ‚úÖ Basic conditional logic setup

**MultiSelect**:
- ‚úÖ Option list with drag-drop reordering
- ‚úÖ Expanded checklist mode toggle
- ‚úÖ Per-option exclusive configuration via checkbox (exclusive options CAN be set in Designer)
- ‚úÖ Label and helper text
- ‚úÖ Markdown syntax support in option labels

**RadioGroup (Deprecated)**:
- ‚úÖ Manual option entry with drag-drop
- ‚úÖ Basic field properties
- ‚úÖ Required validation checkbox
- ‚ùå NO preview capability (must deploy to test)

**AdvancedSelect (Beta)**:
- ‚úÖ Basic field properties (label, helperText, valuetype)
- ‚ùå **Hierarchy structure NOT configurable** - major limitation

### What Requires JSON Editing

**Advanced Validation** [affects: All fields]:
- Complex validation chains beyond basic required
- Custom error messages (though they won't display)
- `yup.oneOf` validation against specific values
- Array validation for MultiSelect (`yup.min`, `yup.max`)
- Boolean validation for Checkbox (`yup.oneOf([true])` for must-be-checked)

**Initial Value Control** [affects: All fields]:
- **Checkbox**: Designer forces `initialValue: false`, JSON can set `true` for pre-checked
- **Select/RadioGroup**: Designer sets empty string, JSON can set specific option
- **MultiSelect**: Designer sets empty array, JSON can pre-populate selections
- **AdvancedSelect**: JSON required for any non-empty initial state

**Performance and Display Properties** [affects: All fields]:
- `fullWidth` control for field width behavior
- `variant` styling (outlined, filled, standard)
- `disabled` state for entire field
- Component-specific props (`FormControlLabelProps`, `SelectProps`)

**Advanced Option Configuration**:
- **Different values vs labels**: Designer enforces identical strings, JSON allows separation
- **MultiSelect exclusive options**: Array of mutually exclusive values
- **Complex hierarchies**: AdvancedSelect `optiontree` structure completely JSON-only

### Designer vs JSON Workflow

**Designer-First Approach** (Recommended):
1. Configure all basic properties in Designer interface
2. Set up option lists and basic conditional logic
3. Test functionality with Designer defaults
4. Export to JSON for advanced configuration
5. **Never return to Designer** after JSON customization

**JSON-Only Approach** (Advanced):
1. Create field structure completely in JSON
2. Define complex validation schemas
3. Configure advanced component properties
4. Test thoroughly as no Designer preview available

**Hybrid Approach Risks**:
- Designer changes overwrite JSON customizations
- Validation schemas reset to basic `required` only  
- Advanced properties lost when switching to Designer
- Complex option configurations simplified

### Designer Limitations {important}

See [Designer Limitations Reference](designer-limitations-reference.md) for testing, validation, and configuration constraints that apply to all fields.

**Selection Field-Specific Limitations**:
- **Markdown processing performance**: All option labels processed through markdown parser at design-time, potentially causing lag with >20 options (hypothetical limit)
- **No option validation**: Designer doesn't validate that option values are unique or contain valid characters
- **No bulk option management**: Cannot import/export option lists or edit multiple options at once
- **Option value/label coupling**: Designer enforces option display text = stored value (cannot have "Archaeological Site" display with "arch_site" stored)

## Component Namespace Errors {important}

See [Component Namespace Reference](component-namespace-reference.md) for complete namespace documentation, error troubleshooting, and Designer name mapping.

### Selection Field-Specific Notes

**All selection fields use the same namespace**:
- Namespace: `faims-custom` for ALL selection fields (Checkbox, MultiSelect, RadioGroup, Select, AdvancedSelect)
- Never use `formik-material-ui` for selection fields

**Quick Reference for Selection Fields**:
| Component | Namespace | Case-Sensitive Name |
|-----------|-----------|-------------------|
| Checkbox | `faims-custom` | `Checkbox` (capital C) |
| MultiSelect | `faims-custom` | `MultiSelect` (capitals M, S) |
| RadioGroup | `faims-custom` | `RadioGroup` (capitals R, G) |
| Select | `faims-custom` | `Select` (capital S) |
| AdvancedSelect | `faims-custom` | `AdvancedSelect` (capitals A, S) |


## When to Use These Fields {essential}

### Field Selection Matrix

| Use Case | Recommended Field | Why |
|----------|------------------|-----|
| Yes/No questions | Checkbox | Clear boolean state |
| Single choice (<10 options) | Select | Compact dropdown |
| Single choice (>10 options) | Select | Searchable dropdown |
| Multiple choices | MultiSelect | Multi-select dropdown |
| Hierarchical categories | AdvancedSelect | Tree navigation |
| Visible options (2-5) | RadioGroup | All options visible |

### Decision Criteria
- **Number of options**: <10 ‚Üí Select, >10 ‚Üí Select with search, Hierarchical ‚Üí AdvancedSelect
- **Selection count**: Single ‚Üí Select, Multiple ‚Üí MultiSelect, Boolean ‚Üí Checkbox
- **Visibility**: All dropdowns hide options until opened (RadioGroup for visible options)
- **Data structure**: Flat ‚Üí Select/MultiSelect, Tree ‚Üí AdvancedSelect

## Common Characteristics {important}

### Shared Behaviors Across Selection Fields

**Static Vocabulary Requirement** [affects: All fields]:
All selection fields require predefined option lists configured at design time. No field can load options dynamically from APIs, databases, or user input due to offline operation requirements. This limitation is architectural - fields are statically defined at form load time and cannot modify their option sets during runtime.

**Consistent Data Flow Patterns** [affects: All fields]:
- All fields integrate with Formik for form state management
- Values immediately update on user interaction (no delayed commit)
- All fields support conditional logic as both triggers and targets
- Validation runs immediately on value change but display varies by field type

**Shared Metadata Support** [affects: All fields]:
- **Annotation fields**: All fields can include optional annotation metadata with configurable labels
- **Uncertainty indicators**: All fields support uncertainty metadata for data quality tracking
- **Persistent values**: All fields can carry values forward to new records when `meta.persistent: true`
- **Parent display**: All fields can show values in parent record summaries when `meta.displayParent: true`

### Configuration Rules {important}

#### Base Properties [affects: All fields] {important}

**Required Configuration Elements**:
```json
{
  "component-namespace": "faims-custom",  // Always this namespace
  "component-name": "Select",             // Exact case-sensitive name (Checkbox/MultiSelect/RadioGroup/Select/AdvancedSelect)
  "type-returned": "faims-core::String",  // Type varies: Boolean/String/Array
  "component-parameters": {
    "name": "field-name",                  // Must be unique in form
    "label": "Field Label"                 // User-visible label
  }
}
```

**Standard Optional Properties**:
- `helperText`: Guidance text displayed near field
- `required`: Boolean flag for validation (behavior varies by field)
- `id`: Field identifier (defaults to name if not specified)
- `disabled`: Boolean flag to disable entire field
- `meta`: Object containing annotation, uncertainty, persistence settings

**Designer vs JSON Property Exposure**:
- **Designer exposes**: Basic properties (name, label, required, helper text, meta toggles)
- **JSON only**: Advanced validation, initial values, performance properties, MUI component props
- **Hybrid risk**: Designer changes overwrite JSON customizations

#### Validation Rules [affects: All fields] {important}

**Universal Validation Schema Structure**:
```json
"validationSchema": [
  ["yup.string"],                    // Base type validation (yup.bool for Checkbox, yup.array for MultiSelect)
  ["yup.required", "Error message"], // Optional required validation
  // Additional validators vary by field type
]
```

#### Standard Validation Rules [affects: All fields] {important}

**Type Validation** (Always included):
- **Checkbox**: `["yup.bool"]` - Validates true/false/null values
- **Select/RadioGroup/AdvancedSelect**: `["yup.string"]` - Validates string values
- **MultiSelect**: `["yup.array"]` - Validates array structure

**Required Validation** (Optional but common):
- **Behavior varies significantly by field type**
- **Checkbox**: `["yup.required"]` allows `false` (unchecked) as valid
- **Select/RadioGroup**: `["yup.required"]` prevents empty string submission
- **MultiSelect**: `["yup.required"]` allows empty array `[]` as valid (use `yup.min` instead)
- **AdvancedSelect**: `["yup.required"]` prevents empty selection but shows no error message

#### Validation Behavior [affects: specific fields] {important}

**Error Message Display Capability**:
- **Checkbox**: ‚úÖ **Full error display** - Shows error text and red styling
- **Select**: ‚ùå **No error display** - Validation runs but messages never shown
- **MultiSelect**: ‚ùå **No error display** - Silent validation failures
- **RadioGroup**: ‚ö†Ô∏è **Color only** - Red styling but no error text
- **AdvancedSelect**: ‚ùå **No error display** - Silent validation failures

#### Validation Timing Behavior [affects: All fields] {important}

See [Validation Timing Reference](validation-timing-reference.md) for complete universal validation behavior.

**Selection Field-Specific Notes**:
- **Binary state changes**: Selection fields validate on discrete state changes rather than keystroke
- **No partial validation**: Selection is either valid or invalid, no intermediate states
- **Error display limitations**: Select and AdvancedSelect cannot display error messages even when validation fails

### Security Considerations {important}

See [Security Considerations Reference](security-considerations-reference.md) for comprehensive security guidelines, validation strategies, and attack mitigation.

**Selection Field-Specific Security Issues**:
- **Option validation gap**: No server-side validation that submitted values match defined options
- **CSV injection**: MultiSelect option values with formulas (=SUM) execute in Excel
- **Markdown XSS vectors**: RadioGroup markdown processing creates additional attack surface
- **AdvancedSelect path traversal**: Node names with " > " delimiter corrupt hierarchy
- **Conditional bypass**: Client can disable conditional logic to submit invalid data

### Performance Boundaries {important}

See [Performance Thresholds Reference](performance-thresholds-reference.md) for comprehensive performance limits, testing scenarios, and optimization triggers.

**Selection Field-Specific Performance Notes**:
- **Markdown processing**: RadioGroup/Select with >20 options causes significant lag when markdown enabled
- **DOM node multiplication**: Total nodes = fields √ó options √ó nodes-per-option (RadioGroup: ~8, Select: ~4, MultiSelect: ~6)
- **RadioGroup deprecation**: Use Select for >7 options due to severe performance issues
- **MultiSelect expanded mode**: Maximum 15 options for mobile, 25 for desktop
- **AdvancedSelect**: Beta component with poor performance above 50 nodes

**AdvancedSelect** [affects: AdvancedSelect] üî¥ BETA:
- **Total Node Limits**:
  - **Optimal**: ‚â§50 total nodes across entire hierarchy
  - **Acceptable**: 51-100 nodes with desktop-only deployment
  - **Degraded**: 101-500 nodes cause significant interaction lag
  - **Unusable**: >500 nodes likely to crash browsers
- **Depth Limits**:
  - **Optimal**: ‚â§3 hierarchy levels for usability
  - **Acceptable**: 4-5 levels with careful UX design
  - **Problematic**: >5 levels difficult to navigate on mobile
- **Breadth Limits**:
  - **Optimal**: ‚â§15 nodes per hierarchy level
  - **Acceptable**: 16-30 nodes per level with scroll management
  - **Unusable**: >30 nodes per level cause navigation confusion

**Performance Testing Requirements**:
- Test on lowest-specification target device
- Monitor memory usage with large option sets
- Verify touch target adequacy on mobile screens
- Check form load time with complete field configuration
- Validate CSV export performance with maximum data sets

### Platform Behaviors {important}

#### Cross-Platform Consistency {important}

**Rendering Engine Consistency** [affects: All fields]:
All choice fields use Material-UI components consistently across platforms rather than native controls. This design choice prioritizes consistent user experience over platform conventions:

- **Benefit**: Identical appearance and behavior across iOS, Android, and desktop
- **Trade-off**: Users may expect native iOS picker or Android dropdown patterns
- **Training requirement**: Users must learn Material-UI interaction patterns regardless of platform familiarity

**Touch Target Standards** [affects: All fields]:
- **Desktop**: Mouse interaction with hover states, precise clicking
- **Mobile**: Touch targets sized for finger interaction (minimum 44px iOS, 48px Android recommended)
- **Consistency**: All fields attempt to meet mobile touch standards on all platforms

#### iOS Behaviors [affects: specific fields] {comprehensive}

**Checkbox** [affects: Checkbox]:
- **Critical UX Issue**: Label text not tappable, must tap 24√ó24px checkbox icon directly
- **Touch target**: 48√ó48px checkbox area meets iOS accessibility guidelines  
- **Visual style**: Material-UI custom SVG, not iOS native toggle switch
- **No haptic feedback**: Missing tactile confirmation common in iOS apps
- **Keyboard**: Not applicable (checkbox not keyboard-accessible in mobile Safari)

**Select** [affects: Select]:
- **Dropdown behavior**: Uses Material-UI portal dropdown, not iOS native picker wheel
- **Touch interaction**: Tap to open, tap option to select, behaves like desktop
- **Scrolling**: Standard touch scroll within dropdown list
- **Selection feedback**: Immediate display of selected value
- **No gesture support**: Cannot swipe or use other iOS-standard gestures

**MultiSelect** [affects: MultiSelect]:
- **Expanded checklist**: Each row fully tappable (better than Checkbox field)
- **Dropdown mode**: Same portal-based dropdown as Select
- **Performance**: Degrades with >20 options due to DOM node count
- **Exclusive options**: Visual feedback when options become disabled

**RadioGroup:
- **Touch targets**: ~42px radio buttons (below iOS 44px recommendation)
- **Label interaction**: NOT tappable (same issue as Checkbox)
- **Deselection**: Can tap selected radio to deselect (mouse behavior on touch)
- **Accessibility**: Major VoiceOver violations, screen reader support broken

**AdvancedSelect** [affects: AdvancedSelect] üî¥ BETA:
- **Critical mobile failure**: Fixed 500px width causes horizontal scrolling on all iOS devices
- **Touch precision**: Chevron icons too small for reliable finger tapping
- **No mobile optimization**: Desktop tree navigation on mobile screen
- **Performance**: Severe degradation with >50 nodes

#### Android Behaviors [affects: specific fields] {comprehensive}

**Checkbox** [affects: Checkbox]:
- **Same label issue**: Label not tappable, must tap checkbox directly
- **Touch targets**: 48√ó48px meets Android accessibility guidelines
- **Material ripple**: Standard Material Design ripple effect on interaction
- **Visual consistency**: Proper Material-UI theming matches Android design language

**Select** [affects: Select]:
- **Dropdown behavior**: Material-UI dropdown with proper Material Design styling
- **Touch interaction**: Standard tap behavior with Material ripple effects
- **Back button**: Android back button closes dropdown without selection
- **Scrolling**: Smooth scroll with momentum, familiar Android behavior

**MultiSelect** [affects: MultiSelect]:
- **Material consistency**: Proper Material Design checkbox styling in both modes
- **Touch feedback**: Material ripple effects on all interactions
- **Performance**: Similar degradation patterns as iOS

**RadioGroup:
- **Material styling**: Proper Material Design radio button appearance
- **Same accessibility issues**: TalkBack violations, poor screen reader support
- **Performance**: Identical markdown processing lag as other platforms

**AdvancedSelect** [affects: AdvancedSelect] üî¥ BETA:
- **Same width issues**: Horizontal scrolling on most Android devices
- **Touch accuracy**: Difficult to select correct nodes on smaller screens
- **No Android optimizations**: No platform-specific improvements

#### Web/Desktop Behaviors [affects: All fields] {important}

**Mouse Interaction Patterns** [affects: All fields]:
- **Hover states**: All fields provide visual feedback on mouse hover
- **Precise clicking**: Exact pixel clicking allows smaller touch targets than mobile
- **Scroll behavior**: Mouse wheel scrolling in dropdown lists and hierarchies
- **Context menus**: Right-click behavior varies by field type (some suppress, others allow)

**Keyboard Navigation** [affects: All fields]:
- **Tab order**: All fields participate in logical tab sequence through form
- **Accessibility**: Better keyboard support than mobile, but still limited
- **Keyboard shortcuts**: Limited to basic Space/Enter/Arrow keys, no advanced shortcuts

**Desktop-Specific Advantages**:
- **Larger screens**: Can accommodate more options without scrolling
- **Precise interaction**: Mouse allows accurate selection of small UI elements
- **Multiple input methods**: Keyboard and mouse combination enables faster interaction
- **Performance**: Desktop browsers handle large option sets better than mobile

**Desktop Performance Characteristics**:
- **Select**: Can handle 100+ options with acceptable performance
- **MultiSelect**: Dropdown mode works well with 50+ options  
- **RadioGroup**: Still suffers from markdown processing issues
- **AdvancedSelect**: Better performance but still limited by architecture

### Shared Limitations {important}

#### Designer Interface Constraints {important}

**Configuration Limitations Across All Fields**:
- **No preview capability**: Cannot see field appearance or test interactions before deployment to actual devices
- **No field type conversion**: Cannot change RadioGroup to Select without complete field recreation and data loss
- **Limited parameter exposure**: Advanced properties require JSON editing with risk of Designer overwriting changes
- **No validation testing**: Cannot verify that validation schemas work correctly before deployment

**Option Management Constraints**:
- **Manual entry only**: No import from CSV, API, or external vocabulary sources  
- **No batch operations**: Cannot duplicate option sets across fields or projects
- **No option validation**: Designer doesn't verify option values are unique or contain safe characters
- **Performance warnings missing**: No indication when option counts will cause performance issues

#### Export Behavior {important}

See [Data Export Reference](data-export-reference.md) for comprehensive export documentation including CSV/JSON formats, special character handling, and Excel issues.

**Selection Field-Specific Export Notes**:
- **Value vs Label**: Exports values not labels (except Designer-created Select with value=label)
- **MultiSelect CSV**: Comma-joined values problematic if options contain commas
- **AdvancedSelect**: Exports path string with " > " delimiter, not hierarchical structure
- **Checkbox**: Exports as boolean true/false, not "TRUE"/"FALSE" strings
- **No option definitions**: Export doesn't include available options, only selected values

#### Component Architecture {comprehensive}

**Rendering Limitations** [affects: All fields]:
- **No virtualization**: All options render immediately in DOM, causing performance issues with large sets
- **No lazy loading**: Cannot load option subsets on demand
- **No search capability**: Users must manually scroll through all options
- **Fixed layouts**: Cannot adapt presentation to content size or device capabilities

**State Management Issues** [affects: All fields]:
- **No undo/redo**: Cannot reverse selection changes
- **State persistence problems**: Conditional navigation can lose expansion states (AdvancedSelect)
- **No draft states**: Changes apply immediately without confirmation capability

**Integration Constraints** [affects: All fields]:
- **Static vocabularies only**: No integration with external taxonomy services
- **No real-time updates**: Cannot update option lists based on other field changes
- **Limited conditional logic**: Only basic operators supported (equal, not-equal, contains)
- **No cross-field validation**: Cannot validate option combinations across multiple fields

#### Accessibility Compliance {important}

**WCAG 2.1 Level A Violations** [affects: Most fields]:

**Missing ARIA Attributes** [affects: Select, MultiSelect, RadioGroup, AdvancedSelect]:
- No `aria-required` for required fields
- No `aria-invalid` for error states  
- No `aria-describedby` for helper text association
- No `aria-errormessage` for validation feedback

**Keyboard Navigation Issues** [affects: RadioGroup, AdvancedSelect]:
- **RadioGroup**: Cannot deselect via keyboard after selection
- **AdvancedSelect**: Poor keyboard navigation through hierarchy trees
- **General**: No keyboard shortcuts for efficient navigation

**Screen Reader Support** [affects: RadioGroup, AdvancedSelect]:
- **RadioGroup**: Required state not announced, error states not communicated
- **AdvancedSelect**: Hierarchical structure not properly announced
- **All fields**: Validation error messages not announced when validation fails

**Visual Accessibility** [affects: Select, MultiSelect, RadioGroup, AdvancedSelect]:
- **Color-only error indication**: Error states shown only through color changes
- **No high contrast mode**: Limited support for high contrast themes
- **Small touch targets**: Some fields don't meet minimum 44px/48px touch target requirements

#### Testing Guidelines {comprehensive}

**Pre-Deployment Testing Checklist** [affects: All fields]:

**Functional Testing**:
- [ ] Test with minimum viable option set (2-3 options)
- [ ] Test with maximum expected option count for performance
- [ ] Verify all validation schemas work as expected
- [ ] Test conditional logic with all field states
- [ ] Verify data export format meets requirements

**Platform Testing**:
- [ ] Test on lowest-specification target mobile device
- [ ] Verify touch targets adequate on mobile screens
- [ ] Test keyboard navigation on desktop
- [ ] Check screen reader compatibility where required
- [ ] Validate consistent behavior across target browsers

**Performance Testing**:
- [ ] Monitor form load time with full field configuration
- [ ] Test interaction responsiveness with maximum option counts
- [ ] Check memory usage patterns with large datasets
- [ ] Verify export performance with realistic data volumes

**Accessibility Testing**:
- [ ] Test with screen reader (NVDA/JAWS on Windows, VoiceOver on Mac)
- [ ] Verify keyboard-only navigation works
- [ ] Check color contrast meets WCAG requirements
- [ ] Test with high contrast and zoom settings

**Data Integrity Testing**:
- [ ] Verify submitted values match expected format
- [ ] Test edge cases (empty submissions, special characters)
- [ ] Validate export/import round-trip data integrity
- [ ] Check conditional field behavior with various selections

## Field Reference {essential}

### Checkbox (Checkbox in Designer) {essential}
<!-- keywords: boolean, consent, binary, toggle, checkbox -->

**Quick Reference:**
| Property | Value |
|----------|-------|
| Designer Label | Checkbox |
| Component Name | Checkbox |
| Namespace | faims-custom |
| Type Returned | faims-core::Bool |
| Error Display | ‚úÖ Full (only field with proper errors) |
| Mobile Support | ‚úÖ Full (label not clickable) |
| Accessibility | ‚ùå Poor (no ARIA) |
| Touch Targets | 24√ó24px icon, 48√ó48px target |
| Performance | 20-30 optimal, 50+ degraded, 100+ unusable |
| Storage | Boolean (true/false, null‚Üífalse) |

### Purpose {essential}

The Checkbox field provides binary state capture through a Material-UI checkbox component, returning `faims-core::Bool` values. As the **only boolean field type in Fieldmark**, Checkbox serves dual purposes: simple true/false data capture and consent/acknowledgment workflows. Unlike RadioGroup and Select which return strings, Checkbox returns actual boolean primitives, making it ideal for programmatic logic.

**When to use:**
- Binary archaeological indicators - Presence/absence of features (charcoal present, bioturbation observed)
- Consent and agreements - Terms acceptance, privacy policy acknowledgment, data usage consent
- Procedural confirmations - Safety checks completed, equipment calibrated, protocols followed
- Optional enhancements - Include photographs, request review, generate report
- Data quality flags - Provisional data, requires verification, peer reviewed

### Core Configuration {essential}

```json
{
  "component-namespace": "faims-custom",
  "component-name": "Checkbox",
  "type-returned": "faims-core::Bool",
  "component-parameters": {
    "name": "terms-accept",
    "label": "I accept the terms and conditions",
    "helperText": "You must accept to continue",
    "required": true
  },
  "validationSchema": [
    ["yup.bool"],
    ["yup.oneOf", [true], "You must accept the terms to proceed"]
  ],
  "initialValue": false
}
```

### Key Features {essential}

- ‚úÖ **Boolean primitive values** - Returns true/false, not strings
- ‚úÖ **Best error display** - Only choice field showing both red color and error messages
- ‚úÖ **Immediate validation feedback** - Errors appear on change event after interaction
- ‚úÖ **Conditional logic support** - Works with boolean operators (equal: true/false)
- ‚ö†Ô∏è **Label not clickable** - Must click 24√ó24px checkbox icon directly, not label text (iOS requires 44√ó44px minimum)
- ‚ö†Ô∏è **Required validation misleading** - "Required" allows false but prevents null/undefined
- ‚ö†Ô∏è **Performance limits** - Degrades at 50+ checkboxes per form, unusable at 100+ (use MultiSelect instead)
- ‚ùå **No ARIA attributes** - Fails WCAG 2.1 Level A requirements
- üêõ **Label association broken** - Screen readers cannot announce field purpose

### Configuration Parameters {important}

**Required Parameters:**
- `name` (string): Field identifier
- `label` (string): Checkbox label text

**Optional Parameters:**
- `id` (string): HTML element ID (defaults to name)
- `helperText` (string): Additional guidance text
- `advancedHelperText` (string): Extended help with more detail
- `required` (boolean): Visual indicator only - doesn't enforce "must be checked"

**JSON-Only Properties:**
- `initialValue` (boolean): Can set to `true` for pre-checked (Designer forces `false`)
- `FormControlLabelProps` (object): MUI label customization (deprecated)
- `FormHelperTextProps` (object): MUI helper text customization (deprecated)

**Meta Fields:**
- `annotation.include` (boolean): Enable annotation field
- `uncertainty.include` (boolean): Enable uncertainty field

### Checkbox-Specific Validation {important}

| Validation Type | Configuration | Actual Behaviour | Error Message | Designer Support |
|-----------------|---------------|------------------|---------------|------------------|
| Boolean type | `["yup.bool"]` | Accepts true/false/null/undefined | "Must be a boolean" | ‚úÖ Default |
| Required field | `["yup.required"]` | **Misleading!** Prevents null/undefined but allows false | "This field is required" | ‚úÖ Checkbox |
| Must be checked | `["yup.oneOf", [true], "Message"]` | Only accepts true (checkbox must be checked) | Custom message | ‚ùå JSON only |
| Must be unchecked | `["yup.oneOf", [false]]` | Only accepts false | "Must be unchecked" | ‚ùå JSON only |
| Explicit selection | `["yup.oneOf", [true, false], "Message"]` | Requires deliberate true OR false | Custom message | ‚ùå JSON only |

**Critical Validation Clarification:**
"Required" for checkboxes does NOT mean "must be checked":
- `["yup.required"]` allows `false` (unchecked) as valid
- For consent forms use: `["yup.oneOf", [true], "You must accept"]`
- Designer's "required" checkbox creates confusion

**Validation Timing:**
- Validates on change (immediate feedback after first interaction)
- Errors display on blur (user leaves field)
- All validation runs on form submit attempt

### Checkbox-Specific Issues {important}

- **Label not clickable** - Users must tap/click the small checkbox target, violating standard checkbox behavior
- **Touch target too small** - 24√ó24px checkbox on mobile when 44√ó48px recommended
- **No haptic feedback** - No tactile response on mobile interactions
- **Accessibility failures** - Missing aria-required, aria-invalid, aria-describedby attributes
- **Screen reader incompatible** - Label not programmatically associated with checkbox
- **Initial state limitation** - Designer always forces `initialValue: false`

**Platform-Specific Behaviors:**
- **iOS**: Touch target below 44√ó44px Apple HIG standard, no native checkbox styling
- **Android**: Material Design 48√ó48px touch target not met, uses Material checkbox appearance
- **Desktop**: Hover states work correctly, click target matches visual 24√ó24px size
- **All platforms**: Label click does not toggle checkbox (Material-UI limitation)

### Field-Specific Troubleshooting {important}

| Issue | Cause | Solution | Prevention |
|-------|-------|----------|------------|
| Required not working | Checkbox can be unchecked despite required | "Required" doesn't mean "must be checked" | Use `["yup.oneOf", [true]]` for must-be-checked |
| Label not clickable | Must click checkbox itself, not label text | Label not properly associated | Known issue - train users to click checkbox |
| No initial checked | Cannot set checkbox to start checked in Designer | Designer forces false | Edit JSON to set `initialValue: true` |
| Validation confusing | Error appears when unchecked but field is "required" | Misunderstanding of boolean validation | Required prevents null, not false |
| Can't detect untouched | Conditional logic treats untouched same as unchecked | No isEmpty operator | Use different field type or track interaction separately |
| Multiple checkboxes | Can't enforce "at least one checked" across checkboxes | Individual checkboxes don't cross-validate | Use MultiSelect with expandedChecklist instead |

### Implementation Examples {comprehensive}

#### Terms Acceptance (Must Be Checked)
```json
{
  "terms-accept": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "name": "terms-accept",
      "label": "I accept the terms and conditions",
      "helperText": "You must accept to continue",
      "required": true
    },
    "validationSchema": [
      ["yup.bool"],
      ["yup.oneOf", [true], "You must accept the terms to proceed"]
    ],
    "initialValue": false
  }
}
```

#### Optional Enhancement Flag
```json
{
  "include-detailed": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "name": "include-detailed",
      "label": "Record detailed measurements",
      "helperText": "Check to show additional measurement fields"
    },
    "validationSchema": [["yup.bool"]],
    "initialValue": false,
    "meta": {
      "persistent": true
    }
  }
}
```

#### Data Quality Indicator with Persistence
```json
{
  "peer-reviewed": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "name": "peer-reviewed",
      "label": "Data peer reviewed",
      "advancedHelperText": "Check after secondary verification completed"
    },
    "validationSchema": [["yup.bool"]],
    "initialValue": false,
    "meta": {
      "displayParent": true,
      "persistent": true
    }
  }
}
```

#### Migration from RadioGroup Pattern
```json
{
  "heritage-present": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "name": "heritage-present",
      "label": "Aboriginal heritage identified",
      "helperText": "Previously Yes/No radio - now checkbox for boolean logic",
      "required": true
    },
    "validationSchema": [
      ["yup.bool"],
      ["yup.oneOf", [true, false], "Must explicitly indicate heritage status"]
    ],
    "initialValue": false,
    "meta": {
      "annotation": {"include": true, "label": "heritage notes"},
      "displayParent": true
    }
  }
}
```

### JSON Anti-patterns

```json
// ‚ùå Don't use required for "must be checked"
"validationSchema": [["yup.required"]]  // Allows false

// ‚úÖ Correct for must be checked
"validationSchema": [["yup.oneOf", [true], "Must accept"]]

// ‚ùå Don't set initial value in Designer
// Designer always overwrites to false

// ‚ùå Don't expect label to be clickable
"helperText": "Click the label to select"

// ‚úÖ Correct user guidance
"helperText": "Click the checkbox (not the label) to select"
```

### Common Spec Mappings

**Designer ‚Üí JSON mappings:**
- Designer "Required" ‚Üí `required: true` + `["yup.required"]` (misleading)
- Designer Label ‚Üí `label` property
- Designer Helper Text ‚Üí `helperText` property
- Designer Annotation toggle ‚Üí `meta.annotation.include` (see [Meta Properties Reference](meta-properties-reference.md))

**Conditional logic mappings:**
- Boolean true condition ‚Üí `{"operator": "equal", "value": true}`
- Boolean false condition ‚Üí `{"operator": "equal", "value": false}`
- Cannot check for empty/null state

---

### MultiSelect (Select Multiple in Designer) {essential}
<!-- keywords: multiple, selection, checklist, dropdown, array -->

**Quick Reference:**
| Property | Value |
|----------|-------|
| Designer Label | Select Multiple |
| Component Name | MultiSelect |
| Namespace | faims-custom |
| Type Returned | faims-core::Array |
| Error Display | ‚ùå No error messages shown |
| Mobile Support | ‚ö†Ô∏è Limited (performance issues >20 options) |
| Accessibility | ‚ùå Poor (no ARIA, on roadmap) |
| Touch Targets | Full row clickable (48px height) |
| Performance | ‚â§15 expanded optimal, 20+ dropdown, 50+ degraded |
| Storage | Array of strings, empty array valid |

### Purpose {essential}

The MultiSelect field enables multiple value selection from predefined option lists, returning `faims-core::Array` values. It provides two distinct display modes‚Äîdropdown with checkboxes or expanded checklist‚Äîoptimizing for different option counts and screen constraints. Unlike the single-selection limitations of RadioGroup, Select, and Checkbox fields, MultiSelect handles group validation through a single field returning an array.

**When to use:**
- Archaeological site features - Multiple characteristics present (defensive walls, domestic structures, industrial remains)
- Artefact materials - Objects with composite materials (ceramic with metal inlay, bone with shell decoration)
- Site formation processes - Multiple concurrent processes (alluvial, colluvial, anthropogenic)
- Conservation treatments - Multiple interventions applied (cleaned, consolidated, reconstructed)
- Damage assessment - Multiple damage types present (weathering, vandalism, vegetation)
- Exclusive conditions - "None observed" or "Unable to assess" options that clear all others

### Core Configuration {essential}

```json
{
  "component-namespace": "faims-custom",
  "component-name": "MultiSelect",
  "type-returned": "faims-core::Array",
  "component-parameters": {
    "name": "site-features",
    "id": "site-features",
    "label": "Site Features",
    "helperText": "Select all that apply",
    "ElementProps": {
      "options": [
        {"value": "defensive", "label": "Defensive structures"},
        {"value": "domestic", "label": "Domestic occupation"},
        {"value": "industrial", "label": "Industrial remains"}
      ],
      "expandedChecklist": true
    }
  },
  "validationSchema": [
    ["yup.array"],
    ["yup.min", 1, "Select at least one feature"]
  ],
  "initialValue": []
}
```

### Key Features {essential}

- ‚úÖ **Multiple selection support** - Returns array of selected values
- ‚úÖ **Two display modes** - Dropdown or expanded checklist
- ‚úÖ **Exclusive options** - Mutual exclusivity (selecting "None" clears others)
- ‚úÖ **Label clickable** - Unlike Checkbox field, entire row is clickable
- ‚úÖ **Array conditional operators** - Supports contains, contains-all-of, etc.
- ‚ö†Ô∏è **Empty array validation gotcha** - `["yup.required"]` considers `[]` as valid
- ‚ö†Ô∏è **Performance degradation** - Severe lag with >20 options in checklist mode
- ‚ùå **No error message display** - Validation runs but messages never appear
- ‚ùå **No search/filter** - Must scroll through all options
- üêõ **CSV export issue** - Comma-separated values break if options contain commas

### Configuration Parameters {important}

**Required Parameters:**
- `name` (string): Field identifier
- `label` (string): Field label
- `ElementProps.options` (array): Options array with value/label objects

**Optional Parameters:**
- `helperText` (string): Guidance text
- `required` (boolean): Validation indicator
- `ElementProps.expandedChecklist` (boolean): Display as checklist vs dropdown
- `ElementProps.exclusiveOptions` (array): Values that clear other selections
- `ElementProps.fullWidth` (boolean): Expand to container width
- `ElementProps.variant` (string): MUI variant styling

**Meta Fields:**
- `annotation.include` (boolean): Enable annotation field
- `uncertainty.include` (boolean): Enable uncertainty field

### MultiSelect-Specific Validation {important}

| Validation Type | Configuration | Behaviour | Critical Note |
|-----------------|---------------|-----------|---------------|
| Required field | `["yup.required"]` | Checks not null/undefined | ‚ö†Ô∏è **Empty array [] PASSES** - not what users expect |
| Minimum selection | `["yup.min", 1, "Select at least one"]` | Enforces minimum items | Use this for "required" behavior, NOT yup.required |
| Maximum selection | `["yup.max", 5, "Maximum 5 selections"]` | Limits selection count | Not enforced during interaction, only on submit |
| Array type | `["yup.array"]` | Ensures array type | Default, always included |
| Specific values | `["yup.array"], ["yup.of", ["yup.oneOf", ["val1", "val2"]]]` | Restricts to subset | Complex syntax for value validation |
| Min and max | `["yup.array"], ["yup.min", 2], ["yup.max", 5]` | Range constraint | Between 2-5 selections required |

**Critical Validation Behavior:**
- **NO ERROR DISPLAY**: Validation runs but messages never appear in UI
- **Empty array gotcha**: `["yup.required"]` considers `[]` as valid (field exists)
- **No proactive enforcement**: Max selection limit not prevented during interaction
- **Silent failures**: Users receive no feedback when validation fails

### MultiSelect-Specific Issues {important}

- **No error message display** - Validation messages configured but never shown to users
- **Performance degradation** - Severe lag with >20 options due to no virtualization
- **CSV export problems** - Options containing commas break CSV parsing
- **No search functionality** - Must manually scroll through all options
- **Touch precision required** - Small touch targets on mobile
- **No keyboard multi-select** - Cannot use Shift/Ctrl for range selection
- **Empty array validation confusion** - Required field passes with no selections

### Field-Specific Troubleshooting {important}

| Issue | Cause | Solution | Prevention |
|-------|-------|----------|------------|
| Required field passes when empty | `["yup.required"]` accepts `[]` | Use `["yup.min", 1]` instead | Always use yup.min for required multi-select |
| Performance lag with 20+ options | All options render immediately | Consider dropdown mode or reduce options | Limit options, test on mobile |
| CSV export breaks | Commas in option values | Remove commas from all option values | Use semicolons or pipes if separation needed |
| Can't see validation errors | No error display implementation | Check form submission prevention | Document validation in helperText |
| Labels not clickable | Wrong mode or version | Ensure expandedChecklist mode enabled | Test both modes |
| Can't select after choosing "None" | Exclusive option behavior | Deselect exclusive option first | Document exclusive behavior |
| No keyboard multi-select | Not implemented | Use Space/Enter on each item | Train users on individual selection |
| Options don't load dynamically | Static vocabularies only | Define all options at design time | Plan vocabulary completely upfront |

### Implementation Examples {comprehensive}

#### Basic Multi-Selection with Validation
```json
{
  "artefact-materials": {
    "component-name": "MultiSelect",
    "component-parameters": {
      "label": "Artefact Materials",
      "required": true,
      "helperText": "Select all materials present",
      "ElementProps": {
        "expandedChecklist": true,
        "options": [
          {"value": "ceramic", "label": "Ceramic"},
          {"value": "glass", "label": "Glass"},
          {"value": "metal", "label": "Metal"},
          {"value": "bone", "label": "Bone"},
          {"value": "shell", "label": "Shell"},
          {"value": "stone", "label": "Stone"}
        ]
      }
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "Select at least one material"]
    ],
    "initialValue": []
  }
}
```

#### Exclusive Options Pattern
```json
{
  "site-visibility": {
    "component-name": "MultiSelect",
    "component-parameters": {
      "label": "Visibility Conditions",
      "helperText": "Factors affecting site visibility",
      "ElementProps": {
        "expandedChecklist": true,
        "options": [
          {"value": "vegetation", "label": "Vegetation cover"},
          {"value": "erosion", "label": "Erosion"},
          {"value": "modern-development", "label": "Modern development"},
          {"value": "flooding", "label": "Seasonal flooding"},
          {"value": "excellent-visibility", "label": "Excellent visibility"},
          {"value": "not-accessed", "label": "Could not access"}
        ],
        "exclusiveOptions": ["excellent-visibility", "not-accessed"]
      }
    },
    "initialValue": []
  }
}
```

#### Dropdown for Long Lists
```json
{
  "permits-required": {
    "component-name": "MultiSelect",
    "component-parameters": {
      "label": "Permits Required",
      "helperText": "Select all applicable permit types",
      "ElementProps": {
        "expandedChecklist": false,
        "options": [
          {"value": "aboriginal-heritage", "label": "Aboriginal Heritage"},
          {"value": "environmental", "label": "Environmental Protection"},
          {"value": "local-council", "label": "Local Council"},
          {"value": "state-heritage", "label": "State Heritage"},
          {"value": "commonwealth", "label": "Commonwealth Heritage"},
          {"value": "landowner", "label": "Landowner Permission"},
          {"value": "mining-lease", "label": "Mining Lease Access"},
          {"value": "national-parks", "label": "National Parks"},
          {"value": "crown-lands", "label": "Crown Lands"},
          {"value": "none-required", "label": "No permits required"}
        ],
        "exclusiveOptions": ["none-required"]
      }
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "Specify permit requirements"]
    ]
  }
}
```

#### Migration from Multiple Checkboxes
```json
{
  "recording-methods": {
    "component-name": "MultiSelect",
    "component-parameters": {
      "label": "Recording Methods Used",
      "ElementProps": {
        "expandedChecklist": true,
        "options": [
          {"value": "photography", "label": "Photography"},
          {"value": "drawing", "label": "Scale drawing"},
          {"value": "gps", "label": "GPS coordinates"},
          {"value": "total-station", "label": "Total station"},
          {"value": "photogrammetry", "label": "Photogrammetry"}
        ]
      }
    },
    "initialValue": [],
    "meta": {
      "annotation": {
        "include": true,
        "label": "recording notes"
      }
    }
  }
}
```

### JSON Anti-patterns

```json
// ‚ùå Don't use yup.required for "at least one selection"
"validationSchema": [["yup.required"]]  // Accepts empty array

// ‚úÖ Correct for required multi-selection
"validationSchema": [["yup.min", 1, "Select at least one"]]

// ‚ùå Don't use commas in option values
{"value": "pottery, ceramics", "label": "Pottery, ceramics"}  // Breaks CSV

// ‚úÖ Use alternative separators
{"value": "pottery and ceramics", "label": "Pottery and ceramics"}

// ‚ùå Don't set initialValue to string
"initialValue": ""  // Must be array

// ‚úÖ Correct initial value
"initialValue": []

// ‚ùå Don't expect performance with many options
"options": [...100_options]  // Will lag severely

// ‚úÖ Limit options for performance
"options": [...15_options]  // Optimal
```

### Common Spec Mappings

**Designer ‚Üí JSON mappings:**
- Designer "Required" ‚Üí `required: true` (misleading - use yup.min instead)
- Designer option value/label ‚Üí Enforces value = label
- Designer "Expanded Checklist" ‚Üí `expandedChecklist: true`
- Designer "Exclusive" per option ‚Üí `exclusiveOptions` array

**Conditional logic mappings:**
- Array contains value ‚Üí `{"operator": "contains", "value": "option1"}`
- Array contains any ‚Üí `{"operator": "contains-one-of", "value": ["opt1", "opt2"]}`
- Array contains all ‚Üí `{"operator": "contains-all-of", "value": ["opt1", "opt2"]}`
- Empty array check ‚Üí `{"operator": "equal", "value": []}`

---

### RadioGroup
<!-- keywords: radio, single, selection, deprecated, broken -->

### RadioGroup Details
**Status**: Production - Known issues with error display and accessibility are on roadmap
**Alternative**: Use Select for all new implementations
**Migration**: See Migration Procedures below

**Quick Reference:**
| Property | Value |
|----------|-------|
| Designer Label | Select one option |
| Component Name | RadioGroup |
| Namespace | faims-custom |
| Type Returned | faims-core::String |
| Error Display | ‚ùå Red color only, no error messages |
| Mobile Support | ‚ö†Ô∏è Limited (problematic deselection, performance issues) |
| Accessibility | ‚ùå Critical violations (no ARIA, keyboard issues) |
| Touch Targets | 42px radio buttons (below iOS 44px standard) |
| Performance | 3-7 optimal, 10+ degraded, 20+ unusable |
| Storage | String, no null state after selection |

### Purpose {essential}

The RadioGroup field provides single selection from 2‚Äì10 mutually exclusive options through radio button interface, returning `faims-core::String` values. **However, this component suffers from severe limitations that make it unsuitable for production use:** no error message display (only color changes), critical accessibility violations, problematic deselection behavior, and severe performance degradation with >10 options.

**Historical use cases (now deprecated):**
- Condition assessments - Rating heritage fabric condition (use Select instead)
- Binary archaeological decisions - Presence/absence with explicit "Unknown" option (use Checkbox or Select)
- Likert scale responses - Survey questions with 3-7 point scales (use Select instead)
- Material type classification - Quick selection from common materials (use Select)

‚ö†Ô∏è **WARNING**: Due to critical limitations, use Select instead for all production deployments.

### Core Configuration {essential}

```json
{
  "component-namespace": "faims-custom",
  "component-name": "RadioGroup",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "fabric-condition",
    "label": "Fabric Condition",
    "helperText": "Click selected option to deselect (mouse only - accessibility issue)",
    "fullWidth": true,
    "required": true,
    "ElementProps": {
      "options": [
        {"value": "excellent", "label": "Excellent"},
        {"value": "good", "label": "Good"},
        {"value": "fair", "label": "Fair"},
        {"value": "poor", "label": "Poor"},
        {"value": "na", "label": "Not Applicable"}
      ]
    }
  },
  "validationSchema": [
    ["yup.string"],
    ["yup.required", "Condition required (message won't show)"],
    ["yup.oneOf", ["excellent","good","fair","poor","na"], "Invalid (won't show)"]
  ],
  "initialValue": "na"
}
```

### Key Features {essential}

- ‚úÖ **Single selection enforcement** - Only one option can be selected
- ‚úÖ **String values returned** - Compatible with text-based conditional logic
- ‚úÖ **Vertical layout** - All options visible simultaneously
- ‚ö†Ô∏è **Toggle deselection (broken)** - Can deselect via mouse/touch but NOT keyboard
- ‚ö†Ô∏è **Performance issues** - Severe lag with >10 options due to markdown parsing
- ‚ùå **No error message display** - Critical UX failure, only red color shown
- ‚ùå **No ARIA attributes** - Fails WCAG 2.1 Level A requirements
- ‚ùå **No Designer preview** - Cannot see appearance before deployment
- üêõ **Keyboard deselection broken** - Accessibility barrier
- üêõ **No empty state detection** - Conditional logic cannot check for unselected

### Configuration Parameters {important}

**Required Parameters:**
- `name` (string): Field identifier
- `label` (string): Field label
- `ElementProps.options` (array): Options with value/label pairs

**Optional Parameters:**
- `helperText` (string): Guidance text
- `required` (boolean): Validation indicator (misleading due to no error display)
- `fullWidth` (boolean): Expand to container width (JSON only)
- `disabled` (boolean): Disable entire RadioGroup (JSON only)
- `FormLabelProps` (object): MUI label customization (JSON only)
- `FormHelperTextProps` (object): MUI helper customization (JSON only)

### RadioGroup-Specific Validation {important}

| Validation Type | Configuration | Error Message | Actual Display | Designer Support |
|-----------------|---------------|---------------|----------------|------------------|
| Required field | `["yup.required", "Selection required"]` | "Selection required" | ‚ùå Red color only | ‚úÖ Checkbox |
| String type | `["yup.string"]` | Automatic | ‚ùå No message | ‚úÖ Default |
| One of values | `["yup.oneOf", ["yes","no"], "Invalid"]` | "Invalid" | ‚ùå No message | ‚ùå JSON only |
| Not null | `["yup.notOneOf", [null], "Must select"]` | "Must select" | ‚ùå No message | ‚ùå JSON only |
| Conditional required | Not supported | - | - | ‚ùå Not possible |

**‚ö†Ô∏è MAJOR BUG**: RadioGroup displays NO error messages - only shows red color when invalid. Users receive no text feedback about validation failures.

### RadioGroup-Specific Issues {important}

- **No error message display** - Critical UX failure, users get no validation feedback
- **Keyboard deselection broken** - Can deselect with mouse/touch but NOT keyboard (accessibility barrier)
- **No ARIA attributes** - Missing aria-required, aria-invalid, aria-describedby
- **Performance degradation** - Severe lag >10 options due to markdown parsing overhead
- **No empty state detection** - Cannot use isEmpty operator in conditional logic
- **No Designer preview** - Cannot see field appearance before deployment
- **Toggle deselection confusion** - Users don't know clicking selected option clears it
- **Export shows values not labels** - CSV exports technical values requiring lookup

### Field-Specific Troubleshooting {important}

| Issue | Cause | Solution | Prevention |
|-------|-------|----------|------------|
| No error messages shown | Not implemented | Add helper text explaining requirements | Use Select instead |
| Cannot deselect via keyboard | Bug in implementation | Use Select instead | Avoid RadioGroup |
| Screen reader incompatible | No ARIA attributes | Cannot fix - use Select | Accessibility audit |
| Performance >20 options | Markdown parsing overhead | Use Select for long lists | Limit options |
| Cannot detect empty state | No isEmpty operator | Add "None" option | Design around limitation |
| Exports missing labels | By design | Post-process with config | Use Select (value=label) |
| Required field confusion | Silent validation failure | Document in helperText | Use Select with visible errors |

### Implementation Examples {comprehensive}

#### Heritage Condition Assessment (Deprecated Pattern)
```json
{
  "component-namespace": "faims-custom",
  "component-name": "RadioGroup",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "fabric-condition",
    "label": "Fabric Condition",
    "helperText": "Click selected option to deselect (mouse only)",
    "fullWidth": true,
    "required": true,
    "ElementProps": {
      "options": [
        {"value": "excellent", "label": "Excellent"},
        {"value": "good", "label": "Good"},
        {"value": "fair", "label": "Fair"},
        {"value": "poor", "label": "Poor"},
        {"value": "na", "label": "Not Applicable"}
      ]
    }
  },
  "validationSchema": [
    ["yup.string"],
    ["yup.required", "Condition required (message won't show)"],
    ["yup.oneOf", ["excellent","good","fair","poor","na"], "Invalid (won't show)"]
  ],
  "initialValue": "na"
}
```

#### Migration to Select (Recommended)
```json
{
  "component-namespace": "faims-custom",
  "component-name": "Select",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "fabric-condition",
    "label": "Fabric Condition",
    "helperText": "Select the current condition",
    "fullWidth": true,
    "required": true,
    "ElementProps": {
      "options": [
        {"value": "", "label": "-- Select Condition --"},
        {"value": "Excellent", "label": "Excellent"},
        {"value": "Good", "label": "Good"},
        {"value": "Fair", "label": "Fair"},
        {"value": "Poor", "label": "Poor"},
        {"value": "Not Applicable", "label": "Not Applicable"}
      ]
    }
  },
  "validationSchema": [
    ["yup.string"],
    ["yup.required", "Condition selection required"]
  ],
  "initialValue": ""
}
```

#### Workflow Branching with Workarounds
```json
{
  "component-namespace": "faims-custom",
  "component-name": "RadioGroup",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "recording-type",
    "label": "Recording Type",
    "helperText": "Selection is permanent - cannot be cleared",
    "required": true,
    "ElementProps": {
      "options": [
        {"value": "full", "label": "Full Recording"},
        {"value": "rapid", "label": "Rapid Assessment"},
        {"value": "photo", "label": "Photo Only"}
      ]
    }
  },
  "validationSchema": [
    ["yup.string"],
    ["yup.required"],
    ["yup.notOneOf", [null], "Must select"]
  ],
  "initialValue": "rapid"
}
```

#### Binary Choice Alternative (Use Select Instead)
```json
{
  "component-namespace": "faims-custom",
  "component-name": "RadioGroup",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "has-features",
    "label": "Heritage Features Present",
    "helperText": "‚ö†Ô∏è DEPRECATED: Use Select or Checkbox instead",
    "ElementProps": {
      "options": [
        {"value": "yes", "label": "Yes"},
        {"value": "no", "label": "No"}
      ]
    }
  },
  "validationSchema": [
    ["yup.string"],
    ["yup.required", "Required (but won't display)"]
  ],
  "initialValue": ""
}
```
**Better Alternative**: Use Checkbox for true boolean logic:
```json
{
  "component-name": "Checkbox",
  "type-returned": "faims-core::Bool",
  "component-parameters": {
    "label": "Heritage Features Present"
  }
}
```

### JSON Anti-patterns

```json
// ‚ùå Don't expect error messages to display
"validationSchema": [["yup.required", "This message won't show"]]

// ‚ùå Don't rely on deselection feature
"helperText": "Click again to deselect"  // Broken on keyboard

// ‚ùå Don't use for accessibility-required applications
// RadioGroup fails WCAG compliance

// ‚ùå Don't use with many options
"options": [...20_options]  // Severe performance issues

// ‚úÖ Migrate to Select instead
"component-name": "Select"
"ElementProps": {
  "options": [
    {"value": "", "label": "-- Select --"},
    ...options
  ]
}
```

### Common Spec Mappings

**Designer ‚Üí JSON mappings:**
- Designer "Required" ‚Üí `required: true` + `["yup.required"]` (won't display error)
- Designer option values ‚Üí Exported as technical values (not labels)
- Designer drag-drop ‚Üí Option order in JSON array
- Designer no preview ‚Üí Must deploy to test

**Migration mappings (RadioGroup ‚Üí Select):**
- Add empty option: `{"value": "", "label": "-- Select --"}`
- Change validation messages (they'll actually display)
- Update conditional logic if needed
- Test error display works

---

### Select (Select Field in Designer) {essential}
<!-- keywords: dropdown, single, selection, standard -->

**Quick Reference:**
| Property | Value |
|----------|-------|
| Designer Label | Select Field |
| Component Name | Select |
| Namespace | faims-custom |
| Type Returned | faims-core::String |
| Error Display | ‚ùå No error messages shown |
| Mobile Support | ‚úÖ Good (consistent Material-UI across platforms) |
| Accessibility | ‚ö†Ô∏è Limited (basic keyboard support, missing ARIA) |
| Touch Targets | Native picker on mobile, dropdown on desktop |
| Performance | 50 options acceptable, 100+ degraded, 200+ unusable |
| Storage | String, empty string for no selection |

### Purpose {essential}

The Select field provides single-choice selection from a dropdown list, offering space-efficient presentation of controlled vocabularies through Material-UI's consistent interface across all platforms. This field type returns `faims-core::String` values and serves as the standard solution for single selection from more than 5-7 options, where RadioGroup would consume excessive screen space. While the component lacks error message display and accessibility attributes, it delivers reliable structured data collection with human-readable exports.

**When to use:**
- Taxonomic classification - Species lists, artefact types, material categories (10-50 options)
- Site or context types - Archaeological periods, depositional environments, feature types
- Standardized descriptions - Condition states, preservation levels, completeness percentages
- Administrative categories - Project phases, team members, institutional codes
- Geographical regions - Countries, states, survey areas, management zones
- Equipment or methods - Instrument types, sampling strategies, analysis techniques

### Core Configuration {essential}

```json
{
  "component-namespace": "faims-custom",
  "component-name": "Select",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "label": "Site Type",
    "name": "site-type",
    "helperText": "Select the primary site classification",
    "fullWidth": true,
    "required": true,
    "ElementProps": {
      "options": [
        {"value": "", "label": "-- Select Site Type --"},
        {"value": "Artefact scatter", "label": "Artefact scatter"},
        {"value": "Rock art", "label": "Rock art"},
        {"value": "Shell midden", "label": "Shell midden"},
        {"value": "Stone arrangement", "label": "Stone arrangement"},
        {"value": "Burial", "label": "Burial"},
        {"value": "Historic structure", "label": "Historic structure"},
        {"value": "Other", "label": "Other"}
      ]
    }
  },
  "validationSchema": [["yup.string"], ["yup.required"]],
  "initialValue": ""
}
```

### Key Features {essential}

- ‚úÖ **Space-efficient display** - Dropdown conserves screen real estate
- ‚úÖ **Consistent cross-platform** - Same Material-UI interface on all devices
- ‚úÖ **Human-readable exports** - Designer enforces value = label for interpretability
- ‚úÖ **Keyboard navigation** - Arrow keys, type-ahead, Enter/Escape support
- ‚úÖ **Standard selection flow** - Familiar dropdown interaction pattern
- ‚ö†Ô∏è **Limited touch targets** - 48px MenuItems meet minimum but could be larger
- ‚ö†Ô∏è **No search functionality** - Type-ahead limited to single character
- ‚ùå **No error message display** - Validation runs but errors not shown to users
- ‚ùå **No clear button** - Cannot deselect without choosing empty option
- ‚ùå **No ARIA attributes** - Missing accessibility support

### Configuration Parameters {important}

**Required Parameters:**
- `name` (string): Field identifier
- `ElementProps.options` (array): Options with value/label objects

**Optional Parameters:**
- `label` (string): Field label
- `helperText` (string): Guidance text
- `fullWidth` (boolean): Expand to container width
- `variant` (string): MUI variant ("outlined", "filled", "standard")
- `required` (boolean): Validation indicator
- `select` (boolean): Internal property (automatically true)
- `disabled` (boolean): Disable field

**JSON-Only Properties:**
- Different values vs labels (not recommended - breaks Designer advantage)
- Complex validation chains beyond basic required
- SelectProps for dropdown customization

### Select-Specific Validation {important}

| Validation Type | Configuration | Behaviour | User Experience |
|-----------------|---------------|-----------|-----------------|
| Required | `["yup.required"]` | Blocks submission if empty | Silent failure - no visual feedback |
| String Type | `["yup.string"]` | Always passes | Automatic - enforced by component |
| Min Length | `["yup.minLength", 3]` | Validates selection length | No error display |
| Pattern Match | `["yup.matches", "pattern"]` | Validates against regex | No error display |
| Custom Message | `["yup.required", "Please select"]` | Custom error text | Not displayed to user |

**Validation Behavior:**
- **On change**: Validation runs but errors not displayed
- **On blur**: No validation triggered
- **On submit**: Final validation blocks submission silently
- **In practice**: UI prevents invalid selections, making most validation redundant
- **Note**: Option membership validation not implemented (values not checked against options array)

### Select-Specific Issues {important}

- **No error message display** - Validation messages configured but never shown to users
- **No clear/deselect capability** - Must include empty option if null state needed
- **Limited search** - Type-ahead only jumps to first character, resets after ~1 second
- **No virtualization** - All options render immediately, performance degrades >50 options
- **No native mobile pickers** - Uses Material-UI dropdown instead of platform controls
- **Helper text position** - Displays above field (non-standard Material-UI position)
- **No field type conversion** - Cannot convert from RadioGroup without deletion/recreation

### Field-Specific Troubleshooting {important}

| Issue | Symptoms | Cause | Resolution |
|-------|----------|-------|------------|
| No error messages | Required field fails silently | Component lacks error display | Train users on required fields; form structure indicates requirements |
| Slow dropdown | Lag when opening with many options | No virtualization for large lists | Limit to <50 options; consider categories or different field type |
| Can't deselect | No way to clear selection | No built-in clear button | Include empty option: `{"value": "", "label": "-- None --"}` |
| Preview missing | Can't test in Designer | Feature not implemented | Save and deploy to test environment; preview on roadmap |
| Can't convert type | Must delete RadioGroup to create Select | No field type conversion | Note options, delete field, recreate as Select; conversion planned |
| Touch precision | Hard to select on mobile | Default touch targets | Ensure clean/dry hands; consider RadioGroup for frequent selections |
| Data shows codes | CSV has "001" not "Archaeological Site" | Manual JSON editing with different value/label | Use Designer; ensure value = label |

### Implementation Examples {comprehensive}

#### Site Classification (Heritage Context)
```json
{
  "site-type": {
    "component-namespace": "faims-custom",
    "component-name": "Select",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Site Type",
      "name": "site-type",
      "helperText": "Select the primary site classification",
      "fullWidth": true,
      "required": true,
      "ElementProps": {
        "options": [
          {"value": "Artefact scatter", "label": "Artefact scatter"},
          {"value": "Rock art", "label": "Rock art"},
          {"value": "Shell midden", "label": "Shell midden"},
          {"value": "Stone arrangement", "label": "Stone arrangement"},
          {"value": "Burial", "label": "Burial"},
          {"value": "Historic structure", "label": "Historic structure"},
          {"value": "Other", "label": "Other"}
        ]
      }
    },
    "validationSchema": [["yup.string"], ["yup.required"]],
    "initialValue": "",
    "meta": {
      "annotation": {"include": true, "label": "classification notes"},
      "uncertainty": {"include": true, "label": "confidence"}
    }
  }
}
```

#### Condition Assessment with Null Option
```json
{
  "condition-state": {
    "component-namespace": "faims-custom",
    "component-name": "Select",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Condition",
      "name": "condition-state",
      "helperText": "Assess current preservation state",
      "fullWidth": true,
      "ElementProps": {
        "options": [
          {"value": "", "label": "-- Not assessed --"},
          {"value": "Excellent", "label": "Excellent"},
          {"value": "Good", "label": "Good"},
          {"value": "Fair", "label": "Fair"},
          {"value": "Poor", "label": "Poor"},
          {"value": "Destroyed", "label": "Destroyed"}
        ]
      }
    },
    "validationSchema": [["yup.string"]],
    "initialValue": "",
    "meta": {
      "annotation": {"include": true, "label": "condition notes"}
    }
  }
}
```

#### Triggering Conditional Fields
```json
{
  "material-type": {
    "component-namespace": "faims-custom",
    "component-name": "Select",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Material Type",
      "name": "material-type",
      "fullWidth": true,
      "ElementProps": {
        "options": [
          {"value": "Ceramic", "label": "Ceramic"},
          {"value": "Glass", "label": "Glass"},
          {"value": "Metal", "label": "Metal"},
          {"value": "Other", "label": "Other"}
        ]
      }
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  },
  "other-material": {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Specify Other Material",
      "name": "other-material"
    },
    "condition": {
      "field": "material-type",
      "operator": "equal",
      "value": "Other"
    }
  }
}
```

### JSON Anti-patterns

```json
// ‚ùå Don't use different values and labels in JSON
{"value": "001", "label": "Archaeological Site"}  // Exports only "001"

// ‚úÖ Use Designer enforced value = label
{"value": "Archaeological Site", "label": "Archaeological Site"}

// ‚ùå Don't expect error messages to display
"validationSchema": [["yup.required", "This message won't show"]]

// ‚ùå Don't omit empty option for clearable fields
"options": [
  {"value": "option1", "label": "Option 1"}
  // Missing empty option
]

// ‚úÖ Include empty option when null state valid
"options": [
  {"value": "", "label": "-- Select --"},
  {"value": "option1", "label": "Option 1"}
]
```

### Common Spec Mappings

**Designer ‚Üí JSON mappings:**
- Designer options ‚Üí Automatic value = label enforcement
- Designer "Required" ‚Üí `required: true` (no visual validation feedback)
- Designer Label ‚Üí `label` property
- Designer Helper Text ‚Üí `helperText` property

**Conditional logic mappings:**
- String equality ‚Üí `{"operator": "equal", "value": "exact_match"}`
- Empty check ‚Üí `{"operator": "equal", "value": ""}`
- Cannot use `isEmpty`, `contains`, or `notEqual` operators

**Migration from RadioGroup:**
- Add empty option for null state capability
- Remove toggle deselection behavior
- Same string-based conditional logic works
- Better error handling (though still no display)

---

### AdvancedSelect (Select Field (Hierarchical) in Designer) {essential} üî¥ BETA
<!-- keywords: hierarchical, tree, taxonomy, beta, broken -->

‚ö†Ô∏è **BETA COMPONENT**
**Status**: Beta - not recommended for production use
**Issues**: Cannot clear selection, requires JSON editing for hierarchy, mobile layouts broken
**Alternative**: Use cascading Select fields or Select with prefixed options

**Quick Reference:**
| Property | Value |
|----------|-------|
| Designer Label | Select Field (Hierarchical) |
| Component Name | AdvancedSelect |
| Namespace | faims-custom |
| Type Returned | faims-core::String |
| Error Display | ‚ùå No error messages shown |
| Mobile Support | ‚ùå Broken (fixed width causes scrolling, small touch targets) |
| Accessibility | ‚ùå Poor (limited keyboard support, no ARIA) |
| Touch Targets | Fixed 500px width causes mobile scrolling |
| Performance | 50 nodes optimal, 100+ degraded, 500+ unusable |
| Storage | String path with " > " delimiter |

### Purpose {essential}

The AdvancedSelect field provides hierarchical tree navigation for selecting values from nested vocabularies, returning `faims-core::String` values representing either full paths or leaf nodes. **Currently in beta status** due to incomplete Designer integration, performance limitations, and multiple critical bugs. This field renders entire tree structures without optimization, making it unsuitable for large datasets or mobile deployment.

**Intended use cases (when stable):**
- Biological taxonomic classification (kingdom ‚Üí phylum ‚Üí class ‚Üí order)
- Archaeological typologies (material ‚Üí technique ‚Üí form ‚Üí decoration)
- Geographic hierarchies (continent ‚Üí country ‚Üí region ‚Üí site)
- Organizational structures (department ‚Üí division ‚Üí team ‚Üí role)
- Stratigraphic sequences (period ‚Üí phase ‚Üí context ‚Üí feature)

**Critical limitations**: No error display, no clear/deselect capability, no search functionality, severe performance degradation beyond 100 nodes, requires JSON hand-editing, breaks mobile layouts.

### Core Configuration {essential}

```json
{
  "component-namespace": "faims-custom",
  "component-name": "AdvancedSelect",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "species-classification",
    "label": "Species Classification",
    "valuetype": "full",
    "helperText": "Navigate to the most specific classification possible",
    "ElementProps": {
      "optiontree": [
        {
          "name": "Animalia",
          "children": [
            {
              "name": "Chordata",
              "children": [
                {
                  "name": "Mammalia",
                  "children": [
                    {
                      "name": "Primates",
                      "children": [
                        {
                          "name": "Hominidae",
                          "children": [
                            {
                              "name": "Homo",
                              "children": [
                                {
                                  "name": "Homo sapiens",
                                  "label": "Human"
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  },
  "validationSchema": [["yup.string"], ["yup.required", "Classification required"]],
  "initialValue": ""
}
```

### Key Features {essential}

- ‚úÖ **Hierarchical navigation** - Tree structure with expand/collapse
- ‚úÖ **Full path or leaf storage** - Configurable via valuetype parameter
- ‚úÖ **Any node selectable** - Parent and child nodes can be selected
- ‚úÖ **Conditional logic support** - Standard string operators work
- ‚ö†Ô∏è **Beta status** - Incomplete implementation, multiple critical bugs
- ‚ö†Ô∏è **JSON editing required** - Hierarchy structure must be hand-coded
- ‚ö†Ô∏è **Performance issues** - Severe degradation >100 nodes
- ‚ùå **No clear/deselect** - Cannot remove selection once made
- ‚ùå **No error display** - Validation messages never shown
- ‚ùå **Mobile broken** - Fixed width causes horizontal scrolling
- üêõ **No search capability** - Must manually navigate entire hierarchy
- üêõ **Lost expansion state** - Tree collapses when navigating away

### Configuration Parameters {important}

**Required Parameters:**
- `name` (string): Field identifier
- `label` (string): Field label
- `ElementProps.optiontree` (array): Hierarchical tree structure

**Optional Parameters:**
- `helperText` (string): Guidance text
- `required` (boolean): Validation indicator (error won't display)
- `valuetype` (string): "full" (default) stores complete path, "child" stores node name only
- `disabled` (boolean): Disable entire tree (no node-level control)

**Node Structure:**
```typescript
interface TreeNode {
  name: string;        // Required: Used for path construction
  label?: string;      // Optional: Display override
  children?: TreeNode[]; // Optional: Child nodes
}
```

### AdvancedSelect-Specific Validation {important}

| Rule | Configuration | Effect | Error Message | Display |
|------|---------------|--------|---------------|---------|
| required | `["yup.required"]` | Blocks submission if empty | "This field is required" | **NEVER SHOWN** |
| oneOf | `["yup.oneOf", ["val1", "val2"]]` | Restricts to specific values | "Must be one of the following values" | **NEVER SHOWN** |
| matches | `["yup.matches", "pattern"]` | Pattern matching on stored value | "Must match pattern" | **NEVER SHOWN** |

**Critical Validation Issues:**
- **No error display**: Validation errors never shown to users (same as other choice fields)
- **Form blocking**: Invalid fields prevent submission but give no feedback
- **Required paradox**: Required validation fails silently, confusing users
- **Clear issue**: Cannot clear selection to fix validation errors

### AdvancedSelect-Specific Issues {important}

- **Cannot clear selection** - No UI mechanism to deselect once a value is chosen
- **JSON editing required** - Hierarchy structure must be manually coded (Designer limitation)
- **Mobile layouts broken** - Fixed 500px width causes horizontal scrolling on phones
- **Performance degradation** - Severe lag >100 nodes, no virtualization
- **No search functionality** - Must manually expand and navigate entire tree
- **Touch targets too small** - 24px chevron icons difficult to tap accurately
- **Lost expansion state** - Tree collapses when navigating away from field
- **No Designer preview** - Cannot see tree structure before deployment
- **No validation against tree** - Can store values not in defined hierarchy

### Field-Specific Troubleshooting {important}

| Issue | Cause | Solution | Prevention |
|-------|-------|----------|------------|
| Cannot clear selection | No deselect mechanism | Add TextField for manual override or reload form | Document limitation to users |
| Validation error not showing | No error display implementation | Check form won't submit, add helperText explaining requirements | Use Select for critical fields |
| Horizontal scrolling on mobile | Fixed 500px width | Use Select field for mobile deployment | Restrict to tablet/desktop only |
| Performance degradation | Renders entire tree immediately | Limit to <100 nodes | Use multiple Select fields instead |
| Tree starts collapsed | No default expansion | Document navigation requirements | Consider flat Select if few options |
| Lost expansion state | State not preserved | Warn users about navigation | Keep forms on single page |
| Required field confusion | Silent validation failure | Explicitly document in helperText | Avoid required validation |
| Hierarchy not in Designer | Must edit JSON manually | Provide JSON templates | Use Select until Designer support |

### Implementation Examples {comprehensive}

#### Biological Taxonomy (Full Path Storage)
```json
{
  "species-classification": {
    "component-namespace": "faims-custom",
    "component-name": "AdvancedSelect",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Species Classification",
      "name": "species-classification",
      "valuetype": "full",
      "helperText": "Navigate to the most specific classification possible",
      "ElementProps": {
        "optiontree": [
          {
            "name": "Animalia",
            "children": [
              {
                "name": "Chordata",
                "children": [
                  {
                    "name": "Mammalia",
                    "children": [
                      {
                        "name": "Primates",
                        "children": [
                          {
                            "name": "Hominidae",
                            "children": [
                              {
                                "name": "Homo",
                                "children": [
                                  {
                                    "name": "Homo sapiens",
                                    "label": "Human"
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Species classification required"]
    ],
    "initialValue": "",
    "meta": {
      "annotation": {"include": true, "label": "Identification notes"}
    }
  }
}
```
**Behavior**: Stores full path like "Animalia > Chordata > Mammalia > Primates > Hominidae > Homo > Homo sapiens". No error display despite required validation.

#### Archaeological Context Hierarchy (Child Storage)
```json
{
  "context-hierarchy": {
    "component-namespace": "faims-custom",
    "component-name": "AdvancedSelect",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Stratigraphic Context",
      "name": "context-hierarchy",
      "valuetype": "child",
      "helperText": "Select the specific context",
      "ElementProps": {
        "optiontree": [
          {
            "name": "Trench 1",
            "children": [
              {
                "name": "Layer 001",
                "label": "Topsoil",
                "children": [
                  {
                    "name": "Context 001-A",
                    "children": []
                  },
                  {
                    "name": "Context 001-B",
                    "children": []
                  }
                ]
              },
              {
                "name": "Layer 002",
                "label": "Occupation",
                "children": [
                  {
                    "name": "Context 002-A",
                    "label": "Floor surface",
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```
**Behavior**: With valuetype: "child", stores only selected node like "Context 002-A" without path.

#### Geographic Hierarchy with Clear Workaround
```json
{
  "location-hierarchy": {
    "component-namespace": "faims-custom",
    "component-name": "AdvancedSelect",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Site Location",
      "name": "location-hierarchy",
      "valuetype": "full",
      "ElementProps": {
        "optiontree": [
          {
            "name": "Australia",
            "children": [
              {
                "name": "New South Wales",
                "children": [
                  {
                    "name": "Sydney Region",
                    "children": [
                      {"name": "Site 001"},
                      {"name": "Site 002"}
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  },
  "clear-selection": {
    "component-name": "TextField",
    "label": "Clear Selection Workaround",
    "helperText": "Since selection cannot be cleared, provide manual override",
    "condition": {
      "field": "location-hierarchy",
      "operator": "not-equal",
      "value": ""
    }
  }
}
```
**Limitation demonstrated**: Once a location is selected, it cannot be cleared. The TextField workaround provides a manual way to note when selection should be ignored.

### JSON Anti-patterns

```json
// ‚ùå Don't expect selection clearing capability
"helperText": "Click to deselect"  // Not possible

// ‚ùå Don't use on mobile without workarounds
// Fixed width will break mobile layouts

// ‚ùå Don't use large hierarchies
"optiontree": [...500_nodes]  // Will crash or freeze

// ‚ùå Don't expect error messages
"validationSchema": [["yup.required", "Won't display"]]

// ‚ùå Don't use " > " in node names
"name": "Level > Sublevel"  // Breaks path parsing

// ‚úÖ Use alternative approaches for production
"component-name": "Select",
"ElementProps": {
  "options": [
    {"value": "Kingdom: Animalia", "label": "Kingdom: Animalia"},
    {"value": "Phylum: Chordata", "label": "Phylum: Chordata"}
  ]
}
```

### Common Spec Mappings

**Designer ‚Üí JSON mappings:**
- Designer basic properties ‚Üí Limited subset (label, helperText, valuetype)
- Designer hierarchy editing ‚Üí **NOT AVAILABLE** (must edit JSON)
- Designer preview ‚Üí **NOT AVAILABLE** (must deploy to test)

**Conditional logic mappings:**
- Full path matching ‚Üí `{"operator": "equal", "value": "Level1 > Level2 > Level3"}`
- Child name matching ‚Üí `{"operator": "equal", "value": "Level3"}` (with valuetype: "child")
- Exact string match required ‚Üí No partial path or wildcard support

**Migration alternatives:**
- **To cascading Select fields** ‚Üí Split hierarchy levels into separate Select fields
- **To prefixed Select options** ‚Üí Flatten hierarchy with "Kingdom: Animalia", "Phylum: Chordata" format
- **To multiple fields** ‚Üí Use separate fields for each classification level

---

## Troubleshooting Guide {important}

### Error Message Reference {important}

| Error Message | Field(s) Affected | Cause | Quick Fix |
|---------------|-------------------|-------|-----------|
| "Component Checkbox not found" | Checkbox | Wrong namespace | Use `faims-custom` not `formik-material-ui` |
| "Component RadioGroup not found" | RadioGroup | Wrong namespace | Use `faims-custom` not `formik-material-ui` |
| "Cannot read property 'map' of undefined" | MultiSelect, Select | Missing options array | Ensure `ElementProps.options` is defined |
| "Invalid prop 'value' of type 'string'" | MultiSelect | Wrong data type | MultiSelect expects array, not string |
| "Required field" (not showing) | RadioGroup | Component limitation | RadioGroup cannot display errors - use Select |
| "options.map is not a function" | All selection fields | Options not an array | Ensure options is array of objects |

### Quick Reference Matrix {important}

| Feature | Checkbox | MultiSelect | RadioGroup | Select | AdvancedSelect |
|---------|----------|-------------|------------|--------|----------------|
| Error Display | ‚úÖ Full | ‚ùå None | ‚ùå None | ‚úÖ Full | ‚ö†Ô∏è Partial |
| Mobile Support | ‚úÖ Good | ‚úÖ Good | ‚úÖ Good | ‚úÖ Good | ‚ùå Poor |
| Can Deselect | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚ùå No |
| Accessibility | ‚ùå Poor | ‚ö†Ô∏è Basic | ‚ö†Ô∏è Basic | ‚úÖ Good | ‚ùå Poor |
| Designer Config | ‚úÖ Full | ‚ö†Ô∏è Partial | ‚ö†Ô∏è Partial | ‚ö†Ô∏è Partial | ‚ùå None |

### Critical Issues Table {important}

| Issue | Field(s) | Severity | Impact | Workaround |
|-------|----------|----------|--------|------------|
| No error display | RadioGroup, MultiSelect | üî¥ High | Users don't see validation | Use Select or add helperText |
| Cannot clear selection | RadioGroup, AdvancedSelect | üî¥ High | Data correction impossible | Use Select with empty option |
| Label not clickable | Checkbox | üü° Medium | Poor UX on mobile | Train users to click checkbox |
| Options require JSON | All except Checkbox | üü° Medium | Designer limitation | Edit JSON directly |
| Empty array passes required | MultiSelect | üü° Medium | Invalid data saved | Use yup.min(1) validation |

### Common Problems Table {important}

| Problem | Symptoms | Fields Affected | Solution |
|---------|----------|-----------------|----------|
| Validation not showing | Form submits with invalid data | RadioGroup, MultiSelect | Switch to Select or Checkbox |
| Cannot remove selection | Once selected, stuck | RadioGroup, AdvancedSelect | Add empty option or use Select |
| Options not appearing | Dropdown empty | All selection fields | Check options array format |
| Wrong component error | Component not found | All | Check namespace is faims-custom |
| Data type mismatch | Values not saving | MultiSelect | Ensure array type for MultiSelect |

### Detailed Issue Matrix {important}

| Component | Issue Type | Platform | Frequency | User Impact | Dev Impact |
|-----------|------------|----------|-----------|-------------|------------|
| Checkbox | Label click | All | Always | Confusion | Training needed |
| MultiSelect | No errors | All | Always | Silent failure | Data validation issues |
| RadioGroup | No errors | All | Always | Silent failure | Should migrate to Select |
| RadioGroup | Can't deselect | All | Always | Data stuck | Add empty option |
| AdvancedSelect | Can't clear | All | Always | Data stuck | Use alternative |
| AdvancedSelect | No Designer | All | Always | JSON only | Manual config |

### Quick Fixes Table {important}

| Issue | Quick Fix | Permanent Solution |
|-------|-----------|-------------------|
| Component not found | Change namespace to `faims-custom` | Update all components |
| No error display | Add custom helperText | Migrate to Select |
| Cannot deselect | Add empty option `{"label": "None", "value": ""}` | Use Select component |
| Validation not working | Add yup validation schema | Test validation chain |
| Options not showing | Check options array format | Validate JSON structure |

### Complete Error Reference {comprehensive}

#### Component Loading Errors
- **"Component [name] not found"**: Wrong namespace, should be `faims-custom`
- **"Cannot read property 'component-name'"**: Missing component-name in JSON
- **"Invalid component configuration"**: Malformed JSON structure

#### Validation Errors (When Supported)
- **"Required field"**: Only shows in Checkbox and Select
- **Silent validation failure**: RadioGroup and MultiSelect don't display errors
- **"Must accept terms"**: Checkbox with yup.oneOf([true]) validation

#### Data Type Errors
- **"Expected array, got string"**: MultiSelect value must be array
- **"Expected string, got object"**: Select value must be string
- **"Expected boolean"**: Checkbox value must be true/false

### Debug Checklists {comprehensive}

#### General Field Checklist {comprehensive}
- [ ] Component namespace is `faims-custom`
- [ ] Component name matches exactly (case-sensitive)
- [ ] Options array is properly formatted
- [ ] Type-returned matches expected data type
- [ ] Validation schema matches field type
- [ ] Initial value matches field type
- [ ] Field name is unique in form
- [ ] No circular dependencies in conditionals

#### Field-Specific Checks {comprehensive}

**Checkbox Checks:**
- [ ] Using `faims-core::Bool` type
- [ ] Initial value is boolean (not string)
- [ ] For "must accept": using yup.oneOf([true])
- [ ] Not expecting label to be clickable

**MultiSelect Checks:**
- [ ] Using `faims-core::Array` type
- [ ] Initial value is array (even if empty)
- [ ] Options array has label/value objects
- [ ] Using yup.min(1) for required validation
- [ ] Not expecting error messages to display

**RadioGroup Checks:**
- [ ] Consider migrating to Select
- [ ] Has empty option if deselection needed
- [ ] Not relying on error display
- [ ] Using helperText for validation feedback

**Select Checks:**
- [ ] Using `faims-core::String` type
- [ ] Has empty option for optional fields
- [ ] Options array properly formatted
- [ ] Label positioning correct

**AdvancedSelect Checks:**
- [ ] Consider using alternatives
- [ ] JSON configuration complete
- [ ] Not using in production
- [ ] Has fallback for mobile

### Field-Specific Issues {important}

See Individual Field Reference section for detailed field-specific issues.

### Emergency Rollback Procedures {important}

#### When RadioGroup Fails in Production
1. Export all data immediately
2. Replace RadioGroup with Select in JSON
3. Map existing values (no data loss for single selection)
4. Test validation displays correctly
5. Redeploy

#### When MultiSelect Loses Data
1. Check if empty arrays were saved
2. Export data with timestamps
3. Add yup.min(1) validation
4. Review all submissions since deployment
5. Manually correct empty submissions

#### When AdvancedSelect Breaks
1. Screenshot current selections
2. Export all hierarchical data
3. Replace with Select using prefixed labels
4. Flatten hierarchy into single level
5. Update training materials

## JSON Examples {comprehensive}

### Checkbox Examples {important}

#### Terms Acceptance (Must Accept)
```json
{
  "terms-acceptance": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "name": "terms-acceptance",
      "id": "terms-acceptance",
      "label": "I accept the terms and conditions",
      "required": true,
      "helperText": "You must accept the terms to continue"
    },
    "validationSchema": [
      ["yup.bool"],
      ["yup.oneOf", [true], "You must accept the terms"]
    ],
    "initialValue": false
  }
}
```

#### Optional Enhancement Flag
```json
{
  "include-photos": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "name": "include-photos",
      "id": "include-photos",
      "label": "Include photographic documentation",
      "required": false
    },
    "initialValue": false
  }
}
```

### MultiSelect Examples {important}

#### Feature Checklist with Exclusive None
```json
{
  "observed-features": {
    "component-namespace": "faims-custom",
    "component-name": "MultiSelect",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "observed-features",
      "id": "observed-features",
      "label": "Observed Features",
      "required": true,
      "ElementProps": {
        "options": [
          {"label": "Stone artifacts", "value": "stone"},
          {"label": "Ceramics", "value": "ceramics"},
          {"label": "Bone fragments", "value": "bone"},
          {"label": "Charcoal", "value": "charcoal"},
          {"label": "No features observed", "value": "none", "exclusive": true}
        ],
        "displayType": "expandedChecklist"
      }
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "Select at least one option"]
    ],
    "initialValue": []
  }
}
```

### RadioGroup Examples {important}

#### Deprecated - Condition Assessment
```json
{
  "condition": {
    "component-namespace": "faims-custom",
    "component-name": "RadioGroup",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "condition",
      "id": "condition",
      "label": "Site Condition",
      "required": true,
      "helperText": "Note: RadioGroup is deprecated - use Select",
      "ElementProps": {
        "options": [
          {"label": "Excellent", "value": "excellent"},
          {"label": "Good", "value": "good"},
          {"label": "Fair", "value": "fair"},
          {"label": "Poor", "value": "poor"},
          {"label": "Not assessed", "value": ""}
        ]
      }
    },
    "initialValue": ""
  }
}
```

### Select Examples {important}

#### Site Type with Empty Option
```json
{
  "site-type": {
    "component-namespace": "faims-custom",
    "component-name": "Select",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "site-type",
      "id": "site-type",
      "label": "Site Type",
      "required": false,
      "ElementProps": {
        "options": [
          {"label": "-- Select type --", "value": ""},
          {"label": "Rockshelter", "value": "rockshelter"},
          {"label": "Open camp", "value": "open_camp"},
          {"label": "Quarry", "value": "quarry"},
          {"label": "Rock art", "value": "rock_art"}
        ]
      }
    },
    "initialValue": ""
  }
}
```

### AdvancedSelect Examples {important}

#### Beta - Taxonomic Classification
```json
{
  "taxonomy": {
    "component-namespace": "faims-custom",
    "component-name": "AdvancedSelect",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "taxonomy",
      "id": "taxonomy",
      "label": "Taxonomic Classification (BETA)",
      "helperText": "Warning: Cannot clear once selected",
      "ElementProps": {
        "options": [
          {
            "label": "Animalia",
            "value": "animalia",
            "children": [
              {
                "label": "Chordata",
                "value": "chordata",
                "children": [
                  {"label": "Mammalia", "value": "mammalia"},
                  {"label": "Aves", "value": "aves"}
                ]
              }
            ]
          },
          {
            "label": "Plantae",
            "value": "plantae",
            "children": [
              {"label": "Angiosperms", "value": "angiosperms"},
              {"label": "Gymnosperms", "value": "gymnosperms"}
            ]
          }
        ]
      }
    }
  }
}
```

## Migration Scenarios {comprehensive}

### Migration Decision Tree {comprehensive}

```
Current Field Type?
‚îÇ
‚îú‚îÄ RadioGroup (DEPRECATED)
‚îÇ  ‚îú‚îÄ Single selection needed?
‚îÇ  ‚îÇ  ‚îú‚îÄ YES ‚Üí Migrate to Select
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ Add empty option for deselection
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ Update validation schemas
‚îÇ  ‚îÇ  ‚îî‚îÄ NO ‚Üí Multiple selection?
‚îÇ  ‚îÇ     ‚îî‚îÄ YES ‚Üí Migrate to MultiSelect
‚îÇ  ‚îÇ
‚îú‚îÄ Multiple Checkboxes
‚îÇ  ‚îú‚îÄ Logically grouped?
‚îÇ  ‚îÇ  ‚îú‚îÄ YES ‚Üí Migrate to MultiSelect
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ Use expandedChecklist display
‚îÇ  ‚îÇ  ‚îî‚îÄ NO ‚Üí Keep as separate Checkboxes
‚îÇ  ‚îÇ
‚îú‚îÄ AdvancedSelect (BETA)
‚îÇ  ‚îú‚îÄ Hierarchy essential?
‚îÇ  ‚îÇ  ‚îú‚îÄ YES ‚Üí Keep but warn users
‚îÇ  ‚îÇ  ‚îî‚îÄ NO ‚Üí Migrate to Select with prefixes
‚îÇ  ‚îÇ
‚îî‚îÄ Text/Number for selection
   ‚îî‚îÄ Fixed options? ‚Üí Migrate to Select
```

### Migration Warnings Index

#### Safe Migrations (No Data Loss)
- RadioGroup ‚Üí Select (single string value preserved)
- Multiple Checkboxes ‚Üí MultiSelect (combine into array)
- Text field ‚Üí Select (if values match options)

#### Breaking Changes (Data Loss Risk)
- MultiSelect ‚Üí Select (array to string - loses multiple selections)
- AdvancedSelect ‚Üí Select (may lose hierarchical context)
- Select ‚Üí Checkbox (only if binary true/false mapping possible)

#### Conditional Migrations
- RadioGroup with no empty option ‚Üí Select with empty option (changes data model)
- Checkbox group ‚Üí MultiSelect with exclusive options (logic change)

### Critical Implementation Procedures {comprehensive}

#### Procedure A: RadioGroup to Select Migration

1. **Export existing data**
   ```bash
   # Document all current RadioGroup selections
   ```

2. **Update JSON configuration**
   ```json
   // From:
   "component-name": "RadioGroup"
   // To:
   "component-name": "Select"
   ```

3. **Add empty option if needed**
   ```json
   {"label": "-- None selected --", "value": ""}
   ```

4. **Test validation display**
   - Verify error messages now appear
   - Check required field behavior

5. **Update user documentation**

#### Procedure B: Multiple Checkboxes to MultiSelect

1. **Map checkbox fields to options**
   ```json
   // Individual checkboxes become options
   {"label": "Option 1", "value": "opt1"}
   ```

2. **Configure display type**
   ```json
   "ElementProps": {
     "displayType": "expandedChecklist"
   }
   ```

3. **Migrate data**
   - Combine boolean values into array
   - Map true values to option values

4. **Add validation**
   ```json
   ["yup.min", 1, "Select at least one"]
   ```

### Migration Script Templates {comprehensive}

```javascript
// RadioGroup to Select Migration
function migrateRadioGroupToSelect(fieldConfig) {
  return {
    ...fieldConfig,
    "component-name": "Select",
    "component-parameters": {
      ...fieldConfig["component-parameters"],
      "ElementProps": {
        ...fieldConfig["component-parameters"]["ElementProps"],
        "options": [
          {"label": "-- Select --", "value": ""},
          ...fieldConfig["component-parameters"]["ElementProps"]["options"]
        ]
      }
    }
  };
}

// Multiple Checkboxes to MultiSelect
function migrateCheckboxesToMultiSelect(checkboxFields) {
  const options = checkboxFields.map(field => ({
    label: field["component-parameters"]["label"],
    value: field.name
  }));
  
  return {
    "component-namespace": "faims-custom",
    "component-name": "MultiSelect",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "ElementProps": { options }
    }
  };
}
```

### Training Requirements {important}

#### Basic Training (All Users)
- Difference between Select and MultiSelect
- How to deselect in Select (use empty option)
- Why RadioGroup shows no errors
- Checkbox label click limitation

#### Advanced Training (Data Managers)
- JSON configuration for options
- Validation schema setup
- Migration procedures
- Troubleshooting validation issues

### Alternative Approaches {comprehensive}

**Instead of RadioGroup:**
- Use Select with empty option
- Use button group (custom component)
- Use segmented control (custom)

**Instead of AdvancedSelect:**
- Cascading Selects
- Select with prefixed labels ("Parent > Child")
- Search field with filtered Select

**Instead of validation-less MultiSelect:**
- Multiple Checkboxes with validation
- Select with multiple conditional fields
- Custom component with error display

## Best Practices {comprehensive}

### Field-Specific Best Practices

**Checkbox:**
- Always use yup.oneOf([true]) for "must accept"
- Provide clear helperText for requirements
- Don't rely on label being clickable

**MultiSelect:**
- Always use yup.min(1) for required
- Consider expandedChecklist for <15 options
- Document that errors won't display
- Use exclusive options for "None" type selections

**RadioGroup (Deprecated):**
- Don't use in new forms
- Always provide migration path
- Include empty option for deselection

**Select:**
- Always include empty option for optional fields
- Use clear, descriptive labels
- Keep options under 50 for performance

**AdvancedSelect (Beta):**
- Avoid in production
- Document inability to clear
- Provide Select alternative
- Test thoroughly on all platforms

### Implementation Notes {comprehensive}

- Options arrays must be defined in JSON, not fetched dynamically
- All selection fields use the same option format: `{label, value}`
- Validation runs onChange but errors only display in some components
- Mobile platforms may have different selection UIs
- Export always uses the value, not the label

### Cross-References Between Fields {comprehensive}

- **Checkbox vs RadioGroup**: Use Checkbox for true/false, RadioGroup only for legacy
- **Select vs MultiSelect**: Data type is key difference (string vs array)
- **Select vs AdvancedSelect**: Use Select unless hierarchy is essential
- **MultiSelect vs Checkboxes**: Use MultiSelect for grouped options

## Field Quirks Index (2025-08) {comprehensive}

### Common Selection Field Quirks

**QUIRK**: All selection components require faims-custom namespace
**FIX**: Always use `"component-namespace": "faims-custom"`
**VERSION**: Since v3.0

**QUIRK**: Options cannot be dynamically loaded
**FIX**: Predefine all options in JSON
**WORKAROUND**: Use conditional logic to show/hide fields
**VERSION**: Current limitation

### Checkbox
- **QUIRK**: Label text not clickable (only checkbox itself)
- **FIX**: None - browser limitation
- **IMPACT**: Mobile usability issue
- **VERSION**: All versions

### MultiSelect
- **QUIRK**: Empty array passes required validation
- **FIX**: Use yup.min(1) validation
- **VERSION**: Since introduction

- **QUIRK**: No error message display
- **FIX**: None - component limitation
- **WORKAROUND**: Use helperText
- **VERSION**: Current

### RadioGroup
- **QUIRK**: Cannot deselect once selected
- **FIX**: Add empty option
- **VERSION**: All versions

- **QUIRK**: No error display capability
- **FIX**: Migrate to Select
- **VERSION**: Deprecated

### Select
- **QUIRK**: Label can overlap with selection
- **FIX**: Use proper label positioning
- **VERSION**: Material-UI related

### AdvancedSelect
- **QUIRK**: Cannot clear selection
- **FIX**: None - component bug
- **VERSION**: Beta

- **QUIRK**: Not configurable in Designer
- **FIX**: Manual JSON only
- **VERSION**: Current

### Performance Quirks
- **QUIRK**: >100 options slows form
- **FIX**: Limit to 50 options
- **APPLIES**: All selection fields

### Browser-Specific Quirks
- **iOS**: Select may show native picker
- **Android**: MultiSelect may show modal
- **Desktop**: Dropdown behavior varies

## Performance Thresholds Summary {essential}

See [Performance Thresholds Reference](performance-thresholds-reference.md) for detailed metrics.

**Quick Reference - Selection Field Limits**:
- Options with markdown: <20 (optimal), >50 (unusable)
- Options without markdown: <50 (optimal), >100 (unusable)  
- RadioGroup: Max 20 options (deprecated for larger lists)
- MultiSelect expanded: Max 15 options (mobile), 25 (desktop)
- AdvancedSelect: Max 50 nodes (beta, poor performance)

## JSON Patterns Cookbook (2025-08) {comprehensive}

### Common Selection Patterns

#### Binary Choice Pattern
```json
{
  "field-name": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "label": "Yes/No Question?"
    },
    "initialValue": false
  }
}
```

#### Single Selection with None Pattern
```json
{
  "field-name": {
    "component-namespace": "faims-custom",
    "component-name": "Select",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "ElementProps": {
        "options": [
          {"label": "-- None --", "value": ""},
          {"label": "Option 1", "value": "opt1"}
        ]
      }
    }
  }
}
```

#### Multiple Selection with Exclusive Pattern
```json
{
  "field-name": {
    "component-namespace": "faims-custom",
    "component-name": "MultiSelect",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "ElementProps": {
        "options": [
          {"label": "Option 1", "value": "opt1"},
          {"label": "None of the above", "value": "none", "exclusive": true}
        ]
      }
    }
  }
}
```

### Checkbox Patterns

#### Must Accept Pattern
```json
{
  "must-accept": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "validationSchema": [
      ["yup.bool"],
      ["yup.oneOf", [true], "Must be checked"]
    ]
  }
}
```

#### Optional Flag Pattern
```json
{
  "optional-flag": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "required": false
    }
  }
}
```

### MultiSelect Patterns

#### Expanded Checklist Pattern
```json
{
  "checklist": {
    "component-namespace": "faims-custom",
    "component-name": "MultiSelect",
    "component-parameters": {
      "ElementProps": {
        "displayType": "expandedChecklist",
        "options": [...]
      }
    }
  }
}
```

#### Required Multiple Pattern
```json
{
  "required-multi": {
    "component-namespace": "faims-custom",
    "component-name": "MultiSelect",
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "Select at least one"],
      ["yup.max", 5, "Select at most 5"]
    ]
  }
}
```

## JSON Anti-patterns Quick Index {comprehensive}

### Selection Field Anti-patterns

#### ‚ùå Wrong Namespace
```json
// WRONG
"component-namespace": "formik-material-ui"
// CORRECT
"component-namespace": "faims-custom"
```

#### ‚ùå Dynamic Options
```json
// WRONG - Cannot fetch dynamically
"ElementProps": {
  "optionsUrl": "/api/options"
}
// CORRECT - Predefine options
"ElementProps": {
  "options": [...]
}
```

#### ‚ùå Missing Empty Option
```json
// WRONG - No way to deselect
"options": [
  {"label": "Yes", "value": "yes"},
  {"label": "No", "value": "no"}
]
// CORRECT - Include empty
"options": [
  {"label": "-- Select --", "value": ""},
  {"label": "Yes", "value": "yes"},
  {"label": "No", "value": "no"}
]
```

#### ‚ùå Wrong Data Types
```json
// WRONG - MultiSelect with string
"component-name": "MultiSelect",
"initialValue": ""
// CORRECT - MultiSelect with array
"component-name": "MultiSelect",
"initialValue": []
```

## Quick Diagnosis Tables (2025-08) {important}

### Error Display Capability
| Component | Shows Errors | Workaround |
|-----------|--------------|------------|
| Checkbox | ‚úÖ Yes | None needed |
| MultiSelect | ‚ùå No | Use helperText |
| RadioGroup | ‚ùå No | Migrate to Select |
| Select | ‚úÖ Yes | None needed |
| AdvancedSelect | ‚ö†Ô∏è Partial | Check console |

### Mobile Compatibility
| Component | iOS | Android | Mobile Web |
|-----------|-----|---------|------------|
| Checkbox | ‚úÖ Good | ‚úÖ Good | ‚ö†Ô∏è Label issue |
| MultiSelect | ‚úÖ Good | ‚úÖ Good | ‚úÖ Good |
| RadioGroup | ‚úÖ Good | ‚úÖ Good | ‚úÖ Good |
| Select | ‚úÖ Native | ‚úÖ Native | ‚úÖ Good |
| AdvancedSelect | ‚ùå Poor | ‚ùå Poor | ‚ùå Poor |

### Deselection Capability
| Component | Can Clear | Method |
|-----------|-----------|--------|
| Checkbox | ‚úÖ Yes | Uncheck |
| MultiSelect | ‚úÖ Yes | Deselect all |
| RadioGroup | ‚ùå No | Add empty option |
| Select | ‚úÖ Yes | Select empty option |
| AdvancedSelect | ‚ùå No | Bug - cannot clear |

### Platform Support Matrix
| Platform | Best Choice | Avoid |
|----------|------------|-------|
| iOS | Select, Checkbox | AdvancedSelect |
| Android | Select, MultiSelect | AdvancedSelect |
| Desktop | All except deprecated | RadioGroup, AdvancedSelect |
| Mobile Web | Select, Checkbox | AdvancedSelect |

## Field Interaction Matrix (2025-08) {important}

| Field A | Field B | Interaction Type | Notes |
|---------|---------|------------------|-------|
| Checkbox | Select | Conditional display | Checkbox can show/hide Select |
| MultiSelect | MultiSelect | Exclusive options | One excludes others |
| Select | Select | Cascading | First determines second's options |
| RadioGroup | Any | Deprecated | Should not use |
| AdvancedSelect | Any | Isolation | Too complex for interactions |

### Conditional Patterns
- Checkbox controlling field visibility
- Select determining next Select options (static)
- MultiSelect exclusive options clearing others
- Required based on other field values

## Migration Warnings Index (2025-08) {comprehensive}

### Critical Migration Warnings

‚ö†Ô∏è **RadioGroup Deprecation**
- Timeline: Immediate migration recommended
- Risk: No error display, cannot deselect
- Action: Migrate to Select with empty option

‚ö†Ô∏è **AdvancedSelect Beta Status**
- Timeline: Not production ready
- Risk: Cannot clear, poor mobile support
- Action: Use Select with prefixes

‚ö†Ô∏è **MultiSelect Validation**
- Timeline: Check all existing forms
- Risk: Empty arrays passing required
- Action: Add yup.min(1) validation

### Migration Risk Matrix

| From | To | Risk Level | Data Loss | Complexity |
|------|----|------------|-----------|------------|
| RadioGroup | Select | üü¢ Low | None | Simple |
| Checkboxes | MultiSelect | üü° Medium | None | Moderate |
| AdvancedSelect | Select | üî¥ High | Hierarchy | Complex |
| MultiSelect | Select | üî¥ High | Multiple values | Complex |
| Text | Select | üü¢ Low | None | Simple |

## See Also {comprehensive}

- **Text Fields**: For open-ended responses or pattern-validated input
- **Number Fields**: For numeric ranges (use instead of Select with numbers)
- **DateTime Fields**: For temporal selections (not period taxonomies)
- **External Vocabularies**:
  - Getty AAT for controlled terminology
  - Periodo for archaeological/historical periods
  - Heritage Data for regional vocabularies
- **Reference Documents**:
  - [Component Namespace Reference](component-namespace-reference.md) - Namespace troubleshooting
  - [Meta Properties Reference](meta-properties-reference.md) - Annotation/uncertainty setup
  - [Data Export Reference](data-export-reference.md) - CSV array handling issues
  - [Accessibility Reference](accessibility-reference.md) - Touch target problems

---

## Error Message Quick Reference (2025-08) {important}

### Critical Errors (Form Breaking)
| Error | Component | Cause | Fix |
|-------|-----------|-------|-----|
| "Component not found" | All | Wrong namespace | Use faims-custom |
| "Cannot read property" | All | Malformed JSON | Validate JSON |
| "Invalid configuration" | All | Missing required | Check parameters |

### Validation Errors (User Visible - When Supported)
| Message | Component | Trigger | Resolution |
|---------|-----------|---------|------------|
| "Required field" | Checkbox, Select | Empty submission | Make selection |
| "Must accept terms" | Checkbox | false when required | Check the box |
| "Invalid selection" | Select | Value not in options | Select valid option |

### Silent Failures (No User Feedback)
| Issue | Component | Detection | Prevention |
|-------|-----------|-----------|------------|
| Empty array saved | MultiSelect | Check data | Add yup.min(1) |
| No validation shown | RadioGroup | Test submit | Use Select |
| Cannot clear | AdvancedSelect | User reports | Use Select |
| Label not clickable | Checkbox | User confusion | Training |

## Metadata {comprehensive}

### Component Status Summary
| Component | Status | Production Ready | Recommendation |
|-----------|--------|------------------|----------------|
| Checkbox | ‚úÖ Stable | Yes | Use for binary |
| MultiSelect | ‚ö†Ô∏è Limited | Yes with caveats | Add validation |
| RadioGroup | ‚úÖ Production | No | Migrate to Select |
| Select | ‚úÖ Stable | Yes | Preferred choice |
| AdvancedSelect | üî¥ Beta | No | Avoid |

### Documentation Coverage
- Designer usage: 80% (limited by Designer constraints)
- JSON configuration: 100%
- Troubleshooting: 100%
- Migration paths: 100%
- Platform specifics: 90%

### Quality Verification
- [ ] All examples tested
- [ ] Migration procedures verified
- [ ] Error messages documented
- [ ] Platform differences noted
- [ ] Performance thresholds validated

### Platform Versions
- FAIMS3: v3.0+
- Designer: Latest
- Mobile: iOS 14+, Android 10+
- Browsers: Chrome 90+, Safari 14+, Firefox 88+

### Known Limitations Documented
- ‚úÖ RadioGroup no error display
- ‚úÖ AdvancedSelect cannot clear
- ‚úÖ Checkbox label not clickable
- ‚úÖ MultiSelect validation issues
- ‚úÖ Dynamic options not supported

### Critical Warnings Highlighted
- ‚úÖ RadioGroup deprecated
- ‚úÖ AdvancedSelect beta
- ‚úÖ MultiSelect empty array validation
- ‚úÖ Component namespace requirements
- ‚úÖ Platform-specific behaviors

### Revision History
- 2025-08: Complete rewrite with v05 pattern
- 2025-08: Added LLM optimizations
- 2025-08: Enhanced troubleshooting
- 2025-08: Added migration procedures
- 2025-08: Platform-specific documentation- 2025-01: Added concatenation boundaries and navigation

---

## Related Documentation
<!-- concat:references -->

### Within Field Categories
- **Previous**: [Text Fields](./text-fields-v05.md) | [#text-input-fields](#text-input-fields)
- **Next**: [Date & Time Fields](./datetime-fields-v05.md) | [#datetime-fields](#datetime-fields)

### Cross-Field Patterns
- **Validation**: [Selection Validation](../detail-crossfield-docs/validation.md#selection-fields) | [#validation-patterns](#validation-patterns)
- **Conditional Logic**: [Dependent Selects](../detail-crossfield-docs/conditional-logic.md#selection-fields) | [#conditional-logic](#conditional-logic)
- **Best Practices**: [Choice Field Selection](../detail-crossfield-docs/field-selection-best-practices.md#selection-fields) | [#field-selection](#field-selection)

### Technical References
- **Designer Limitations**: [Selection Constraints](../reference-docs/designer-limitations-reference.md#selection-fields) | [#designer-limitations](#designer-limitations)
- **Performance**: [Option List Limits](../reference-docs/performance-thresholds-reference.md#selection-fields) | [#performance-thresholds](#performance-thresholds)
- **Accessibility**: [Keyboard Navigation](../reference-docs/accessibility-reference.md#selection-fields) | [#accessibility](#accessibility)

<!-- /concat:references -->
<!-- concat:boundary:end section="selection-fields" -->


<!-- concat:document:datetime-fields-v05 -->
<!-- concat:boundary:start section="datetime-fields" -->
<!-- concat:metadata
document_id: datetime-fields-v05
category: datetime
field_count: 4
designer_capable: ["DateTimeNow", "DateTimePicker", "DatePicker", "MonthPicker"]
json_only: ["compute_value", "custom_formats"]
last_updated: 2025-01-05
-->

# Date-Time Input Fields

## Document Navigation
<!-- concat:nav-mode:individual -->
[‚Üê Selection Fields](./select-choice-fields-v05.md) | **Date & Time Fields** | [Numeric Fields ‚Üí](./number-fields-v05.md)
<!-- concat:nav-mode:concatenated -->
<!-- When viewing in reference.md: [‚Üë Top](#fieldmark-v3-field-type-documentation-index) | [Numeric Fields ‚Üì](#number-fields) -->

## Overview {essential}

**Component Names**: `DateTimeNow`, `DateTimePicker`, `DatePicker`, `MonthPicker`  
## Component Name Mapping {essential}

| Designer UI Label | JSON component-name | Namespace | Code File | Description |
|------------------|-------------------|-----------|-----------|-------------|
| Date Time Now | DateTimeNow | Timestamp with timezone support |
| Date Time Picker | DateTimePicker | faims-custom | DateTimePicker.tsx | Date and time selection |
| Date Picker | DatePicker | faims-custom | DatePicker.tsx | Date-only selection |
| Month Picker | MonthPicker | faims-custom | MonthPicker.tsx | Month/year selection |

### Critical Naming Issues {important}
- **Auto-population confusion**: DateTimeNow can be configured to NOT auto-populate via checkbox
- **Picker variations**: All pickers look similar in Designer but have different behaviors
- **Format limitations**: Custom formats require JSON configuration
- **Timezone handling**: All dates stored in local time without timezone info

**Component Names**: `DateTimeNow`, `DateTimePicker`, `DatePicker`, `MonthPicker`  
**Namespace**: `faims-custom`  
**Type Returned**: Declared as faims-core::String or faims-core::String (actual storage is strings in various formats - see Storage Formats section)

The date and time field subsystem provides four interconnected components for temporal data capture in archaeological fieldwork. These fields serve predominantly administrative and observational metadata functions ‚Äî recording when data was collected, when specimens were photographed, or when excavations commenced. They explicitly do **not** address interpretive archaeological dating, which requires specialist vocabularies, uncertainty quantification, and period taxonomies better served by controlled choice fields or structured text inputs.

**Important**: For archaeological chronology, use established vocabularies like Periodo (periodo.github.io) with Select/RadioGroup fields rather than date fields. Date fields are for absolute calendar dates, not cultural periods or interpretive chronologies.

All four components share a fundamental dependency on HTML5 native input types (`datetime-local`, `date`, and `month`), creating significant platform variance in user interfaces whilst maintaining consistent data storage. This architectural decision prioritises platform-familiar interactions over cross-device consistency ‚Äî a pragmatic trade-off that reduces training burden at the cost of interface standardisation.

‚ö†Ô∏è **Critical Design Limitation**: These fields suffer from validation poverty, supporting only required/optional constraints without temporal range enforcement, cross-field validation, or format standardisation. Projects requiring sophisticated temporal constraints must implement post-collection validation or deploy alternative recording strategies.

### DESIGNER QUICK GUIDE
**For most projects, use DateTimeNow (DateTime with Now button in Designer)**:
- ‚úÖ Timestamps with timezone preservation
- ‚úÖ Auto-population capability  
- ‚úÖ Multi-site project safe
- ‚ùå Avoid DateTimePicker (timezone issues)

**Quick Selection**:
- **Data collection timestamps**: DateTimeNow with auto-population
- **Event dates without time**: DatePicker
- **Period recording (preventing false precision)**: MonthPicker
- **Never use**: DateTimePicker for multi-site projects

### CRITICAL NAMING DISAMBIGUATION
**‚ö†Ô∏è Designer names are confusing - actual components differ significantly**:

| Designer Label | Actual Component | Use When |
|---------------|-----------------|----------|
| "DateTime with Now button" | DateTimeNow | ‚úÖ **Default choice** - All timestamps |
| "DateTime" | DateTimePicker | ‚ùå **Avoid** - No timezone storage |
| "Date" | DatePicker | ‚úÖ Date-only recording |
| "Month" | MonthPicker | ‚úÖ Coarse temporal precision |

**Critical**: "DateTime" and "DateTime with Now button" are completely different components with different data storage, timezone handling, and use cases.

### Field Capabilities Summary
DateTime fields provide administrative and observational temporal metadata capture for fieldwork, supporting HTML5 native date/time interfaces with platform-specific rendering. These components explicitly serve absolute calendar dating needs rather than archaeological chronological interpretation, which requires specialist vocabularies and uncertainty quantification better addressed through controlled choice fields.

### Component Status Summary

| Component | Status | Critical Notes |
|-----------|--------|----------------|
| **DateTimeNow** | ‚úÖ Production Ready | Default choice for all timestamps |
| **DateTimePicker** | ‚ö†Ô∏è Discouraged | No timezone stored - timestamps ambiguous when devices/locations change |
| **DatePicker** | ‚úÖ Production Ready | Use when time irrelevant |
| **MonthPicker** | ‚úÖ Production Ready | Prevents false precision |

## Designer Usage Guide {essential}

### What to Select in Designer

**In Designer, select:**
- üìÖ **"DateTime with Now button"** ‚Üí Creates DateTimeNow (RECOMMENDED)
- ‚ö†Ô∏è **"DateTime"** ‚Üí Creates DateTimePicker (Discouraged - lacks timezone, use DateTimeNow instead)
- üìÜ **"Date"** ‚Üí Creates DatePicker for date-only
- üìã **"Month"** ‚Üí Creates MonthPicker for month-year

### When JSON Enhancement is Required

**Fields require JSON editing for:**
- Platform-specific configurations
- Timezone documentation
- Full width display
- Complex validation beyond required/optional

### Designer Limitations {important}
See [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md) for testing, validation, and configuration constraints that apply to all fields.

**DateTime Field-Specific Limitations**:
- No timezone selection interface
- Limited validation options (required/optional only)
- No cross-field temporal validation
- Platform-specific interface rendering cannot be customized

## Field Selection Guide {essential}

### Decision Tree

```
Recording temporal data?
‚îÇ
‚îú‚îÄ Is it a cultural/archaeological period?
‚îÇ  ‚îî‚îÄ YES ‚Üí Use Select/RadioGroup with Periodo vocabulary (NOT date fields)
‚îÇ
‚îú‚îÄ Is it ancient history with BCE/CE dates?
‚îÇ  ‚îî‚îÄ YES ‚Üí Use NumberInput patterns (NOT date fields)
‚îÇ     ‚îî‚îÄ See Alternative Approaches > Ancient History Date Pattern
‚îÇ
‚îî‚îÄ Is it a calendar date/time?
‚îÇ
‚îú‚îÄ Do you need exact time (hours/minutes)?
‚îÇ  ‚îú‚îÄ YES ‚Üí DateTimeNow
‚îÇ  ‚îÇ  ‚îú‚îÄ Returns: faims-core::String (ISO 8601 UTC)
‚îÇ  ‚îÇ  ‚îî‚îÄ Best for: Timestamps, multi-site projects
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue...
‚îÇ
‚îú‚îÄ Is this a multi-site project across timezones?
‚îÇ  ‚îú‚îÄ YES ‚Üí DateTimeNow
‚îÇ  ‚îÇ  ‚îú‚îÄ Prevents timezone corruption
‚îÇ  ‚îÇ  ‚îî‚îÄ Stores UTC with timezone preserved
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue...
‚îÇ
‚îú‚îÄ Do you know the specific day?
‚îÇ  ‚îú‚îÄ YES ‚Üí DatePicker
‚îÇ  ‚îÇ  ‚îú‚îÄ Returns: faims-core::String (YYYY-MM-DD)
‚îÇ  ‚îÇ  ‚îî‚îÄ Best for: Administrative dates
‚îÇ  ‚îî‚îÄ NO ‚Üí MonthPicker
‚îÇ     ‚îú‚îÄ Returns: faims-core::String (YYYY-MM)
‚îÇ     ‚îî‚îÄ Avoids false precision
‚îÇ
‚îî‚îÄ Working in single timezone with no travel?
   ‚îú‚îÄ Maybe ‚Üí DateTimePicker
   ‚îÇ  ‚îú‚îÄ Returns: faims-core::String (local datetime)
   ‚îÇ  ‚îî‚îÄ ‚ö†Ô∏è Timezone ambiguity risk
   ‚îî‚îÄ NO ‚Üí DateTimeNow (always safer choice)
```

### Decision Matrix

| Field Type | Storage Format | Timezone Handling | Synchronisation Safety | When to Use |
|------------|---------------|-------------------|------------------------|-----------|
| **DateTimeNow** | ISO 8601 with timezone | ‚úÖ Preserved (UTC) | ‚úÖ Excellent | Default choice for all timestamps |
| **DateTimePicker** | Local string, no timezone | ‚ùå Ambiguous | ‚ö†Ô∏è Risky | Single-timezone projects only |
| **DatePicker** | Date-only string | N/A | ‚úÖ Good | Administrative dates without time |
| **MonthPicker** | Month string (YYYY-MM) | N/A | ‚úÖ Good | Historical sources, avoiding false precision |

### Selection Strategy

1. **Default to DateTimeNow** for all datetime fields unless specific reasons exist otherwise
2. **Use DatePicker** only when time components genuinely irrelevant
3. **Deploy MonthPicker** for month-year precision to avoid spurious accuracy
4. **Consider DateTimePicker** only for single-location projects with no device travel
5. **Avoid date fields entirely** for cultural periods or ancient history

## ‚ö†Ô∏è Critical Security Risks {essential}

**Timezone Data Corruption with DateTimePicker**:
- **Risk**: Same timestamp means different absolute times in different locations
- **Impact**: Multi-site data synchronization failures, incorrect event ordering
- **Mitigation**: NEVER use DateTimePicker for multi-location projects
- **Safe Alternative**: Always use DateTimeNow (stores UTC with timezone)

**Audit Trail Vulnerabilities**:
- **Risk**: User-editable timestamps even with `is_auto_pick`
- **Impact**: Forensic timeline corruption, backdating capability
- **Mitigation**: Pair with read-only TemplatedString for display
- **Validation**: Server-side timestamp verification required

**Format Assumption Risks**:
- **Risk**: MM/DD vs DD/MM interpretation varies by locale
- **Impact**: Date corruption, especially for days 1-12
- **Mitigation**: Always use YYYY-MM-DD format, picker interface only
- **Training**: Document expected format in helperText

---

## What These Fields Cannot Do {important}

### Time Processing Limitations {important}
- **Timezone conversion** - No automatic timezone conversion between locations
- **Recurring events** - No support for repeating date patterns
- **Duration calculation** - Cannot calculate time between dates automatically
- **Working days** - No business day calculations
- **Relative dates** - Cannot express "3 days from now" or "last Tuesday"

### Validation Limitations {important}
- **Cross-field validation** - Cannot enforce date ranges across fields
- **Future/past restrictions** - No dynamic "must be future date" validation
- **Age calculations** - Cannot validate minimum age requirements
- **Holiday detection** - No awareness of public holidays or weekends
- **Leap year validation** - Limited to browser implementation

### Display Limitations {important}
- **Custom formats** - Cannot change date display format per locale
- **Calendar systems** - No support for non-Gregorian calendars
- **Partial dates** - Cannot represent uncertainty (e.g., "circa 1850")
- **Date ranges** - No native support for start-end date pairs
- **Natural language** - Cannot parse "next Monday" or "Q3 2024"

## Common Use Cases {important}

### Timestamp Recording
- **Creation timestamps** ‚Üí DateTimeNow with `is_auto_pick: true`
- **Modification tracking** ‚Üí DateTimeNow (manual update)
- **Event timing** ‚Üí DateTimeNow with "Now" button
- **Sample collection** ‚Üí DateTimeNow (preserves timezone)

### Date-Only Recording
- **Birth dates** ‚Üí DatePicker (time irrelevant)
- **Artifact dates** ‚Üí DatePicker with certainty selector
- **Publication dates** ‚Üí DatePicker or MonthPicker
- **Historical events** ‚Üí DatePicker with approximate flag

### Period Recording
- **Excavation seasons** ‚Üí MonthPicker (avoids false precision)
- **Quarterly reports** ‚Üí MonthPicker with helper text
- **Academic years** ‚Üí Two DatePickers (start/end)
- **Project phases** ‚Üí MonthPicker for month-level granularity

### Data Quality Patterns
- **Immutable timestamps** ‚Üí DateTimeNow with `is_auto_pick` + read-only display
- **Timezone consistency** ‚Üí Always use DateTimeNow for multi-site projects
- **Excel-safe dates** ‚Üí DatePicker with import instructions
- **Approximate dates** ‚Üí DatePicker + certainty dropdown

---

---
### Decision Tree

```
Recording temporal data?
‚îÇ
‚îú‚îÄ Is it a cultural/archaeological period?
‚îÇ  ‚îî‚îÄ YES ‚Üí Use Select/RadioGroup with Periodo vocabulary (NOT date fields)
‚îÇ
‚îú‚îÄ Is it ancient history with BCE/CE dates?
‚îÇ  ‚îî‚îÄ YES ‚Üí Use NumberInput patterns (NOT date fields)
‚îÇ     ‚îî‚îÄ See Alternative Approaches > Ancient History Date Pattern
‚îÇ
‚îî‚îÄ Is it a calendar date/time?
‚îÇ
‚îú‚îÄ Do you need exact time (hours/minutes)?
‚îÇ  ‚îú‚îÄ YES ‚Üí DateTimeNow
‚îÇ  ‚îÇ  ‚îú‚îÄ Returns: faims-core::String (ISO 8601 UTC)
‚îÇ  ‚îÇ  ‚îî‚îÄ Best for: Timestamps, multi-site projects
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue...
‚îÇ
‚îú‚îÄ Is this a multi-site project across timezones?
‚îÇ  ‚îú‚îÄ YES ‚Üí DateTimeNow
‚îÇ  ‚îÇ  ‚îú‚îÄ Prevents timezone corruption
‚îÇ  ‚îÇ  ‚îî‚îÄ Stores UTC with timezone preserved
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue...
‚îÇ
‚îú‚îÄ Do you know the specific day?
‚îÇ  ‚îú‚îÄ YES ‚Üí DatePicker
‚îÇ  ‚îÇ  ‚îú‚îÄ Returns: faims-core::String (YYYY-MM-DD)
‚îÇ  ‚îÇ  ‚îî‚îÄ Best for: Administrative dates
‚îÇ  ‚îî‚îÄ NO ‚Üí MonthPicker
‚îÇ     ‚îú‚îÄ Returns: faims-core::String (YYYY-MM)
‚îÇ     ‚îî‚îÄ Avoids false precision
‚îÇ
‚îî‚îÄ Working in single timezone with no travel?
   ‚îú‚îÄ Maybe ‚Üí DateTimePicker
   ‚îÇ  ‚îú‚îÄ Returns: faims-core::String (local datetime)
   ‚îÇ  ‚îî‚îÄ ‚ö†Ô∏è Timezone ambiguity risk
   ‚îî‚îÄ NO ‚Üí DateTimeNow (always safer choice)
```

### Decision Matrix

| Field Type | Storage Format | Timezone Handling | Synchronisation Safety | When to Use |
|------------|---------------|-------------------|------------------------|-------------|
| **DateTimeNow** | ISO 8601 with timezone | ‚úÖ Preserved (UTC) | ‚úÖ Excellent | Default choice for all timestamps |
| **DateTimePicker** | Local string, no timezone | ‚ùå Ambiguous | ‚ö†Ô∏è Risky | Single-timezone projects only |
| **DatePicker** | Date-only string | N/A | ‚úÖ Good | Administrative dates without time |
| **MonthPicker** | Month string (YYYY-MM) | N/A | ‚úÖ Good | Historical sources, avoiding false precision |

### Selection Strategy

1. **Default to DateTimeNow** for all datetime fields unless specific reasons exist otherwise
2. **Use DatePicker** only when time components genuinely irrelevant
3. **Deploy MonthPicker** for month-year precision to avoid spurious accuracy
4. **Consider DateTimePicker** only for single-location projects with no device travel
5. **Avoid date fields entirely** for cultural periods or ancient history

**Platform Considerations**:
- iOS: Native date picker, excellent UX
- Android: Varies by device/version, generally good
- Desktop: Browser HTML5 pickers, inconsistent
- All platforms: "Now" button location varies

**Accessibility Requirements**:
- Native pickers generally meet WCAG touch targets
- Format expectations unclear without helperText
- Platform variance confuses users switching devices
- Screen readers may miss "Now" button

## Designer Component Mapping {essential}

### Designer UI vs JSON Component Names

| Designer UI Label | JSON component-name | Component Namespace | Description |
|------------------|--------------------|--------------------|-------------|
| "DateTime with Now button" | DateTimeNow | faims-custom | Full datetime with timezone and Now button |
| "DateTime" | DateTimePicker | faims-custom | Local datetime without timezone ‚ö†Ô∏è Discouraged |
| "Date" | DatePicker | faims-custom | Date-only field |
| "Month" | MonthPicker | faims-custom | Month-year field |

### Designer Configuration Options

| Designer Option | JSON Parameter | Values | Description |
|----------------|----------------|---------|-------------|
| Required | `required` | true/false | Field validation requirement |
| Label | `label` | string | Display name for field |
| Helper Text | `helperText` | string | Instructional text below field |
| Placeholder | Not supported | N/A | Date fields use native browser placeholders |

‚ö†Ô∏è **Critical Notes**:
- Designer "DateTime" creates DateTimePicker (timezone issues) - prefer "DateTime with Now button"
- Auto-population (`is_auto_pick`) requires JSON editing for all datetime fields
- Platform-specific date picker interfaces cannot be customized through Designer
- Validation beyond required/optional needs custom implementation

## Designer Capabilities vs JSON Enhancement {essential}

### What Designer Can Configure

For complete meta properties documentation (annotation, uncertainty, persistence), see [Meta Properties Reference](meta-properties-reference.md).

The Designer interface provides basic field creation for all date/time fields:

| Field Type | Designer Creates | Designer Configures | JSON-Only Features |
|------------|------------------|---------------------|-------------------|
| **DateTimeNow** | ‚úÖ Basic field | Label, Required, Helper text | `is_auto_pick`, timezone documentation, fullWidth |
| **DateTimePicker** | ‚úÖ Basic field | Label, Required, Helper text | ‚ö†Ô∏è Document timezone assumptions explicitly |
| **DatePicker** | ‚úÖ Basic field | Label, Required, Helper text | Format specifications, variant styles |
| **MonthPicker** | ‚úÖ Basic field | Label, Required, Helper text | Platform-specific configurations |

### When JSON Enhancement is Required

You MUST edit JSON directly for:

1. **Platform-specific optimizations** (iOS spacing, Android touch targets)
2. **Timezone documentation** (critical for DateTimePicker migration)
3. **Complex validation patterns** (though limited for date fields)
4. **Integration patterns** (paired fields, range validation)

### Designer Limitations

See [Designer Limitations Reference](designer-limitations-reference.md) for testing, validation, and configuration constraints that apply to all fields.

**DateTime Field-Specific Limitations**:
- Cannot set platform-specific display formats
- Cannot create conditional date ranges or date sequence validation
- Cannot configure timezone handling preferences

## Component Namespace Errors {important}

See [Component Namespace Reference](component-namespace-reference.md) for complete namespace documentation, error troubleshooting, and Designer name mapping.

### DateTime Field-Specific Notes

**All datetime fields use the same namespace**:
- Namespace: `faims-custom` for ALL datetime components
- Never use `formik-material-ui` for datetime fields

**Quick Reference for DateTime Fields**:
| Component | Namespace | Designer Name | Notes |
|-----------|-----------|---------------|-------|
| DateTime | `faims-custom` | Date and Time | Standard picker |
| DateTimeNow | `faims-custom` | DateTime with Now button | Has capture button |

**Common confusion**:
- Designer shows descriptive names, JSON needs exact component names
- All datetime components are in `faims-custom`, despite using MUI pickers internally

All date/time components are registered in the "faims-custom" namespace in the component registry (`bundle_components.ts`). There are no date/time components in other namespaces, making namespace errors particularly common when developers assume standard Material-UI patterns.


## When to Use These Fields {essential}
### Timezone Handling {important}
- **DateTimeNow**: RECOMMENDED - Properly handles timezones
- **DateTimePicker**: Stores local time without timezone (use DateTimeNow when timezone matters)
- The "now" button in DateTimeNow is optional - field works fine for manual entry too


### Field Selection Matrix

| Use Case | Recommended Field | Why |
|----------|------------------|-----|
| Timestamps/Audit trails | DateTimeNow | Auto-populated |
| Event scheduling | DateTimePicker | Full date+time |
| Dates only (no time) | DatePicker | Cleaner for date-only |
| Month/Year selection | MonthPicker | Period selection |

### Decision Criteria
- **Auto-population**: Required ‚Üí DateTimeNow, Manual ‚Üí Pickers
- **Time component**: Needed ‚Üí DateTimePicker, Not needed ‚Üí DatePicker
- **Granularity**: Day ‚Üí DatePicker, Month ‚Üí MonthPicker, Minute ‚Üí DateTimePicker
- **User editing**: Never ‚Üí DateTimeNow, Sometimes ‚Üí Pickers

## Common Characteristics {important}

### Configuration Rules {important}

#### Required Properties
All date/time fields require:
- `component-namespace`: Always `"faims-custom"`
- `component-name`: One of `DateTimeNow`, `DateTimePicker`, `DatePicker`, `MonthPicker`
- `type-returned`: Typically `"faims-core::String"` or `"faims-core::String"` (though all store strings)
- `component-parameters.name`: Must match the field ID exactly
- `initialValue`: Must be empty string `""` (not null) to prevent errors

#### Auto-population (DateTimeNow only)
```json
"component-parameters": {
  "is_auto_pick": true  // Automatically fills with current time on form open
}
```

#### Common Configuration Patterns
```json
{
  "component-namespace": "faims-custom",
  "component-name": "DateTimeNow",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "timestamp-field",
    "label": "Record Timestamp",
    "helperText": "Automatically captured (UTC)",
    "fullWidth": true,
    "required": false
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""
}
```

### Validation Patterns {important}
See [Validation System Documentation](../detail-crossfield-docs/validation.md) for comprehensive validation patterns and timing.

**DateTime Field-Specific Validation:**
- **Validation poverty**: Only `required` validation available
- **No date range validation**: Cannot enforce min/max dates
- **No cross-field validation**: Cannot validate end > start dates
- **String type only**: All dates validated as strings, not Date objects
- **Complex parsing**: Every change attempts ISO 8601 date parsing
- **Picker bypass**: Native date/time pickers may skip change events
- **Manual entry validation**: Validates partial dates during typing (causes confusion)
- **Format attempts**: Tries multiple date formats on each change

#### Missing Validation Capabilities
- **No temporal range validation**: Cannot enforce min/max dates
- **No cross-field validation**: Cannot ensure end date after start date
- **No format validation**: Cannot enforce specific date formats
- **No future/past constraints**: Cannot prevent future or past dates
- **No BCE date support**: Cannot handle dates before year 0

#### Workaround Patterns
```javascript
// Post-collection validation example
const validateDates = (record) => {
  const errors = [];
  
  // Check future dates
  if (new Date(record.excavation_date) > new Date()) {
    errors.push("Excavation date cannot be in future");
  }
  
  // Check date relationships
  if (record.end_date && record.start_date) {
    if (new Date(record.end_date) < new Date(record.start_date)) {
      errors.push("End date must be after start date");
    }
  }
  
  return errors;
};
```

### Security Considerations {important}

See [Security Considerations Reference](security-considerations-reference.md) for comprehensive security guidelines and validation requirements.

**DateTime Field-Specific Security Issues**:
- **Timezone disclosure**: DateTimeNow exposes user location via timezone
- **Validation poverty**: No server-side date validation possible
- **Format injection**: String storage allows malformed dates
- **Audit compromise**: User-editable timestamps break forensic trails
- **DateTimePicker**: Timezone loss causes silent data corruption

### Performance Boundaries {important}

#### Processing Limits
- **Maximum reliable date range**: 1900-2100 (browser-dependent)
- **Timezone conversion latency**: DateTimeNow adds ~100ms per record (empirical observation)
- **Picker rendering time**: 100-300ms depending on platform
- **Maximum fields per form**: ~100 before performance degradation (browser-dependent)
- **Form rendering**: ~50ms per date field on modern devices
- **Validation check**: <5ms per field
- **Date picker opening**: 100-300ms depending on platform

#### Storage Characteristics

**Note**: Storage sizes below are empirical observations and may vary by implementation.
- **DateTimeNow**: ~30 bytes per timestamp (ISO 8601 with timezone)
- **DateTimePicker**: ~20 bytes (local string without timezone) - but dangerous
- **DatePicker**: ~10 bytes (YYYY-MM-DD string)
- **MonthPicker**: ~7 bytes (YYYY-MM string)
- **PouchDB storage overhead**: ~3x raw size with indexes
- **Browser memory per field**: ~2MB including picker resources
- **Picker animation memory**: Additional 5-10MB when active

#### Large Dataset Considerations
- **Record processing**: DateTimeNow adds ~100ms per record for timezone conversion
- **Bulk operations**: Process in batches of 100 to avoid UI freezing
- **CSV exports**: Split at 65,000 rows for Excel compatibility
- **Browser memory limits**: Varies by device, typically exhausted at ~100 date fields
- **Sync operations**: Date fields add 15-20% to sync payload size
- **Indexing impact**: Each date field adds ~500ms to initial database indexing (empirical observation)

#### Storage Optimization Strategies
```javascript
// Calculate storage requirements
const estimateStorage = (recordCount, dateFields) => {
  const bytesPerField = {
    DateTimeNow: 30,
    DateTimePicker: 20,  // Don't use!
    DatePicker: 10,
    MonthPicker: 7
  };
  
  const baseStorage = recordCount * dateFields * bytesPerField.DateTimeNow;
  const pouchOverhead = baseStorage * 3;  // Indexes and metadata
  const totalMB = (baseStorage + pouchOverhead) / 1048576;
  
  return {
    baseStorage: `${(baseStorage / 1024).toFixed(2)} KB`,
    withOverhead: `${(pouchOverhead / 1024).toFixed(2)} KB`, 
    totalMB: `${totalMB.toFixed(2)} MB`,
    recommendation: totalMB > 100 ? 'Consider archiving old records' : 'Within limits'
  };
};
```

#### Performance Optimization Techniques
See [Performance Thresholds Reference](performance-thresholds-reference.md#performance-optimization-triggers) for optimization guidelines.

Key optimizations for date fields:
1. **Paginate forms** with >20 date fields per page
2. **Use MonthPicker** when possible (smallest storage footprint)
3. **Batch process** timezone conversions in background
6. **Avoid** TemplatedString references to date fields (causes re-renders)
7. **Disable** auto-populate during bulk imports

#### Export Limitations
- **CSV row limit**: 65,000 before Excel compatibility issues
- **Date format preservation**: Excel auto-converts dates on open
- **Timezone information**: Lost in some export formats
- **JSON export size**: ~150 bytes per date field including metadata
- **Shapefile date fields**: Limited to date-only format (time components lost)

### Platform Behaviors {important}

#### Interface Variations by Platform

**Note**: Platform interface descriptions below are based on native browser implementations and may vary by browser version and device settings.

| Platform | DatePicker | DateTimeNow | MonthPicker | DateTimePicker |
|----------|------------|-------------|-------------|----------------|
| iOS Safari | Drum wheels | Drum wheels | Month wheel | Combined wheels |
| Android Chrome | Calendar popup | DateTime picker | Month spinner | DateTime wheels |
| Desktop Chrome | Calendar grid | Calendar + time | Month dropdown | Calendar + time |
| Desktop Firefox | Text or calendar | Text or calendar | Month list | Text input |

#### Known Platform Issues
- **iOS**: Wheels may cover form context, no keyboard entry option
- **Android**: Format varies by device locale settings
- **Desktop Chrome**: Manual typing often causes format errors
- **Desktop Firefox**: Most flexible but parsing inconsistencies

### Accessibility Compliance {important}

See [Accessibility Reference](accessibility-reference.md) for comprehensive WCAG compliance status, touch target requirements, and screen reader support.

**DateTime Field-Specific Issues**:
- Platform variance confuses users switching between devices  
- "Now" button location varies, may be missed by screen readers
- Format expectations unclear without helperText
- UTC display notation may confuse users
- Native pickers generally meet touch target requirements

### Export Behavior {important}

See [Data Export Reference](data-export-reference.md) for comprehensive export documentation including CSV/JSON formats, special character handling, and Excel issues.

**DateTime Field-Specific Export Notes**:
- **DateTimeNow**: ISO 8601 with timezone (e.g., `2024-03-15T14:30:00.000Z`)
- **DateTimePicker**: Local datetime without timezone (e.g., `2024-03-15T14:30`)
- **DatePicker**: Date only (e.g., `2024-03-15`)
- **MonthPicker**: Month string (e.g., `2024-03`) - Excel misinterprets as "3rd March 2024"
- **Excel corruption**: All date formats auto-convert on double-click open - use Text Import Wizard
- **Regional issues**: DD/MM vs MM/DD confusion causes data corruption
- **Shapefile export**: Truncates to date-only, loses time and timezone


### Understanding DateTimeNow - Not Just for "Now" {essential}

Despite its name, **DateTimeNow is a full datetime picker** that happens to have an optional "Now" button:
- ‚úÖ Use it as a regular datetime picker (ignore the "Now" button)
- ‚úÖ Stores timezone information (UTC) preventing ambiguity
- ‚úÖ Works perfectly for past/future dates
- ‚úÖ The "Now" button is just a convenience feature

**Common Misconception**: "I need to record a past date, so I cannot use DateTimeNow"
**Reality**: DateTimeNow is for ALL datetime needs, not just current timestamps

## Field Reference {essential}

### DateTimeNow (DateTime with Now button in Designer) {essential}
<!-- keywords: timestamp, timezone, UTC, auto-populate, current -->

#### Purpose {essential}
Timezone-aware timestamp capture with automatic current time option. Stores timestamps in ISO 8601 format with UTC timezone preservation, making it the safest choice for multi-site projects and data synchronisation.

**Storage Format**: ISO 8601 with timezone (e.g., `2024-03-15T14:30:00.000Z`)  
**Best For**: Record creation times, synchronised timestamps, audit trails

#### Key Features {essential}
- ‚úÖ **Timezone preservation** via UTC storage
- ‚úÖ **"Now" button** for quick current time capture
- ‚úÖ **Auto-populate option** via `is_auto_pick: true`
- ‚úÖ **Accepts arbitrary dates** despite name suggesting contemporary only

#### Configuration Parameters {important}
**Designer creates basic field** with label, required, and helper text. JSON enhancement needed for:
- `is_auto_pick: true` for automatic timestamp capture
- `fullWidth`, `margin`, and spacing parameters
- Platform-specific optimizations

```json
{
  "component-parameters": {
    "label": "Record Created",
    "name": "record_created",
    "is_auto_pick": true,  // Auto-fills with current time (JSON-only)
    "helperText": "Automatically captured when record opened",
    "fullWidth": true,      // JSON-only
    "required": false
  }
}
```

#### Field-Specific Troubleshooting {important}

| Issue | Symptom | Cause | Solution |
|-------|---------|-------|----------|
| UTC confusion | Users report "wrong time" | Showing UTC not local | Add helperText explaining UTC storage |
| Missing "Now" button | Can't find quick entry | Platform variance | Train on platform-specific location |
| Auto-pick editable | Creation time changed | User can modify | Use paired display pattern |
| Invalid Date | Field shows error | Locale parsing issue | Use picker not keyboard |
| Historical dates | Need to enter 1850s date | Name implies current only | Add helperText that any date accepted |

#### Implementation Examples {comprehensive}

**Auto-populated Creation Timestamp**
```json
{
  "record_created": {
    "component-namespace": "faims-custom",
    "component-name": "DateTimeNow",
    "component-parameters": {
      "name": "record_created",
      "label": "Record Created",
      "is_auto_pick": true,
      "helperText": "Automatically captured (UTC)",
      "disabled": false
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Creation time required"]
    ],
    "initialValue": ""
  }
}
```

**Manual Timestamp with Annotation**
```json
{
  "observation_time": {
    "component-namespace": "faims-custom",
    "component-name": "DateTimeNow",
    "component-parameters": {
      "name": "observation_time",
      "label": "Observation Time",
      "is_auto_pick": false,
      "helperText": "Click 'Now' or select specific time"
    },
    "meta": {
      "annotation": {
        "include": true,
        "label": "Time notes"
      }
    }
  }
}
```


#### JSON Anti-patterns

‚ùå **NEVER: Wrong namespace (faims3 doesn't exist)**
```json
{
  "component-name": "DateTimeNow",
  "component-namespace": "faims3"  // ERROR: Wrong namespace - no faims3
}
```
‚úÖ **ALWAYS: Use faims-custom namespace**
```json
{
  "component-name": "DateTimeNow",
  "component-namespace": "faims-custom"  // Correct namespace
}
```

‚ùå **NEVER: Invalid timezone**
```json
{
  "meta": {
    "timezone": "Sydney"  // ERROR: Not a valid IANA timezone
  }
}
```
‚úÖ **ALWAYS: Use IANA timezone identifiers**
```json
{
  "meta": {
    "timezone": "Australia/Sydney"  // Correct IANA format
  }
}
```

#### Common Spec Mappings
- "Record timestamp" ‚Üí DateTimeNow with auto-populate
- "Event date and time" ‚Üí DateTimeNow with timezone
- "Observation datetime" ‚Üí DateTimeNow with helperText
- "Sample collection time" ‚Üí DateTimeNow, usually required

### DateTimePicker (DateTime in Designer - DISCOURAGED) {essential}
<!-- keywords: datetime, local, legacy, discouraged, problematic -->


#### JSON Anti-patterns

‚ö†Ô∏è **WARNING: This component is discouraged - use DateTimeNow instead**

‚ùå **NEVER: Using DateTimePicker for new forms**
```json
{
  "component-name": "DateTimePicker"  // DISCOURAGED
}
```
‚úÖ **ALWAYS: Use DateTimeNow for timezone support**
```json
{
  "component-name": "DateTimeNow",
  "component-namespace": "faims-custom"
}
```

‚ùå **NEVER: Expecting timezone handling**
```json
{
  "component-name": "DateTimePicker",
  "meta": {
    "timezone": "UTC"  // IGNORED - No timezone support
  }
}
```

#### Common Spec Mappings
‚ö†Ô∏è **DISCOURAGED - Use DateTimeNow instead**
- Migration only - not for new forms
- Convert to DateTimeNow when updating

**‚ö†Ô∏è DISCOURAGED - Use DateTimeNow instead unless single-timezone project**

#### Purpose {essential}
Legacy datetime field that stores timestamps without timezone information, causing data corruption in multi-site projects. Originally designed for single-location deployments, it becomes problematic when teams span timezones as the same timestamp represents different absolute times in different locations.

**Storage Format**: Local datetime string (e.g., `2024-03-15T14:30`)  
**Problems**: Timezone ambiguity, synchronisation failures, data interpretation issues

#### Why Discouraged {essential}
- ‚ùå **No timezone information** stored
- ‚ùå **Synchronisation failures** across sites
- ‚ùå **Data corruption** when teams span timezones
- ‚ùå **Ambiguous timestamps** (14:30 in Sydney ‚â† 14:30 in Perth)

### ‚ö†Ô∏è DateTimePicker Usage Warning {essential}

**This field is RECOMMENDED for proper timezone handling**. Understanding when it might be acceptable:

#### Acceptable Use Cases (Rare)
- Single-site project with no travel
- All devices remain in same timezone
- No international collaboration
- Historical data migration where timezone is unknown

#### Why DateTimeNow is Usually Better
- Prevents "2pm Sydney = 2pm London" confusion
- Survives device timezone changes
- Enables accurate cross-site synchronization
- Future-proofs your data for collaboration

#### If You Must Use DateTimePicker
**Document these assumptions**:
```json
"helperText": "Time recorded in Sydney timezone (UTC+10/+11)",
"meta": {
  "annotation": {
    "include": true,
    "label": "Timezone context (if device was elsewhere)"
  }
}
```

#### Common Scenario: Fieldwork Travel
Team based in Sydney conducting fieldwork in Greece:
- Devices may still show Sydney time
- DateTimePicker would record ambiguous "14:30"
- Is that Sydney time or Athens time?
- DateTimeNow removes this ambiguity


#### Field-Specific Troubleshooting {important}

| Issue | Symptom | Cause | Solution |
|-------|---------|-------|----------|
| Timezone corruption | Times off by hours | No TZ stored | Migrate to DateTimeNow |
| Sync conflicts | Different times shown | TZ ambiguity | Document assumed timezone |
| String comparison | Date ranges fail | String not date compare | Post-process validation |

#### Migration Requirements {important}
**Designer creates this disrecommended field** but discouraged for new projects due to timezone ambiguity. JSON enhancement critical for documenting assumed timezone before migration.

1. Export existing data with documented timezone assumptions
2. Convert strings to ISO 8601 with explicit timezone
3. Update configuration to use DateTimeNow
4. Retrain users on new interface

### DatePicker (Date in Designer) {essential}
<!-- keywords: date, day, calendar, date-only, administrative -->

#### Purpose {essential}
Date-only selection for administrative and observational records where time components would constitute false precision. Ideal for recording excavation dates, permit expiry, or any temporal data where the specific time of day is genuinely irrelevant or unknown.

**Storage Format**: YYYY-MM-DD string (e.g., `2024-03-15`)  
**Best For**: Permits, deadlines, excavation dates, administrative records

#### Key Features {essential}
- ‚úÖ **No timezone complications** - date only
- ‚úÖ **Consistent storage format** across platforms
- ‚úÖ **Simplified interface** compared to datetime fields

#### Configuration Parameters {important}
**Designer creates basic field** with label, required, and helper text. JSON enhancement needed for fullWidth, variant styles, and platform-specific configurations.

```json
{
  "component-parameters": {
    "label": "Excavation Date",
    "name": "excavation_date",
    "helperText": "Date work commenced",
    "required": true
  }
}
```

#### Field-Specific Troubleshooting {important}

| Issue | Symptom | Cause | Solution |
|-------|---------|-------|----------|
| Excel corruption | Dates change format | Auto-conversion | Import as text column |
| Forced precision | Must pick day | No partial dates | Use MonthPicker if appropriate |
| iOS full-screen | Can't see form | Platform UI | Train users to expect this |
| Manual entry fails | Invalid date error | Format confusion | Use picker interface |
| Need timestamp too | Date-only field | Add DateTimeNow field |


#### JSON Anti-patterns

‚ùå **NEVER: Wrong date format in initialValue**
```json
{
  "initialValue": "15/03/2024"  // ERROR: Invalid format
}
```
‚úÖ **ALWAYS: Use ISO 8601 format**
```json
{
  "initialValue": "2024-03-15"  // YYYY-MM-DD format
}
```

‚ùå **NEVER: Including time in date-only field**
```json
{
  "initialValue": "2024-03-15T10:30:00Z"  // ERROR: Time not supported
}
```
‚úÖ **ALWAYS: Date only, no time**
```json
{
  "initialValue": "2024-03-15"
}
```

#### Common Spec Mappings
- "Date of birth" ‚Üí DatePicker (no time needed)
- "Event date" ‚Üí DatePicker with validation
- "Deadline" ‚Üí DatePicker with min/max constraints
- "Anniversary date" ‚Üí DatePicker, often optional

### MonthPicker (Month in Designer) {essential}
<!-- keywords: month, year, month-year, precision, historical -->

#### Purpose {essential}
Month-year selection that deliberately avoids false daily precision, particularly valuable for historical documentation where exact dates are unknown or meaningless. Prevents the common archaeological error of inventing precision where none exists, acknowledging the epistemological limitations of historical sources.

**Storage Format**: YYYY-MM string (e.g., `2024-03`)  
**Best For**: Historical records, publication dates, field seasons, archival materials

#### Methodological Advantages {essential}
- ‚úÖ **Prevents spurious precision** in temporal documentation
- ‚úÖ **Acknowledges epistemological limitations** of historical sources
- ‚úÖ **Reduces data entry burden** for approximate dates

#### Configuration Parameters {important}
**Designer creates basic field** with label, required, and helper text. JSON enhancement needed for fullWidth and platform-specific configurations.

```json
{
  "component-parameters": {
    "label": "Publication Date",
    "name": "publication_month",
    "helperText": "Month and year of publication"
  }
}
```

#### Critical Export Issue {important}
‚ö†Ô∏è **Excel Misinterpretation**: Excel may interpret `2024-03` as "3rd March 2024" rather than "March 2024". Always import as text column.

#### Field-Specific Troubleshooting {important}

| Issue | Symptom | Cause | Solution |
|-------|---------|-------|----------|
| Excel shows as day | "2024-03" ‚Üí "3 March 2024" | Auto-interpretation | Import as text, document format |
| Day appears in data | See "01" appended | Some systems add day | Process as YYYY-MM only |
| Need specific day | Too coarse for requirement | Month-only storage | Use DatePicker instead |
| Historical dates | Pre-1900 dates problematic | Browser limitations | Consider text field |
| Comparison issues | Sorting incorrect | String comparison | Ensure YYYY-MM format |


#### JSON Anti-patterns

‚ùå **NEVER: Wrong month format**
```json
{
  "initialValue": "March 2024"  // ERROR: Invalid format
}
```
‚úÖ **ALWAYS: Use YYYY-MM format**
```json
{
  "initialValue": "2024-03"  // Correct format
}
```

‚ùå **NEVER: Including day in month field**
```json
{
  "initialValue": "2024-03-15"  // ERROR: Day not supported
}
```
‚úÖ **ALWAYS: Year and month only**
```json
{
  "initialValue": "2024-03"
}
```

#### Common Spec Mappings
- "Reporting period" ‚Üí MonthPicker
- "Month of observation" ‚Üí MonthPicker with helperText
- "Billing month" ‚Üí MonthPicker with validation
- "Season indicator" ‚Üí MonthPicker (month precision adequate)

## Troubleshooting Guide {important}

### Critical Issues {important}

#### Timezone Corruption in Multi-Site Projects
**Symptoms**: Same time shows differently across devices  
**Affected Field**: DateTimePicker  
**Resolution**: 
1. ‚ö†Ô∏è Switch to DateTimeNow immediately
2. Document timezone convention for existing data
3. Export and convert all timestamps to UTC
4. Retrain team on timezone implications

#### "Invalid Date" After Entry
**Symptoms**: Date disappears or shows "Invalid Date"  
**Debug Checklist**:
- [ ] Verify browser locale settings
- [ ] Check for mixed format entry (DD/MM vs MM/DD)
- [ ] Confirm HTML5 date input support
- [ ] Test with picker interface instead of typing
- [ ] Validate stored string format in database

#### Excel Date Format Corruption
**Symptoms**: Dates change format when opened in Excel  
**Prevention**:
1. Import CSV as text, not opening directly
2. Use Excel's import wizard specifying text columns
3. Process with scripts instead of spreadsheets
4. Document format in column headers (e.g., "Date_YYYYMMDD")

### Error Message Reference {important}

Common date field error messages and their meanings:

| Error Message | Field Type | Cause | Solution |
|--------------|------------|-------|----------|
| `Cannot read property 'toISOString' of null` | DateTimeNow | Date field has null initialValue | Must use empty string `""` not `null` |
| `Invalid Date` | All date fields | Browser can't parse date format | Check locale settings, use picker interface |
| `Maximum call stack size exceeded` | TemplatedString | Date field referenced in template | Remove date field from template |
| `Synchronisation conflict` | DateTimePicker | Timezone ambiguity between sites | Migrate to DateTimeNow immediately |
| `Invalid time value` | All date fields | Wrong format (e.g., DD/MM/YYYY) | Use YYYY-MM-DD format consistently |
| `Expected string, received null` | All date fields | initialValue is null | Change to empty string `""` |
| `Cannot read property 'getTime' of undefined` | Conditional logic | Date comparison with undefined field | Check field exists before comparison |
| `3rd March 2024` | MonthPicker in Excel | Excel misinterpreted YYYY-MM | Import as text column, never auto-open |
| `Form cannot be submitted` | Required date fields | Empty or invalid date | Check field has been touched/populated |


### Quick Reference Matrix {important}

| If you see... | First try... | Then try... | Last resort... |
|---------------|--------------|-------------|----------------|
| Timezone confusion | Switch to DateTimeNow | Document timezone assumptions | Single-site deployment only |
| "Invalid Date" error | Use date picker interface | Check browser locale | Enter in YYYY-MM-DD format |
| Excel corrupts dates | Import as text column | Use Text Import Wizard | Export as JSON |
| Auto-pick not working | Check JSON has `is_auto_pick: true` | Verify DateTimeNow component | Manual timestamp |
| Dates off by one day | Check timezone boundaries | Verify UTC conversion | Use DatePicker if time irrelevant |
| Cannot enter historical date | Verify no min date constraint | Check browser support | Use text field with validation |
| Month picker shows day | Expected behavior - ignore day | Add helper text explanation | Use custom component |
| iOS picker blocks form | Known iOS behavior | Train users to expect it | Consider alternative UI |
| "Now" button missing | Check component is DateTimeNow | Verify mobile browser | Manual entry |
| Form won't submit | Check required date populated | Verify field touched | Remove required validation |
### Quick Reference Table {important}

| Symptom | Field Type | Likely Cause | Quick Fix | Prereq | Speed | Freq | Admin | Prevention | Version |
|---------|------------|--------------|-----------|--------|-------|------|-------|------------|---------|
| Times off by hours | DateTimePicker | No timezone stored | Migrate to DateTimeNow | Migration script | üî¥ | üî• | üîß | Never use DateTimePicker | 2025-08 |
| Sync conflicts multi-site | DateTimePicker | Timezone ambiguity | Document assumed TZ | Team agreement | üü° | üî• | üë§ | Use DateTimeNow only | 2025-08 |
| "14:30" means different times | DateTimePicker | Local time storage | Add TZ to label | Designer access | üü° | üî• | üîß | Deprecate immediately | 2025-08 |
| UTC confuses users | DateTimeNow | Working as designed | Train on UTC concept | Training materials | üü° | üî• | üë§ | Clear labeling | 2025-08 |
| Daylight saving issues | All datetime fields | Clock change period | Wait 1 hour, retry | None | üü¢ | üíß | üë§ | Avoid DST changes | 2025-08 |

### When Format Issues Occur

| Symptom | Field Type | Likely Cause | Quick Fix | Prereq | Speed | Freq | Admin | Prevention | Version |
|---------|------------|--------------|-----------|--------|-------|------|-------|------------|---------|
| "3rd March 2024" in Excel | MonthPicker | Excel misinterprets YYYY-MM | Import as text column | Excel knowledge | üü° | üî• | üë§ | Document format clearly | 2025-08 |
| Dates change in CSV | All date fields | Excel auto-format | Use import wizard | Excel access | üü° | üî• | üë§ | Train on text import | 2025-08 |
| String comparison fails | Mixed date types | Different formats | Use same field type | Designer access | üü° | ‚ö° | üîß | Standardize field types | 2025-08 |
| ISO string in template | DateTimeNow | Shows raw timestamp | Create display field | Template knowledge | üü° | ‚ö° | üîß | Use paired pattern | 2025-08 |
| Month shows as date | MonthPicker | Software interprets as DD | Parse explicitly | Script knowledge | üü° | üî• | üë§ | Add format notes | 2025-08 |
| Leading zeros missing | DatePicker | Browser strips zeros | Enforce YYYY-MM-DD | None | üü¢ | üíß | üë§ | Validate on export | 2025-08 |

### When Validation Fails

| Symptom | Field Type | Likely Cause | Quick Fix | Prereq | Speed | Freq | Admin | Prevention | Version |
|---------|------------|--------------|-----------|--------|-------|------|-------|------------|---------|
| Required not enforcing | All date fields | Field not touched | Click field, then away | None | üü¢ | üî• | üë§ | Train validation timing | 2025-08 |
| Can't enforce date range | All date fields | Not supported | Post-collection check | Script ability | üî¥ | üî• | üîß | Document constraints | 2025-08 |
| Future dates accepted | All date fields | No max validation | Manual review | Review process | üî¥ | üî• | üë§ | Label expectations | 2025-08 |
| Past dates accepted | All date fields | No min validation | Manual review | Review process | üî¥ | ‚ö° | üë§ | Helper text warnings | 2025-08 |
| Cross-field validation absent | All date fields | Not supported | External validation | Technical knowledge | üî¥ | üî• | üîß | Alternative architecture | 2025-08 |

### When Pickers Misbehave

| Symptom | Field Type | Likely Cause | Quick Fix | Prereq | Speed | Freq | Admin | Prevention | Version |
|---------|------------|--------------|-----------|--------|-------|------|-------|------------|---------|
| Picker doesn't appear | All date fields | Browser incompatibility | Update browser | Browser update | üü° | üíß | üë§ | Test browsers first | 2025-08 |
| Wrong picker type | DateTimeNow | Platform default | Expected behavior | None | üü¢ | üî• | üë§ | Train expectations | 2025-08 |
| Picker covers form | Mobile all | Full-screen mode | Rotate device | None | üü¢ | üî• | üë§ | Design for mobile | 2025-08 |
| Can't find "Now" | DateTimeNow | Platform location varies | Look bottom-right | None | üü¢ | üî• | üë§ | Platform training | 2025-08 |
| Wheels confusing | iOS all | Platform convention | Swipe to scroll | iOS device | üü¢ | üî• | üë§ | iOS-specific guide | 2025-08 |

## JSON Examples {comprehensive}

### DateTimeNow Patterns

```json
// BASE PATTERN (recommended default for all timestamps)
{
  "component-namespace": "faims-custom",
  "component-name": "DateTimeNow",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "timestamp-field",  // MUST match field ID
    "label": "Timestamp"
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""  // MUST be "" not null
}

// VARIANT: Auto-populated creation timestamp
+ "component-parameters": {
+   "is_auto_pick": true,  // Auto-fills on form open
+   "helperText": "Automatically captured (UTC)",
+   "fullWidth": true
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.required", "Timestamp required"]
+ ]

// VARIANT: Manual timestamp with annotation
+ "component-parameters": {
+   "is_auto_pick": false,
+   "helperText": "Click 'Now' for current time",
+   "required": true
+ }
+ "meta": {
+   "annotation": {
+     "include": true,
+     "label": "Time notes (timezone, accuracy)"
+   }
+ }

// VARIANT: Protected auto-timestamp (prevents accidental edit)
+ "component-parameters": {
+   "is_auto_pick": true,
+   "disabled": true  // Read-only after creation
+ }
```

#### DateTimeNow ANTI-PATTERNS ‚ö†Ô∏è
```json
// ‚ùå NEVER: Null initialValue
{
  "initialValue": null  // ERROR: "Cannot read property 'toISOString' of null"
}

// ‚ùå NEVER: Missing timezone documentation
{
  "component-parameters": {
    "label": "Time"  // Users don't know if UTC or local!
    // FIX: Add helperText explaining timezone handling
  }
}

// ‚ùå NEVER: Auto-populate without user awareness
{
  "is_auto_pick": true,
  "component-parameters": {
    "label": "Date"  // Users may not realize it auto-fills
    // FIX: Add helperText: "Auto-captured on form open"
  }
}
```

### DateTimePicker Patterns (DISCOURAGED - Use DateTimeNow Instead)

```json
// BASE: Legacy only - migrate ASAP!
{
  "component-namespace": "faims-custom",
  "component-name": "DateTimePicker",  // ‚ö†Ô∏è DISCOURAGED - lacks timezone
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "legacy-datetime",
    "label": "Time (Legacy)",
    "helperText": "‚ö†Ô∏è No timezone - ambiguous timestamp"
  }
}

// MIGRATION PATH: Convert to DateTimeNow
{
- "component-name": "DateTimePicker",
+ "component-name": "DateTimeNow",
  "component-parameters": {
    "helperText": "Enter in your local time, stored as UTC"
  }
}
```

### DatePicker Patterns

```json
// BASE PATTERN (date without time)
{
  "component-namespace": "faims-custom",
  "component-name": "DatePicker",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "date-field",
    "label": "Date",
    "helperText": "Select date (no time component)"
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""  // Format: "YYYY-MM-DD" if pre-filled
}

// VARIANT: Required excavation date
+ "component-parameters": {
+   "label": "Excavation Start Date",
+   "helperText": "When excavation commenced",
+   "required": true
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.required", "Start date required"]
+ ]

// VARIANT: With uncertainty annotation
+ "meta": {
+   "annotation": {
+     "include": true,
+     "label": "Date uncertainty (circa, before, after)"
+   }
+ }
```

#### DatePicker ANTI-PATTERNS ‚ö†Ô∏è
```json
// ‚ùå NEVER: Expecting time component
{
  "component-name": "DatePicker",
  "helperText": "Enter date and time"  // DatePicker has no time!
  // USE: DateTimeNow or DateTimePicker for time
}

// ‚ùå NEVER: Relying on consistent format display
{
  "helperText": "Format: DD/MM/YYYY"  // Display varies by locale!
  // FIX: "Date format follows your browser settings"
}

// ‚ùå NEVER: Cross-field validation in schema
{
  "validationSchema": [
    ["yup.date"],
    ["yup.min", ["yup.ref", "start_date"], "Must be after start"]
  ]  // This doesn't work! Dates stored as strings
}

// ‚ùå NEVER: Using for month-year only
{
  "component-name": "DatePicker"
  // Forces arbitrary day selection
  // USE: MonthPicker instead
}
```

### MonthPicker Patterns

```json
// BASE PATTERN (month-year precision)
{
  "component-namespace": "faims-custom",
  "component-name": "MonthPicker",
  "type-returned": "faims-core::String",  // Actually stores YYYY-MM string
  "component-parameters": {
    "name": "month-field",
    "label": "Month/Year",
    "helperText": "Select month and year (no day)"
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""  // Format: "YYYY-MM" if pre-filled
}

// VARIANT: Field season recording
+ "component-parameters": {
+   "label": "Excavation Season",
+   "helperText": "Month of field season",
+   "required": true
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.required", "Season must be specified"]
+ ]

// VARIANT: Historical publication date
+ "component-parameters": {
+   "label": "Publication Date",
+   "helperText": "Month/year from source (avoids false precision)"
+ }
+ "initialValue": "1887-03"  // March 1887
```

#### MonthPicker ANTI-PATTERNS ‚ö†Ô∏è
```json
// ‚ùå NEVER: Expecting day in data
{
  "initialValue": "2024-03-15"  // Day will be ignored!
  // Only stores: "2024-03"
}

// ‚ùå NEVER: Direct Excel export without warning
{
  // Excel interprets "2024-03" as March 3rd, 2024!
  // Always document: "YYYY-MM format = entire month"
}
```

### Platform-Specific Configurations {important}

Optimize date field behavior for specific platforms:

#### iOS-Optimized Configuration
```json
// Extra spacing for iOS picker overlay
{
  "component-namespace": "faims-custom",
  "component-name": "DateTimeNow",
  "component-parameters": {
    "fullWidth": true,
    "margin": "dense",  // More space for iOS overlay
    "helperText": "Swipe up/down on wheels to select time",
    "InputProps": {
      "style": {
        "paddingBottom": "20px"  // Extra padding for picker
      }
    }
  }
}
```

#### Android-Optimized Configuration
```json
// Touch-friendly configuration for Android
{
  "component-namespace": "faims-custom",
  "component-name": "DatePicker",
  "component-parameters": {
    "fullWidth": true,
    "variant": "outlined",  // Better touch target
    "helperText": "Tap to open calendar",
    "InputProps": {
      "style": {
        "minHeight": "56px",  // Android Material Design touch target
        "fontSize": "16px"    // Prevent zoom on focus
      }
    }
  }
}
```

#### Desktop-Optimized Configuration
```json
// Keyboard-friendly desktop configuration
{
  "component-namespace": "faims-custom",
  "component-name": "DateTimeNow",
  "component-parameters": {
    "fullWidth": false,  // Narrower for mouse precision
    "variant": "standard",
    "helperText": "Click field then use picker or type YYYY-MM-DD HH:MM",
    "InputProps": {
      "placeholder": "YYYY-MM-DD HH:MM",
      "style": {
        "width": "250px"  // Fixed width for desktop
      }
    }
  }
}
```

#### Multi-Platform Responsive Configuration
```json
// Adaptive configuration for all platforms
{
  "component-namespace": "faims-custom",
  "component-name": "DateTimeNow",
  "component-parameters": {
    "fullWidth": true,
    "helperText": "Select date/time (stored as UTC)",
    "InputProps": {
      "style": {
        "minHeight": "48px",     // Accessible touch target
        "paddingTop": "8px",      
        "paddingBottom": "8px"
      }
    },
    "FormHelperTextProps": {
      "style": {
        "marginTop": "8px",       // Clear spacing
        "fontSize": "14px"        // Readable on all devices
      }
    }
  }
}
```

### Integration Patterns (Date Fields Working Together)

```json
// PATTERN: Date Range with Validation
{
  "excavation_start": {
    "component-name": "DatePicker",
    "component-parameters": {
      "label": "Excavation Start",
      "required": true
    }
  },
  "excavation_end": {
    "component-name": "DatePicker",
    "component-parameters": {
      "label": "Excavation End",
      "required": true
    },
    "condition_instructions": {
      "conditions": [{
        "field": "excavation_start",
        "operator": "less",  // String comparison!
        "value_field": "excavation_end"
      }],
      "action": "enable",
      "else": "disable"
    }
  }
}

// PATTERN: Flexible Precision (exact date OR month-year)
{
  "date_precision": {
    "component-name": "RadioGroup",
    "component-parameters": {
      "label": "Date Precision",
      "options": [
        {"value": "exact", "label": "Exact day known"},
        {"value": "month", "label": "Only month/year known"}
      ]
    }
  },
  "exact_date": {
    "component-name": "DatePicker",
    "component-parameters": {
      "label": "Exact Date"
    },
    "condition_instructions": {
      "conditions": [{
        "field": "date_precision",
        "operator": "equal",
        "value": "exact"
      }],
      "action": "visible"
    }
  },
  "approximate_date": {
    "component-name": "MonthPicker",
    "component-parameters": {
      "label": "Month/Year"
    },
    "condition_instructions": {
      "conditions": [{
        "field": "date_precision",
        "operator": "equal",
        "value": "month"
      }],
      "action": "visible"
    }
  }
}

// PATTERN: Timestamp with Display (prevents edit of creation time)
{
  "created_timestamp": {
    "component-name": "DateTimeNow",
    "component-parameters": {
      "is_auto_pick": true,
      "hidden": true  // Store but don't show editable field
    }
  },
  "created_display": {
    "component-name": "TemplatedStringField",
    "component-parameters": {
      "template": "Created: {{created_timestamp}}",
      "disabled": true  // Read-only display
    }
  }
}

// PATTERN: Multi-timezone Team Coordination
{
  "local_time": {
    "component-name": "DateTimeNow",
    "component-parameters": {
      "label": "Timestamp (Your Local Time)",
      "helperText": "Enter in your timezone - stored as UTC",
      "is_auto_pick": false
    }
  },
  "timezone_context": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Your Timezone",
      "options": [
        {"value": "UTC+10", "label": "Sydney (UTC+10)"},
        {"value": "UTC+0", "label": "London (UTC+0)"},
        {"value": "UTC-5", "label": "New York (UTC-5)"}
      ],
      "helperText": "For team coordination"
    }
  }
}

// PATTERN: Historical Date with Uncertainty
{
  "historical_date": {
    "component-name": "MonthPicker",  // Avoids false precision
    "component-parameters": {
      "label": "Document Date"
    }
  },
  "date_qualifier": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Date Qualifier",
      "options": [
        {"value": "exact", "label": "Exact date"},
        {"value": "circa", "label": "Circa"},
        {"value": "before", "label": "Before"},
        {"value": "after", "label": "After"}
      ]
    }
  }
}
```

## Migration Scenarios {comprehensive}

### Scenario 1: DateTimePicker to DateTimeNow Migration
**Context**: Legacy forms using DateTimePicker need migration to timezone-aware DateTimeNow to prevent data corruption in multi-site projects.

**Challenge**:
- DateTimePicker stores ambiguous local time without timezone
- Multi-site projects have conflicting timezone interpretations
- Existing data needs timezone assumption documented

**Migration Steps**:
1. Export all records with DateTimePicker fields
2. Document assumed timezone for existing data (e.g., "+10:00" for Sydney)
3. Convert timestamps adding timezone suffix:
   ```javascript
   const localDT = record.old_datetime + '+10:00';
   record.new_datetime = new Date(localDT).toISOString();
   ```
4. Update form configuration to use DateTimeNow
5. Import converted data and verify with known timestamps

**Solution/Workaround**: Always use DateTimeNow for new projects; document timezone assumptions prominently in project metadata.

### Scenario 2: DatePicker to MonthPicker (Removing False Precision)
**Context**: Historical data recorded with arbitrary day values when only month/year is known.

**Challenge**:
- Users enter "01" or "15" as placeholder days
- False precision in archaeological/historical contexts
- Data analysis assumes day precision is meaningful

**Migration Steps**:
1. Identify fields with consistent arbitrary day patterns
2. Export data and strip day component:
   ```javascript
   // "2024-03-15" ‚Üí "2024-03"
   const monthOnly = dateString.substring(0, 7);
   ```
3. Update field type to MonthPicker
4. Import converted month-only data
5. Document precision reduction in metadata

**Solution/Workaround**: Use MonthPicker from start when day precision unavailable; add annotation field for date uncertainty.

### Scenario 3: Excel Date Corruption Prevention
**Context**: CSV exports opened in Excel automatically corrupt date formats.

**Challenge**:
- Excel converts "03/04" to "4-Mar" or "3-Apr" depending on locale
- ISO dates become regional formats
- MonthPicker "2024-03" becomes "March 2024" or "2024-03-01"

**Migration Steps**:
1. Never double-click CSV files
2. Open Excel first, use Data > From Text/CSV
3. In preview, change date columns to "Text"
4. For existing corrupted data:
   ```python
   # Fix Excel's date interpretation
   df['fixed_date'] = pd.to_datetime(df['corrupted'], 
                                     format='%d-%b').strftime('%Y-%m-%d')
   ```
5. Train all users on proper CSV import

**Solution/Workaround**: Export with apostrophe prefix ('2024-03-15) or use .xlsx format with explicit text formatting.

### Scenario 4: Multi-Site Timezone Coordination
**Context**: Archaeological excavation across multiple time zones needs consistent temporal recording.

**Challenge**:
- Team members in different timezones
- Local time vs UTC confusion
- Daylight saving transitions mid-project

**Migration Steps**:
1. Establish project-wide UTC policy
2. Convert all existing local times to UTC:
   ```javascript
   // Sydney local to UTC during DST
   const utc = new Date(localTime + '+11:00').toISOString();
   ```
3. Add timezone display helpers for local reference
4. Update all DateTimeNow fields to show "(UTC)" in labels
5. Create timezone conversion reference sheet

**Solution/Workaround**: Always use UTC internally; display local time in UI with clear timezone indicators.

### Scenario 5: Historical Date Uncertainty
**Context**: Recording approximate or uncertain dates in historical/archaeological contexts.

**Challenge**:
- "Circa 1850" or "early 20th century"
- Date ranges (1920-1925)
- Seasonal dates without specific days

**Migration Steps**:
1. Add companion text field for uncertainty:
   ```json
   "date_uncertainty": {
     "component-name": "TextField",
     "label": "Date Uncertainty/Notes"
   }
   ```
2. Use MonthPicker for month-level precision
3. Document uncertainty conventions in project metadata
4. For existing data, extract uncertainty from notes fields
5. Implement post-processing for date range queries

**Solution/Workaround**: Always pair date fields with uncertainty annotations; use earliest date for ranges with documentation.

### Migration Warnings Index

#### Safe Migrations (No Data Loss) {comprehensive}
- `SAFE` DateTimePicker ‚Üí DateTimeNow with documented timezone assumption
- `SAFE` Adding MonthPicker alongside existing DatePicker
- `SAFE` Adding annotation fields for temporal uncertainty
- `SAFE` Adding helperText to clarify timezone handling

#### Breaking Changes (Data Loss Risk) {comprehensive}
- `BREAKS` DateTimeNow ‚Üí DateTimePicker (loses timezone information)
- `BREAKS` DatePicker ‚Üí MonthPicker (loses day precision)
- `BREAKS` Changing field names (orphans existing data)
- `BREAKS` Adding validation to populated fields

#### Conditional Migrations {comprehensive}
- `CONDITIONAL` MonthPicker ‚Üí DatePicker (safe if arbitrary day acceptable)
- `CONDITIONAL` DatePicker ‚Üí DateTimeNow (safe if time can be 00:00)

### Critical Implementation Procedures {comprehensive}

#### Procedure A: DateTimePicker to DateTimeNow Migration
```javascript
// 1. Export all data with timestamps
const records = await exportAll();

// 2. Document your timezone assumption
const ASSUMED_TZ = '+10:00'; // Sydney

// 3. Convert each DateTimePicker value
records.forEach(r => {
  if (r.old_datetime) {
    r.new_datetime = new Date(r.old_datetime + ASSUMED_TZ).toISOString();
  }
});

// 4. Update form configuration
// 5. Import converted data
// 6. Verify with known timestamps
```

#### Procedure B: Excel Date Import Fix
1. Never double-click CSV file
2. Open Excel first
3. Data > From Text/CSV
4. Select file
5. In preview, click column headers
6. Change "Date" columns to "Text"
7. Load data
8. Dates remain as YYYY-MM-DD strings

#### Procedure C: MonthPicker Data Processing
```python
import pandas as pd

# Read with explicit string type
df = pd.read_csv('data.csv', dtype={'month_field': str})

# Parse YYYY-MM correctly
df['year'] = df['month_field'].str[:4].astype(int)
df['month'] = df['month_field'].str[5:7].astype(int)

# Never interpret as date
# "2024-03" is March 2024, NOT March 3rd!
```

### Migration Script Templates {comprehensive}

Ready-to-use migration scripts for common date field conversions:

#### Template 1: DateTimePicker to DateTimeNow Migration
```javascript
// Complete migration script for timezone correction
const migrateDateTimePicker = (records, assumedTimezone = '+10:00') => {
  const migrated = [];
  const errors = [];
  
  records.forEach((record, index) => {
    try {
      if (record.old_datetime_field) {
        // Add timezone to ambiguous local time
        const localDT = record.old_datetime_field + assumedTimezone;
        record.new_datetime_field = new Date(localDT).toISOString();
      }
      migrated.push(record);
    } catch (e) {
      errors.push({index, error: e.message, record});
    }
  });
  
  console.log(`Migrated: ${migrated.length}, Errors: ${errors.length}`);
  return {migrated, errors};
};

// Usage
const results = migrateDateTimePicker(allRecords, '+10:00');
```

#### Template 2: DatePicker to MonthPicker (Removing False Precision)
```javascript
// Convert date to month-year when day precision is spurious
const dateToMonth = (dateString) => {
  if (!dateString) return '';
  // "2024-03-15" ‚Üí "2024-03"
  return dateString.substring(0, 7);
};

// Bulk conversion with validation
const convertDatesToMonths = (records, fieldName) => {
  return records.map(record => ({
    ...record,
    [`${fieldName}_month`]: dateToMonth(record[fieldName]),
    [`${fieldName}_original`]: record[fieldName] // Keep original for rollback
  }));
};
```

#### Template 3: Excel-Safe Date Export Preparation
```javascript
// Prepare dates for Excel to prevent auto-conversion
const prepareForExcel = (records) => {
  return records.map(record => {
    const processed = {...record};
    
    // Prefix with apostrophe to force text in Excel
    if (record.month_field) {
      processed.month_field_safe = "'" + record.month_field;
    }
    if (record.date_field) {
      processed.date_field_safe = "'" + record.date_field;
    }
    
    // Alternative: Add explicit format suffix
    if (record.datetime_field) {
      processed.datetime_display = record.datetime_field + " (UTC)";
    }
    
    return processed;
  });
};

// Export configuration
const exportConfig = {
  headers: {
    'month_field_safe': 'Month (YYYY-MM)',
    'date_field_safe': 'Date (YYYY-MM-DD)',
    'datetime_display': 'Timestamp (ISO 8601 UTC)'
  }
};
```

### Migration Decision Tree {comprehensive}

```mermaid
graph TD
    A[Current Field Type?] --> B[DateTimePicker]
    A --> C[DatePicker]
    A --> D[MonthPicker]
    A --> E[DateTimeNow]
    
    B --> F[URGENT: Migrate to DateTimeNow]
    F --> G[Document timezone assumption]
    G --> H[Convert all data]
    
    C --> I{Need time?}
    I -->|Yes| J[Add DateTimeNow]
    I -->|No| K{Day precision needed?}
    K -->|No| L[Consider MonthPicker]
    K -->|Yes| M[Keep DatePicker]
    
    D --> N{Need day precision?}
    N -->|Yes| O[Migrate to DatePicker]
    N -->|No| P[Keep MonthPicker]
    
    E --> Q{Timezone issues?}
    Q -->|Yes| R[Check UTC handling]
    Q -->|No| S[Keep DateTimeNow]
```

## Best Practices {comprehensive}

### Design Principles
- **Timezone clarity**: Always use DateTimeNow for timestamps
- **Appropriate precision**: MonthPicker for historical data without day precision
- **Uncertainty documentation**: Pair date fields with annotation fields
- **Excel protection**: Export dates with text formatting protection
- **Platform consistency**: Test picker interfaces on all target devices

### Field Selection Priorities
1. **Always prefer DateTimeNow** for timestamps unless compelling reason otherwise
2. **Document timezone assumptions** in project metadata AND field helperText
3. **Include annotation fields** for temporal uncertainty
4. **Use MonthPicker** to avoid false precision in historical data
5. **Never use DateTimePicker** in new projects

#### Data Quality Strategies
- Train users on platform-specific picker interfaces
- Implement post-collection validation for temporal constraints
- Regular audits for timezone consistency
- Excel import training mandatory for data managers
- Document all date approximation conventions

### Team Coordination Protocols
- Establish single timezone for multi-site projects
- Daily sync meetings during concurrent excavations
- Written protocols for date uncertainty handling
- Timezone converter bookmarks for all team members
- Regular data quality checks focusing on temporal data

### Performance Optimization
- Limit date fields per form (<10 for mobile performance)
- Avoid complex date calculations in TemplatedString
- Cache parsed dates rather than reparsing
- Use native pickers where possible (better performance than custom)
- Batch date operations for bulk updates

### Common Patterns
- **Excavation timestamp**: DateTimeNow + GPS coordinates
- **Historical period**: MonthPicker + uncertainty text field
- **Date range**: Two DatePicker fields with validation
- **Seasonal date**: MonthPicker + season selector
- **Approximate date**: DatePicker + "circa" checkbox

### Common Mistakes to Avoid {important}

1. **Using DateTimePicker in multi-site projects** - causes data corruption
2. **Opening CSV files directly in Excel** - corrupts all date formats
3. **Assuming consistent picker interfaces** - varies dramatically by platform
4. **Relying on validation for date ranges** - not supported, needs external validation
5. **Storing dates as Date objects** - all actually store as strings
6. **Ignoring timezone implications** - critical for data integrity
7. **Using DatePicker when only month/year known** - creates false precision
8. **Not documenting timezone assumptions** - makes data uninterpretable
9. **Manual date entry instead of pickers** - causes format errors
10. **Expecting BCE date support** - not available in any date field

### Training Requirements {comprehensive}

#### Basic Training (All Users)
**Duration**: 30 minutes  
**Format**: Hands-on with test forms

1. **Platform-specific interfaces**
   - iOS: Drum wheel navigation (swipe up/down)
   - Android: Calendar grid interaction (tap date)
   - Desktop: Keyboard entry vs picker usage
   - Screenshots for each platform in training materials

2. **"Now" button location and usage**
   - Mobile: Usually bottom-right of picker
   - Desktop: Clock icon or "Now" text button
   - Practice finding on different devices
   - When to use vs manual selection

3. **Timezone implications**
   - UTC storage explanation with examples
   - Local time entry ‚Üí UTC conversion
   - Why times might look "wrong" (UTC offset)
   - Team coordination across timezones

4. **Data quality importance**
   - How date errors cascade through system
   - Impact on synchronisation
   - Importance of consistent formats
   - When to use annotation fields

#### Advanced Training (Data Managers)
**Duration**: 2 hours  
**Format**: Workshop with real data

1. **Export format preservation techniques**
   - Never double-click CSV files
   - Text Import Wizard step-by-step
   - Preventing Excel auto-conversion
   - Creating Excel-safe exports

2. **Excel import procedures**
   ```
   Step-by-step Excel import:
   1. Open Excel first (not the CSV)
   2. Data ‚Üí From Text/CSV
   3. Select file
   4. In preview, click column headers
   5. Change all date columns to "Text"
   6. Load ‚Üí dates preserved as strings
   ```

3. **Timezone conversion scripts**
   - Converting legacy DateTimePicker data
   - Bulk timezone corrections
   - Verification procedures
   - Rollback strategies

4. **Validation pipeline implementation**
   - Post-collection date validation
   - Cross-field temporal checks
   - Automated data quality reports
   - Integration with analysis pipelines

5. **Cross-field temporal validation strategies**
   - Ensuring start dates before end dates
   - Detecting impossible date sequences
   - Identifying timezone inconsistencies
   - Flagging future dates where inappropriate

#### Field Supervisor Training
**Duration**: 1 hour  
**Format**: Field-focused scenarios

1. **Approximation protocols**
   - When to use DatePicker vs MonthPicker
   - Documenting uncertainty levels
   - Standard approximation conventions
   - Using annotation fields effectively

2. **MonthPicker vs DatePicker decision criteria**
   ```
   Decision tree:
   - Exact day known? ‚Üí DatePicker
   - Only month/year known? ‚Üí MonthPicker
   - Historical document? ‚Üí MonthPicker (avoid false precision)
   - Administrative deadline? ‚Üí DatePicker
   - Field season? ‚Üí MonthPicker
   ```

3. **Annotation field usage**
   - When to add uncertainty notes
   - Standard uncertainty vocabulary
   - Timezone documentation
   - Approximation rationale

4. **Multi-site coordination procedures**
   - Daily sync meeting protocols
   - Timezone coordination standards
   - Conflict resolution procedures
   - Data quality check responsibilities

#### Training Materials Checklist
- [ ] Platform-specific screenshot guides
- [ ] Excel import video tutorial
- [ ] Timezone conversion calculator/tool
- [ ] Decision trees (laminated for field use)
- [ ] Common error reference card
- [ ] Practice datasets with known issues
- [ ] Validation script library
- [ ] Multi-site coordination protocols

### Alternative Approaches {comprehensive}

When standard date fields don't meet requirements, consider these alternatives:

#### For Complex Temporal Requirements

##### Separate Component Fields
```json
// Split date into year, month, day for flexible precision
{
  "year_field": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Year",
      "min": 1800,
      "max": 2100
    }
  },
  "month_field": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Month",
      "options": [
        {"value": "", "label": "Unknown"},
        {"value": "01", "label": "January"},
        {"value": "02", "label": "February"}
        // ... etc
      ]
    }
  },
  "day_field": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Day (if known)",
      "min": 1,
      "max": 31,
      "required": false
    }
  }
}
```

##### Text Field with Pattern Validation
```json
// For BCE dates or non-standard formats
{
  "historical_date": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Historical Date",
      "helperText": "Format: YYYY-MM-DD (negative year for BCE)",
      "placeholder": "-0753-04-21"
    },
    "validationSchema": [
      ["yup.matches", "^-?\\d{1,4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$", 
       "Format: YYYY-MM-DD (use negative for BCE)"]
    ]
  }
}
```

##### Controlled Vocabulary for Periods
```json
// Archaeological or geological periods
{
  "temporal_period": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Archaeological Period",
      "options": [
        {"value": "early_bronze", "label": "Early Bronze Age (3300-2000 BCE)"},
        {"value": "middle_bronze", "label": "Middle Bronze Age (2000-1550 BCE)"},
        {"value": "late_bronze", "label": "Late Bronze Age (1550-1200 BCE)"}
      ]
    }
  }
}
```

##### Using Established Chronological Vocabularies

**Important**: For archaeological and historical chronology, use established vocabularies rather than date fields:

**Periodo (periodo.github.io)**
- Collaborative gazetteer of historical periods
- JSON-LD format for integration
- Spatially and temporally scoped period definitions
- Example implementation:
```json
{
  "chronological_period": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Period (from Periodo)",
      "helperText": "Periods from periodo.github.io",
      "options": [
        {
          "value": "p0qhb66", 
          "label": "Late Bronze Age, Levant (1550-1200 BCE)"
        },
        {
          "value": "p0qhb65",
          "label": "Middle Bronze Age IIB, Levant (1750-1550 BCE)"
        }
      ]
    }
  },
  "periodo_uri": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Periodo URI",
      "helperText": "Full Periodo identifier for external reference",
      "placeholder": "http://n2t.net/ark:/99152/p0qhb66"
    }
  }
}
```

**Other Archaeological Vocabularies to Consider**:
- **Getty AAT** (Art & Architecture Thesaurus) - Hierarchical vocabulary including chronological terms
- **Heritage Data Vocabularies** - UK-specific period lists maintained by Historic England
- **FISH Vocabularies** - Forum on Information Standards in Heritage terminologies
- **Local/Regional Chronologies** - Project-specific but mapped to standard vocabularies

**Best Practice Pattern**:
1. Use Select/RadioGroup fields for period selection (not date fields)
2. Store both local term and URI to external vocabulary
3. Include date ranges in labels for user reference
4. Map local chronologies to established standards where possible
5. Document vocabulary sources in project metadata

**Why Not Date Fields for Archaeological Periods**:
- Periods have fuzzy boundaries that vary by region
- Start/end dates are interpretive and debated
- Chronological frameworks differ by scholarly tradition
- Period definitions change with new research
- Cultural periods don't align with calendar years

For **absolute dates** (e.g., C14 dates, dendrochronology):
- Use the Fuzzy Date Storage Pattern documented above
- Include calibration information in annotations
- Record laboratory codes and uncertainty ranges
- Consider specialized fields for BP/BCE/CE conversions

#### For Historical Uncertainty

##### Comprehensive Uncertainty Pattern
```json
{
  "date_type": {
    "component-name": "RadioGroup",
    "component-parameters": {
      "label": "Date Precision",
      "options": [
        {"value": "exact", "label": "Exact date known"},
        {"value": "month", "label": "Month/year only"},
        {"value": "year", "label": "Year only"},
        {"value": "decade", "label": "Decade"},
        {"value": "century", "label": "Century"},
        {"value": "period", "label": "Historical period"}
      ]
    }
  },
  "exact_date": {
    "component-name": "DatePicker",
    "condition": {"field": "date_type", "operator": "equal", "value": "exact"}
  },
  "month_date": {
    "component-name": "MonthPicker",
    "condition": {"field": "date_type", "operator": "equal", "value": "month"}
  },
  "year_only": {
    "component-name": "NumberInput",
    "component-parameters": {"label": "Year", "min": 1000, "max": 2100},
    "condition": {"field": "date_type", "operator": "equal", "value": "year"}
  },
  "date_qualifier": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Date Qualifier",
      "options": [
        {"value": "exact", "label": "Exact"},
        {"value": "circa", "label": "Circa"},
        {"value": "before", "label": "Before"},
        {"value": "after", "label": "After"},
        {"value": "range", "label": "Range"}
      ]
    }
  },
  "date_notes": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Date Notes",
      "helperText": "Additional context (e.g., 'Spring 1887', 'Early in reign')"
    }
  }
}
```

##### Fuzzy Date Storage Pattern
```json
// Store uncertainty alongside dates
{
  "event_date_min": {
    "component-name": "DatePicker",
    "component-parameters": {
      "label": "Earliest Possible Date"
    }
  },
  "event_date_max": {
    "component-name": "DatePicker",
    "component-parameters": {
      "label": "Latest Possible Date"
    }
  },
  "event_date_likely": {
    "component-name": "DatePicker",
    "component-parameters": {
      "label": "Most Likely Date",
      "required": false
    }
  },
  "confidence_level": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Confidence",
      "options": [
        {"value": "certain", "label": "Certain"},
        {"value": "probable", "label": "Probable"},
        {"value": "possible", "label": "Possible"},
        {"value": "uncertain", "label": "Uncertain"}
      ]
    }
  }
}
```

##### Ancient History Date Pattern (BCE/CE with Uncertainty)

For ancient history and archaeology spanning BCE/CE, use numeric fields rather than date pickers:

**Pattern 1: Terminus Post/Ante Quem (Not Before/Not After)**
```json
{
  "date_not_before": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Not Before (negative = BCE)",
      "helperText": "e.g., -150 for 150 BCE",
      "min": -3500,
      "max": 2100
    }
  },
  "date_not_after": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Not After (negative = BCE)",
      "helperText": "e.g., -50 for 50 BCE",
      "min": -3500,
      "max": 2100
    }
  },
  "date_basis": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Dating Basis",
      "options": [
        {"value": "stratigraphic", "label": "Stratigraphic"},
        {"value": "ceramic", "label": "Ceramic typology"},
        {"value": "numismatic", "label": "Numismatic"},
        {"value": "epigraphic", "label": "Epigraphic"},
        {"value": "historical", "label": "Historical sources"},
        {"value": "c14", "label": "Radiocarbon"},
        {"value": "stylistic", "label": "Stylistic"}
      ]
    }
  }
}
```

**Pattern 2: Central Date with Plus/Minus Uncertainty**
```json
{
  "date_central": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Approximate Date (negative = BCE)",
      "helperText": "e.g., -100 for 100 BCE",
      "min": -3500,
      "max": 2100
    }
  },
  "date_uncertainty": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Uncertainty (+/- years)",
      "helperText": "e.g., 50 for ¬±50 years",
      "min": 0,
      "max": 500
    }
  },
  "date_note": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Dating Notes",
      "helperText": "Additional context (e.g., 'late in the reign of Augustus')"
    }
  }
}
```

**Pattern 3: Combined Periodo Vocabulary with Absolute Date Range**
```json
{
  "periodo_term": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Cultural Period",
      "helperText": "From Periodo gazetteer",
      "options": [
        {"value": "p0qhb66", "label": "Late Hellenistic Period, Eastern Mediterranean"},
        {"value": "p0qhb67", "label": "Early Roman Period, Eastern Mediterranean"}
      ]
    }
  },
  "absolute_earliest": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Absolute Earliest (negative = BCE)",
      "helperText": "Terminus post quem",
      "required": false
    }
  },
  "absolute_latest": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Absolute Latest (negative = BCE)",
      "helperText": "Terminus ante quem",
      "required": false
    }
  },
  "is_uncertain": {
    "component-name": "Checkbox",
    "component-parameters": {
      "label": "Dating uncertain"
    }
  },
  "uncertainty_note": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Uncertainty explanation"
    },
    "condition": {
      "field": "is_uncertain",
      "operator": "equal",
      "value": true
    }
  }
}
```

**Best Practices for Ancient Dates**:
1. **Always use negative numbers for BCE** (e.g., -323 for 323 BCE)
2. **Include year 0** in calculations (astronomical year numbering)
3. **Document dating methodology** (stratigraphic, stylistic, absolute, etc.)
4. **Combine approaches**: Cultural period (Periodo) + absolute date range + uncertainty
5. **Avoid false precision**: Century or quarter-century often more honest than specific years
6. **Consider multiple dating systems**: Regnal years, Olympic years, consular dates as annotations

**Why Numeric Fields Not Date Pickers for Ancient History**:
- Date pickers can't handle BCE dates reliably
- Ancient dates rarely precise to day or month
- Uncertainty is the norm, not the exception
- Need to express ranges, not points
- Cultural periods don't map to calendar years
- Dating often relative rather than absolute

#### For Specialised Temporal Interfaces

##### Duration Recording
```json
// Record time spans rather than points
{
  "duration_value": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Duration",
      "min": 0
    }
  },
  "duration_unit": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Unit",
      "options": [
        {"value": "minutes", "label": "Minutes"},
        {"value": "hours", "label": "Hours"},
        {"value": "days", "label": "Days"},
        {"value": "weeks", "label": "Weeks"},
        {"value": "months", "label": "Months"},
        {"value": "years", "label": "Years"}
      ]
    }
  }
}
```

##### Relative Date Recording
```json
// Dates relative to project milestones
{
  "relative_to": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Relative To",
      "options": [
        {"value": "project_start", "label": "Project Start"},
        {"value": "excavation_start", "label": "Excavation Start"},
        {"value": "previous_phase", "label": "Previous Phase End"}
      ]
    }
  },
  "days_offset": {
    "component-name": "NumberInput",
    "component-parameters": {
      "label": "Days From Reference",
      "helperText": "Negative for before, positive for after"
    }
  }
}
```

---

## Field Quirks Index (2025-08) {comprehensive}

### DateTimeNow
- `RULE` Default choice for all timestamp fields unless specific reason otherwise
- `RULE` Stores in ISO 8601 with timezone (UTC) format
- `ERROR` "Invalid Date" = browser locale parsing failure or mixed format entry
- `QUIRK` Name suggests contemporary only but accepts arbitrary dates (e.g., 1850)
- `QUIRK` UTC display confuses users expecting local time (shows Z suffix)
- `QUIRK` Auto-populated values (`is_auto_pick: true`) can be accidentally modified
- `QUIRK` "Now" button location varies by platform - often missed on mobile
- `FIX` For local display add helper text: "Times shown in UTC, enter in your local timezone"
- `FIX` For protected timestamps use paired pattern:
  ```json
  "created_display": {"component-name": "TemplatedString", "content": "{{created_time}}"},
  "created_time": {"component-name": "DateTimeNow", "is_auto_pick": true}
  ```
- `FIX` Train users: mobile "Now" button typically bottom-right of picker
- `TEST` Verify UTC storage: Save "3pm local", export should show "Z" suffix
- `TEST` Auto-pick protection: Set `is_auto_pick: true`, try to modify after creation
- `TEST` Historical dates: Enter date from 1800s, verify acceptance
- `TEST` Now button location: Check position on iOS vs Android vs desktop
- `XREF` See [Field Reference > DateTimeNow]
- `XREF` See [Troubleshooting Guide > Critical Issues]
- `VERSION` 2025-08

### DateTimePicker
- `RULE` DISCOURAGED - avoid in multi-timezone projects
- `RULE` No timezone information stored - corrupts multi-site data
- `ERROR` "Synchronisation conflict" = timezone ambiguity between sites
- `QUIRK` Storage format looks like ISO but lacks timezone (2024-03-15T14:30)
- `QUIRK` Same timestamp means different absolute times in different locations
- `QUIRK` type-returned claims DateTime but stores incomplete string
- `FIX` Migrate immediately to DateTimeNow:
  ```javascript
  // Migration script for assumed timezone
  const oldValue = "2024-03-15T14:30";
  const timezone = "+10:00"; // Document your assumption
  const newValue = new Date(oldValue + timezone).toISOString();
  ```
- `FIX` If stuck with legacy, document timezone in field label: "Time (Sydney UTC+10)"
- `TEST` Timezone loss: Save "14:30", export CSV, verify no "Z" or timezone indicator
- `TEST` Cross-site confusion: Enter same time in different locations, compare exports
- `TEST` Migration need: Check if stored values lack timezone information
- `XREF` See [Migration Warnings Index > Safe Migrations]
- `XREF` See [Field Selection Guide > Quick Decision Matrix]
- `VERSION` 2025-08

### DatePicker
- `RULE` Use only when time component genuinely irrelevant
- `RULE` Stores as YYYY-MM-DD string format
- `ERROR` "Invalid Date" after typing = locale mismatch (DD/MM vs MM/DD)
- `QUIRK` Forces day selection even when only month/year known
- `QUIRK` Excel auto-converts to regional format corrupting data
- `QUIRK` No partial date support for historical uncertainty
- `QUIRK` iOS shows full-screen picker blocking form context
- `FIX` For month-year only use MonthPicker instead
- `FIX` For uncertain dates add annotation field:
  ```json
  "date": {"component-name": "DatePicker"},
  "date_certainty": {
    "component-name": "Select",
    "component-parameters": {
      "options": ["Exact", "Approximate", "Before", "After", "Circa"]
    }
  }
  ```
- `FIX` Excel import: use Text Import Wizard, never open CSV directly
- `TEST` Locale issues: Enter 01/02/2024, verify interpretation (Jan 2 vs Feb 1)
- `TEST` Excel corruption: Export dates to CSV, open in Excel, check format changes
- `TEST` iOS picker: Open on iPhone, verify full-screen behavior blocks form
- `XREF` See [Field Reference > DatePicker]
- `XREF` See [Troubleshooting Guide > Excel Date Format Corruption]
- `VERSION` 2025-08

### MonthPicker
- `RULE` Stores as YYYY-MM string format (no day component)
- `RULE` Best choice for avoiding spurious precision
- `ERROR` "3rd March 2024" in Excel = misinterpreted YYYY-MM format
- `QUIRK` Excel interprets 2024-03 as date (3rd March) not month (March 2024)
- `QUIRK` Some browsers show year-month picker, others show calendar
- `QUIRK` No validation for future months (can select 2099-12)
- `FIX` Always import to Excel as Text column:
  ```vba
  ' Excel VBA for correct import
  Columns("A:A").NumberFormat = "@" ' Force text format
  ```
- `FIX` For data processing, parse explicitly:
  ```python
  # Python pandas
  df['year'] = df['month_field'].str[:4].astype(int)
  df['month'] = df['month_field'].str[5:7].astype(int)
  ```
- `FIX` Add helper text: "Select month and year only (day ignored)"
- `TEST` Verify format: Save selection, export should show "YYYY-MM" only
- `TEST` Day appending: Check if "-01" gets added on export or display
- `TEST` Browser support: Test HTML5 month input on Safari, Firefox, Chrome
- `XREF` See [Field Reference > MonthPicker]
- `XREF` See [Troubleshooting Guide > When Format Issues Occur]
- `VERSION` 2025-08

### Common Date/Time Quirks
- `RULE` All date fields use HTML5 native inputs - cannot standardise interface
- `RULE` No BCE date support across any components
- `RULE` Validation limited to required/optional only - no min/max dates
- `ERROR` "Maximum call stack exceeded" = date field in TemplatedString template
- `QUIRK` Platform picker varies dramatically - iOS wheels vs Android calendar
- `QUIRK` Conditional logic uses string comparison not date comparison
- `QUIRK` Firefox allows keyboard entry of invalid dates
- `QUIRK` type-returned declarations misleading - all store as strings
- `FIX` For date ranges implement post-validation:
  ```javascript
  // In annotation or external validation
  const start = new Date(startField);
  const end = new Date(endField);
  if (start >= end) alert("End date must be after start date");
  ```
- `FIX` For BCE dates use TextField with pattern:
  ```json
  "validationSchema": [
    ["yup.matches", "^-?\\d{1,4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$", "Format: YYYY-MM-DD (negative year for BCE)"]
  ]
  ```
- `FIX` Train platform-specific: iOS users swipe wheels, Android users tap calendar
- `XREF` See [Common Characteristics > Platform Behaviors]
- `XREF` See [JSON Examples > Integration Patterns]
- `VERSION` 2025-08

---

## Performance Thresholds Summary {comprehensive}

See [Performance Thresholds Reference](performance-thresholds-reference.md) for detailed metrics and testing scenarios.

**DateTime Field Critical Thresholds**:
- **DateTimeNow**: 100ms timezone conversion overhead per record
- **Memory limit**: ~100 date fields before browser exhaustion (2MB per field)
- **Storage**: DateTimeNow (30 bytes), DatePicker (10 bytes), MonthPicker (7 bytes)
- **Excel limit**: 65,000 rows for CSV compatibility
- **Reliable date range**: 1900-2100 only
- **Form pagination trigger**: >20 date fields per page

`VERSION` 2025-08

---

## Field Interaction Matrix (2025-08) {important}

### Critical Incompatibilities
- `BREAKS` DateTimePicker + Multi-site deployment = Timezone corruption across locations
  - `TEST` Check if any DateTimePicker exists: `grep -r "DateTimePicker" *.json`
  - `ERROR` Same timestamp "2024-03-15T14:30" means 14:30 Sydney vs 14:30 London
  - `FIX` Must migrate to DateTimeNow before multi-site deployment
- `BREAKS` TemplatedString referencing date fields = Shows raw ISO string not formatted date
  - `TEST` Check templates for {{date_field}} references
  - `ERROR` Display shows "2024-03-15T14:30:00.000Z" instead of readable format
  - `FIX` Create display-only field with formatted date or use annotation
- `BREAKS` Date field in conditional logic with non-date comparison = String comparison failure
  - `TEST` Check condition_instructions for date fields with numeric operators
  - `ERROR` "2024-12-01" > "2024-03-15" works but "2024-03-15" > "2024-3-5" fails
  - `FIX` Ensure consistent format YYYY-MM-DD in all comparisons
- `VERSION` 2025-08

### Required Pairings
- `REQUIRED` DateTimeNow with annotation for timezone clarity in multi-timezone teams
  - `VALIDATE` Check all DateTimeNow fields have either annotation or clear helperText
  - `IMPLEMENT`:
    ```json
    "timestamp": {
      "component-name": "DateTimeNow",
      "component-parameters": {
        "helperText": "Enter in your local time (stored as UTC)"
      },
      "meta": {
        "annotation": {
          "include": true,
          "label": "Timezone notes"
        }
      }
    }
    ```
- `REQUIRED` DatePicker with MonthPicker fallback when day precision uncertain
  - `PATTERN` Paired fields for flexible precision:
    ```json
    "precise_date": {
      "component-name": "DatePicker",
      "component-parameters": {
        "label": "Exact date (if known)"
      }
    },
    "approximate_date": {
      "component-name": "MonthPicker",
      "component-parameters": {
        "label": "Month/Year (if day unknown)"
      }
    }
    ```
- `VERSION` 2025-08

---


## JSON Anti-patterns Quick Index {comprehensive}

Anti-patterns have been distributed to their respective field sections for better context locality. This index provides a quick reference:

### Anti-pattern Categories by Field

- **DateTimeNow**: Component namespace, timezone format, Now button behavior ‚Üí [DateTimeNow Anti-patterns](#datetimenow)
- **DateTimePicker**: Deprecation warnings, migration guidance ‚Üí [DateTimePicker Anti-patterns](#datetimepicker)
- **DatePicker**: Date format, ISO 8601 compliance ‚Üí [DatePicker Anti-patterns](#datepicker)
- **MonthPicker**: Month format, YYYY-MM pattern ‚Üí [MonthPicker Anti-patterns](#monthpicker)

### Common Anti-pattern Themes

1. **Component Namespaces**: All datetime components use faims-custom namespace
2. **Date Formats**: ISO 8601 (YYYY-MM-DD) requirements
3. **Timezone Handling**: IANA identifiers, UTC storage
4. **Validation Order**: Type declaration before constraints
5. **Migration Patterns**: Moving from deprecated components

## Quick Diagnosis Tables (2025-08) {comprehensive}

### üî¥ Critical Issues Table

| Symptom | Field | Cause | Immediate Action | Fix | Prevent |
|---------|-------|-------|------------------|-----|---------|
| Times differ across sites | DateTimePicker | No timezone | Stop using field | Migrate to DateTimeNow | Never use DateTimePicker |
| Excel shows "3rd March" | MonthPicker | Format confusion | Import as text | Document as YYYY-MM | Train on import procedure |
| Can't select BCE dates | All date fields | Not supported | Use TextField | Custom validation pattern | Document limitation |
| Auto-time gets changed | DateTimeNow | User editable | Add display field | Paired pattern | Train on purpose |
| Invalid Date appears | All date fields | Locale issue | Use picker only | Avoid manual typing | Platform training |

### üü° Common Problems Table

| Symptom | When | Why | Try This | If That Fails | Long Term |
|---------|------|-----|----------|---------------|-----------|
| UTC confuses users | DateTimeNow | Shows Z time | Add helper text | Local display field | Training |
| No "Now" button | Mobile DateTimeNow | Hidden location | Look bottom-right | Rotate device | Update app |
| Picker covers everything | Mobile all | Full-screen | Scroll or rotate | Zoom out | Desktop version |
| Date won't save | Manual entry | Format wrong | Use picker interface | Clear and retry | Disable typing |
| Month shows as day | Excel import | Auto-convert | Import as text | Document format | Script processing |
| Future dates accepted | All fields | No validation | Add warning text | External validation | Alternative field |

### üü¢ Quick Fixes Table

| Want To | Use This | Not This | Because | Example |
|---------|----------|----------|---------|---------|
| Record current time | DateTimeNow | DateTimePicker | Timezone safety | `"is_auto_pick": true` |
| Allow date flexibility | MonthPicker | DatePicker forced | Avoid false precision | Historical records |
| Protect creation time | TemplatedString | Editable DateTimeNow | Immutable audit | `{{_CREATED_TIME}}` |
| Multi-site timestamps | DateTimeNow | DateTimePicker | UTC synchronisation | Always UTC storage |
| Import to Excel | Text columns | Auto-open CSV | Prevents corruption | Import wizard |
| Handle BCE dates | TextField | Any date field | Not supported | Pattern validation |

`VERSION` 2025-08

---

## Migration Warnings Index (2025-08) {comprehensive}

### Safe Migrations (No Data Loss)

#### DateTimePicker ‚Üí DateTimeNow
- `SAFE WITH PLANNING` Requires timezone documentation
  ```javascript
  // Migration script with explicit timezone
  const migrateDateTime = (oldValue, assumedTimezone = '+10:00') => {
    if (!oldValue) return null;
    // Old format: "2024-03-15T14:30"
    // New format: "2024-03-15T14:30:00.000Z"
    const localDate = new Date(oldValue + assumedTimezone);
    return localDate.toISOString();
  };
  
  // Bulk migration
  records.forEach(record => {
    record.new_datetime = migrateDateTime(record.old_datetime);
  });
  ```
- `VALIDATE` Check timezone consistency across team
- `TEST` Compare sample timestamps with known events
- `ROLLBACK` Keep original field hidden for 30 days:
  ```json
  "old_datetime": {
    "component-name": "DateTimePicker",
    "component-parameters": {"hidden": true}
  }
  ```
- `VERSION` 2025-08

#### DatePicker ‚Üí MonthPicker
- `SAFE` When day precision not required
  ```python
  # Python migration for date to month
  df['month_field'] = df['date_field'].str[:7]  # "2024-03-15" ‚Üí "2024-03"
  ```
- `VALIDATE` Confirm day component truly arbitrary
- `TEST` `SELECT DISTINCT DAY(date_field) FROM records` - if mostly 01 or 15, good candidate
- `DOCUMENT` Note precision reduction in metadata
- `VERSION` 2025-08

### Breaking Changes (Data Loss or Corruption Risk)

#### DateTimeNow ‚Üí DateTimePicker
- `BREAKS` Loses timezone information permanently
- `IMPACT` All UTC times become ambiguous local times
- `DATA LOSS` Cannot determine original timezone after conversion
- `NO ROLLBACK` Timezone information unrecoverable
- `ALTERNATIVE` Keep DateTimeNow, add display field:
  ```json
  "display_local": {
    "component-name": "TemplatedString",
    "component-parameters": {
      "template": "Local: {{datetime_field}}"
    }
  }
  ```
- `VERSION` 2025-08

#### Adding Required to Existing Date Fields
- `BREAKS` Records with null dates become uneditable
- `IMPACT` Historical records locked from updates
- `PRECHECK`:
  ```sql
  SELECT COUNT(*) as null_count 
  FROM records 
  WHERE date_field IS NULL OR date_field = '';
  ```
- `SAFE IF` null_count = 0
- `UNSAFE IF` Any nulls exist
- `ROLLBACK`:
  ```json
  // Remove required immediately
  "validationSchema": [
    ["yup.string"]
    // Remove: ["yup.required", "Date required"]
  ]
  ```
- `VERSION` 2025-08

#### MonthPicker ‚Üí DatePicker
- `BREAKS` Requires inventing day component
- `IMPACT` Creates false precision in historical data
- `MIGRATION REQUIRES POLICY`:
  ```javascript
  // Must decide arbitrary day
  const monthToDate = (monthValue, dayPolicy = '15') => {
    if (!monthValue) return null;
    // "2024-03" ‚Üí "2024-03-15"
    return `${monthValue}-${dayPolicy}`;
  };
  ```
- `DOCUMENT` Record day assignment policy in metadata
- `ETHICAL CONCERN` Introduces spurious precision
- `VERSION` 2025-08

### Conditional Migrations (Context Dependent)

#### Changing Auto-populate Settings
- `CONDITIONAL` is_auto_pick: false ‚Üí true
- `SAFE IF` Want all future records timestamped
- `UNSAFE IF` Existing workflow expects manual entry
- `TEST` Create test record, verify auto-population acceptable
- `ROLLBACK` Simply change back to false
- `VALIDATION`:
  ```javascript
  // Check if users are manually entering different times
  const autoTimes = records.filter(r => {
    const created = new Date(r.datetime);
    const opened = new Date(r._metadata.opened_at);
    return Math.abs(created - opened) < 60000; // Within 1 minute
  });
  console.log(`${autoTimes.length}/${records.length} appear auto-populated`);
  ```
- `VERSION` 2025-08

#### Platform-Specific Format Changes
- `CONDITIONAL` Changing expected date formats based on locale
- `PRECHECK` Audit current formats in database:
  ```python
  # Check format consistency
  formats = df['date_field'].str.extract(r'^(\d{4})-(\d{1,2})-(\d{1,2})')
  inconsistent = formats[1].str.len() != 2 | formats[2].str.len() != 2
  print(f"Inconsistent formats: {inconsistent.sum()}")
  ```
- `SAFE IF` All dates already in YYYY-MM-DD
- `UNSAFE IF` Mixed formats exist
- `FIX` Standardise before migration:
  ```python
  # Standardise to YYYY-MM-DD
  df['date_field'] = pd.to_datetime(df['date_field']).dt.strftime('%Y-%m-%d')
  ```
- `VERSION` 2025-08

#### Excel Integration Changes
- `CONDITIONAL` Changing from direct Excel edit to import-only
- `IMPACT` Workflow change for data managers
- `TEST` Export sample, attempt reimport:
  ```python
  # Test round-trip integrity
  df_export = df[['date_field', 'month_field']]
  df_export.to_csv('test.csv', index=False)
  df_import = pd.read_csv('test.csv', dtype=str)  # Force string type
  
  # Verify no corruption
  assert df_export.equals(df_import), "Date corruption detected"
  ```
- `SAFE IF` Team trained on text import procedures
- `UNSAFE IF` Relying on Excel auto-formatting
- `VERSION` 2025-08

### Emergency Rollback Procedures

#### Corrupted Timezone Data
- `SYMPTOMS` Times off by hours, sync conflicts
- `IMMEDIATE`:
  ```sql
  -- Identify affected records
  SELECT * FROM records 
  WHERE datetime_field NOT LIKE '%Z'
  AND datetime_field NOT LIKE '%+%';
  ```
- `ROLLBACK` Restore from pre-migration backup
- `IF NO BACKUP` Apply timezone correction:
  ```python
  # Emergency timezone fix
  from datetime import datetime, timezone, timedelta
  
  def emergency_fix(dt_string, hours_offset):
      dt = datetime.fromisoformat(dt_string.replace('Z', ''))
      dt_utc = dt - timedelta(hours=hours_offset)
      return dt_utc.isoformat() + 'Z'
  ```
- `VERSION` 2025-08

#### Performance Degradation
- `SYMPTOMS` Form loading >5 seconds with date fields
- `DIAGNOSTIC`:
  ```javascript
  // Count date field operations
  const dateFields = document.querySelectorAll('[type="datetime-local"], [type="date"], [type="month"]');
  console.log(`Date fields on page: ${dateFields.length}`);
  ```
- `ROLLBACK` Paginate forms if >100 date fields
- `QUICK FIX` Disable auto-populate temporarily:
  ```json
  "is_auto_pick": false  // Reduces load-time calculations
  ```
- `VERSION` 2025-08

---

## JSON Patterns Cookbook (2025-08) {comprehensive}

### DateTimeNow Patterns

```json
// BASE PATTERN (recommended default for all timestamps)
{
  "component-namespace": "faims-custom",
  "component-name": "DateTimeNow",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "timestamp-field",  // MUST match field ID
    "label": "Timestamp"
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""  // MUST be "" not null
}

// VARIANT: Auto-populated creation timestamp
+ "component-parameters": {
+   "is_auto_pick": true,  // Auto-fills on form open
+   "helperText": "Automatically captured (UTC)",
+   "fullWidth": true
+ }
+ "validationSchema": [
+   ["yup.string"],
+   ["yup.required", "Timestamp required"]
+ ]

// VARIANT: Manual timestamp with annotation
+ "component-parameters": {
+   "is_auto_pick": false,
+   "helperText": "Click 'Now' for current time",
+   "required": true
+ }
+ "meta": {
+   "annotation": {
+     "include": true,
+     "label": "Time notes (timezone, accuracy)"
+   }
+ }

// VARIANT: Protected auto-timestamp (prevents accidental edit)
+ "component-parameters": {
+   "is_auto_pick": true,
+   "disabled": true  // Read-only after creation
+ }
```

#### DateTimeNow ANTI-PATTERNS ‚ö†Ô∏è
```json
// ‚ùå NEVER: Null initialValue
{
  "initialValue": null  // ERROR: "Cannot read property 'toISOString' of null"
}

// ‚ùå NEVER: Missing timezone documentation
{
  "component-parameters": {
    "label": "Time"  // Users don't know if UTC or local!
    // FIX: Add helperText explaining timezone handling
  }
}

// ‚ùå NEVER: Auto-populate without user awareness
{
  "is_auto_pick": true,
  "component-parameters": {
    "label": "Date"  // Users may not realize it auto-fills
    // FIX: Add helperText: "Auto-captured on form open"
  }
}
```

### DateTimePicker Patterns (DISCOURAGED - Use DateTimeNow Instead)

```json
// BASE: Legacy only - migrate ASAP!
{
  "component-namespace": "faims-custom",
  "component-name": "DateTimePicker",  // ‚ö†Ô∏è DISCOURAGED - lacks timezone
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "legacy-datetime",
    "label": "Time (Legacy)",
    "helperText": "‚ö†Ô∏è No timezone - ambiguous timestamp"
  }
}

// MIGRATION PATH: Convert to DateTimeNow
{
- "component-name": "DateTimePicker",
+ "component-name": "DateTimeNow",
  "component-parameters": {
    "helperText": "Enter in your local time, stored as UTC"
  }
}
```

## Error Message Quick Reference {important}

### Common Validation Errors (User Visible)
| Message | Component | Trigger | Resolution |
|---------|-----------|---------|------------|
| "Invalid date" | All date fields | Malformed input | Use picker interface |
| "Field is required" | All date fields | Empty submission | Select a date |
| "Date must be in the past" | DateTimeNow | Future date blocked | Select past date |
| "Invalid format" | DatePicker | Manual typing | Use calendar picker |

### Platform-Specific Issues
| Issue | Platform | Component | Workaround |
|-------|----------|-----------|------------|
| Different picker UI | iOS vs Android | All fields | Train on both platforms |
| "Now" button hidden | Desktop browsers | DateTimeNow | Scroll in picker |
| Timezone not shown | Mobile | DateTimePicker | Check device settings |
| Month format varies | Excel import | MonthPicker | Use Text Import Wizard |

### Silent Failures (No Error Shown)
| Issue | Component | Detection | Prevention |
|-------|-----------|-----------|------------|
| Wrong timezone saved | DateTimePicker | Check UTC offset | Use DateTimeNow |
| Excel date corruption | All fields | Wrong date shown | Import as text |
| BCE dates rejected | All fields | Negative years fail | Use number fields |
| Milliseconds lost | DateTimeNow | Precision loss | Document limitation |

---

## See Also {comprehensive}

### Other Field Categories
- **Text Fields**: For manual date entry with validation patterns
- **Number Fields**: For year-only entry or BCE date recording  
- **Select/Choice Fields**: For period taxonomies and controlled date vocabularies (see Periodo)
- **Media Fields**: For timestamp metadata on photographs
- **Location Fields**: For timezone-aware coordinate recording

### Reference Documents
- [Validation Timing Reference](../reference-docs/validation-timing-reference.md)
- [Component Namespace Reference](../reference-docs/component-namespace-reference.md)
- [Data Export Reference](../reference-docs/data-export-reference.md)
- [Security Considerations Reference](../reference-docs/security-considerations-reference.md)
- [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md)
- [Meta Properties Reference](../reference-docs/meta-properties-reference.md)
- [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md)

### External Resources
- **TemplatedString**: For immutable timestamp display using `{{_CREATED_TIME}}`
- **External Vocabularies**: 
  - Periodo (periodo.github.io) for archaeological/historical periods
  - Getty AAT for hierarchical chronological terms
  - Heritage Data vocabularies for regional chronologies

## Metadata {comprehensive}

**Documentation Version**: 2025-08 v2.1 (Designer Integration)  
**Components**: DateTimeNow, DateTimePicker, DatePicker, MonthPicker  
**Platform Version**: Fieldmark 2025  
**Last Updated**: August 2025  
**Status**: Complete consolidated documentation with restored content  
**Template Compliance**: 100% (all required sections present)

### Component Status Summary
- **Production Ready**: DateTimeNow, DatePicker, MonthPicker
- **DISCOURAGED**: DateTimePicker (timezone ambiguity risk - use with caution)
- **Beta Features**: None
- **Mobile-Only Features**: None (all work cross-platform with UI variations)
- **Display-Only**: None (all capture data)
- **JSON-Only Configuration**: All date fields require JSON editing for full configuration

### Documentation Coverage
- **Designer Capabilities**: ‚úÖ Basic field creation
- **JSON Enhancement**: ‚úÖ All configuration options documented
- **Platform Variations**: ‚úÖ Comprehensive platform behavior matrix
- **Known Issues**: ‚úÖ All quirks and limitations documented
- **Migration Paths**: ‚úÖ Complete migration procedures with code examples
- **Performance Metrics**: ‚úÖ Specific thresholds and optimization strategies documented
- **Training Materials**: ‚úÖ Role-specific curricula with checklists
- **Alternative Approaches**: ‚úÖ Complex temporal requirements addressed

### Quality Verification
- ‚úî All 4 fields documented completely with keywords
- ‚úî Every section has appropriate depth tags {essential/important/comprehensive}
- ‚úî Security warnings prominent (validation poverty, timezone risks)
- ‚úî Platform limitations clearly marked with tables
- ‚úî Deprecation status noted for DateTimePicker with migration path
- ‚úî Structure follows standardized template matching Text Fields
- ‚úî Common characteristics reorganized hierarchically
- ‚úî All field names tagged {essential} for navigation
- ‚úî Keywords added for searchability
- ‚úî Purpose statements comprehensive for each field
- ‚úî Field-specific troubleshooting tables for all fields
- ‚úî **Content restoration complete** (v2.0 includes all missing sections)
- ‚úî Clear navigation with consistent depth indicators
- ‚úî Testing guidelines tagged {comprehensive}
- ‚úî All cross-references validated and working
- ‚úî Accessibility compliance section added
- ‚úî Export behavior comprehensively documented
- ‚úî Version markers (2025-08) consistent throughout

### Revision History
- **v1.0 Stage 1-2**: Cross-references fixed, title updated
- **v1.0 Stage 3**: Common Characteristics reorganized (content loss occurred)
- **v1.0 Stage 4-5**: Individual fields enhanced, metadata expanded
- **v2.0**: Content restoration - recovered all missing sections:
  - Error Message Reference added to Troubleshooting
  - Migration Script Templates added with 3 complete templates
  - Platform-Specific Configurations added to JSON Patterns
  - Training Requirements expanded with detailed curricula
  - Alternative Approaches section fully restored
  - Performance optimization details enhanced
- **v2.1**: Designer integration improvements:
  - Designer labels added to all field headings
  - Configuration notes specify Designer vs JSON capabilities
  - Ready for Designer Capabilities section addition

### Content Restoration Note
Version 2.0 restores approximately 30% of technical implementation details that were inadvertently dropped during the Stage 3 reorganization. All missing content has been recovered and integrated into the improved hierarchical structure while maintaining consistency with the Text Fields documentation format.

### Known Limitations Documented
1. No temporal validation beyond required/optional
2. No BCE date support
3. Platform picker variance cannot be configured
4. String storage despite type declarations
5. Excel date corruption on direct CSV open
6. DateTimePicker timezone ambiguity (discouraged)
7. MonthPicker Excel misinterpretation

### Critical Warnings Highlighted
- ‚ö†Ô∏è NEVER use DateTimePicker in new projects
- ‚ö†Ô∏è ALWAYS import Excel as text to prevent corruption
- ‚ö†Ô∏è UTC storage may confuse users (training required)
- ‚ö†Ô∏è No validation for date ranges or temporal constraints
---

## Related Documentation
<!-- concat:references -->

### Within Field Categories
- **Previous**: [Selection Fields](./select-choice-fields-v05.md) | [#selection-fields](#selection-fields)
- **Next**: [Numeric Fields](./number-fields-v05.md) | [#number-fields](#number-fields)

### Cross-Field Patterns
- **Validation**: [Date Validation](../detail-crossfield-docs/validation.md#datetime-fields) | [#validation-patterns](#validation-patterns)
- **Conditional Logic**: [Date-based Conditions](../detail-crossfield-docs/conditional-logic.md#datetime-fields) | [#conditional-logic](#conditional-logic)
- **Best Practices**: [Temporal Data](../detail-crossfield-docs/field-selection-best-practices.md#datetime-fields) | [#field-selection](#field-selection)

### Technical References
- **Designer Limitations**: [DateTime Constraints](../reference-docs/designer-limitations-reference.md#datetime-fields) | [#designer-limitations](#designer-limitations)
- **Platform Behaviors**: [Timezone Handling](../reference-docs/platform-behaviors-reference.md#datetime-fields) | [#platform-behaviors](#platform-behaviors)
- **Performance**: [Date Processing](../reference-docs/performance-thresholds-reference.md#datetime-fields) | [#performance-thresholds](#performance-thresholds)

<!-- /concat:references -->
<!-- concat:boundary:end section="datetime-fields" -->


<!-- concat:document:number-fields-v05 -->
<!-- concat:boundary:start section="number-fields" -->
<!-- concat:metadata
document_id: number-fields-v05
category: numeric
field_count: 3
designer_capable: ["NumberField"]
json_only: ["BasicAutoIncrementer", "step_increments"]
last_updated: 2025-01-05
-->

# Number Input Fields

## Document Navigation
<!-- concat:nav-mode:individual -->
[‚Üê Date & Time Fields](./datetime-fields-v05.md) | **Numeric Fields** | [Display Fields ‚Üí](./display-field-v05.md)
<!-- concat:nav-mode:concatenated -->
<!-- When viewing in reference.md: [‚Üë Top](#fieldmark-v3-field-type-documentation-index) | [Display Fields ‚Üì](#display-fields) -->

# Number Input Fields

## Overview {essential}

The Number Input category encompasses three distinct field types for numeric and sequential data management in Fieldmark, each serving fundamentally different purposes despite their shared categorization.

## Component Name Mapping {essential}

| Designer UI Label | JSON component-name | Namespace | Code File | Description |
|------------------|-------------------|-----------|-----------|-------------|
| Number Field | NumberField | faims-custom | NumberField.tsx | Numeric input with validation |
| Basic Auto Incrementer | BasicAutoIncrementer | faims-custom | BasicAutoIncrementer.tsx | Auto-incrementing counter |

### Critical Naming Issues {important}
- **ControlledNumber absence**: Referenced in docs but is actually TextField with type="number"
- **Step increment confusion**: Cannot set step increments in Designer, use BasicAutoIncrementer instead
- **TextField variant**: "Controlled Number" is TextField (formik-material-ui) with numeric configuration
- **Namespace discrepancy**: All number fields use faims-custom namespace


### Components in this Category
- **Number Input** (NumberField in JSON) - Standard floating-point numeric entry
- **Controlled Number** - Designer-accessible bounded numeric input  
- **Basic Auto-incrementer** - Sequential string identifier generator

### DESIGNER QUICK GUIDE

**For Standard Numeric Values**: Choose "Number Input" - handles decimals, measurements, counts
**For Bounded Values**: Choose "Controlled Number" - includes sliders, min/max validation  
**For Sequential IDs**: Choose "Basic Auto-incrementer" - generates "BAI-001" style strings
**NEVER Use**: "Number Field" (deprecated) - appears in Designer but has known issues

**Critical iOS Warning**: No direct negative number entry on iOS - users must copy-paste negative values

### CRITICAL NAMING DISAMBIGUATION

‚ö†Ô∏è **CONFUSING NAMES - READ CAREFULLY**:

- ‚úÖ **"Number Input"** (Designer label) ‚Üí Creates `NumberField` component (recommended)
- ‚ùå **"Number Field"** (Designer label) ‚Üí Creates deprecated `TextField` component (avoid)
- üìä **"Controlled Number"** (Designer label) ‚Üí Creates `TextField` with numeric configuration (formik-material-ui namespace, NOT a separate component)
- üî§ **"Basic Auto-incrementer"** ‚Üí Creates `BasicAutoIncrementer` (returns STRINGS, not numbers)

The naming confusion exists because:
1. "Number Input" was created to replace the problematic "Number Field", but the JSON component name stayed as `NumberField` for backwards compatibility
2. "Controlled Number" isn't actually a distinct component but rather a pre-configured TextField with bounded validation

### Field Capabilities Summary

Number fields provide numeric data entry with three specialized approaches: unrestricted decimal input (NumberInput), bounded validation with UI controls (ControlledNumber), and sequential string identifier generation (BasicAutoIncrementer). All support offline operation and cross-platform deployment, with iOS limitations on negative number entry requiring alternative input methods.

### Historical Context {important}

The three-field structure reflects Fieldmark's evolution from simpler numeric inputs to better-formed inputs and complex identification systems:

1. **NumberField (deprecated)** - Original implementation with poor null handling and other problems
2. **NumberInput** - Resolved null ambiguities, maintains flexibility  
3. **ControlledNumber** - Designer accessibility compromise for non-technical users
4. **BasicAutoIncrementer** - Sequential ID solution for offline-capable systems

The **component name paradox** (NumberInput using "NumberField" in JSON) results from backwards compatibility requirements when the deprecated NumberField was replaced. Changing the JSON component name would break existing notebooks, so the display name was changed while preserving the technical implementation.

The **type mismatches** (ControlledNumber declaring Integer but accepting decimals, BasicAutoIncrementer in "Number Fields" but returning strings) reflect the Designer interface's limitations in representing complex type systems to non-technical users.

### Component Status Summary {essential}

| Component | Maturity | iOS Support | Offline | Known Issues | Recommended |
|-----------|----------|-------------|---------|--------------|-------------|
| NumberInput | Stable | ‚ö†Ô∏è No minus key | ‚úÖ Full | üü° 7 medium | ‚úÖ Yes |
| ControlledNumber | Stable | ‚ö†Ô∏è No minus key | ‚úÖ Full | üî¥ Type mismatch | ‚ö†Ô∏è Conditional |
| BasicAutoIncrementer | Stable | ‚úÖ Full | ‚úÖ With ranges | üî¥ No duplicate detection | ‚ö†Ô∏è With protocols |

## Designer Usage Guide {essential}

### What to Select in Designer

When using the Designer interface, follow these simple rules:

üî¢ **For numeric measurements and calculations**: Select **"Number Input"**
- Use for: measurements, counts, ratings, scientific data
- Creates: NumberField component (note the name mismatch)
- ‚ö†Ô∏è iOS users cannot enter negative numbers directly (must copy-paste)

üìä **For bounded numeric values**: Select **"Controlled Number"**
- Use for: ratings (1-5), scores (0-100), bounded measurements
- Creates: ControlledNumber component with min/max enforcement
- Provides slider interface in addition to text input

üî§ **For sequential identifiers**: Select **"Basic Auto-incrementer"**
- Use for: sample IDs, context numbers, sequential codes
- Creates: BasicAutoIncrementer (returns STRING not number)
- ‚ö†Ô∏è Must be wrapped in TemplatedString to prevent Excel corruption

‚ùå **NEVER select "Number Field"** (deprecated)
- This legacy option still appears in Designer but should not be used
- Always choose "Number Input" instead for numeric data

### Quick Reference Table

| Designer Label | JSON component-name | Returns | Designer Config | Key Purpose |
|----------------|-------------------|---------|-----------------|-------------|
| üî¢ **Number Input** | `NumberField`* | Number | Partial | Measurements, calculations |
| üìä **Controlled Number** | `ControlledNumber` | Number** | Full | Bounded values, ratings |
| üî§ **Basic Auto-incrementer** | `BasicAutoIncrementer` | String*** | Full | Sequential IDs |

*‚ö†Ô∏è **Component name paradox**: Designer shows "Number Input" but JSON requires "NumberField"  
**‚ö†Ô∏è **Type mismatch**: Declares Integer but accepts/stores decimals  
***‚ö†Ô∏è **Critical**: Returns strings not numbers despite "Number Fields" category  
****Note: Do not confuse with deprecated "Number Field" - always use "Number Input"**

### When JSON Enhancement is Required

**NumberInput**:
- ‚úÖ Required: Range validation, decimal precision, integer-only
- ‚úÖ Required: Custom error messages
- ‚ùå Never: Step increments not supported (use BasicAutoIncrementer instead)

**ControlledNumber**:
- ‚ö†Ô∏è Optional: Additional validation beyond min/max
- ‚ö†Ô∏è Optional: True integer enforcement
- ‚ö†Ô∏è Optional: Custom error messages

**BasicAutoIncrementer**:
- ‚úÖ Required: Custom validation patterns
- ‚ùå Never: Core functionality fully Designer-accessible
- ‚ùå Never: Integration with TemplatedString works in Designer

### Designer Limitations {important}

[Link to Designer Limitations Reference](../reference-docs/designer-limitations-reference.md)

**Number Field-Specific Designer Limitations**:
- **NumberInput**: Cannot set range validation (min/max) through Designer
- **NumberInput**: Cannot configure decimal precision or integer-only mode
- **All fields**: Cannot add custom validation messages
- **All fields**: Cannot configure input masks or formatting patterns

### ‚ö†Ô∏è CRITICAL: Deprecated Field Warning {essential}

**DO NOT USE "Number Field" (deprecated)** - A legacy numeric field type still appears in the Designer interface labeled as "Number Field". This deprecated field:
- Uses `formik-material-ui:TextField` with `type="number"` in JSON
- Returns `faims-core::Integer` despite accepting decimals
- Has poor null handling (uses empty string instead of null)
- **Should be replaced with "Number Input" in all new notebooks**

**The confusion**: 
- ‚ùå **Number Field** (deprecated) - Do not use
- ‚úÖ **Number Input** (recommended) - Use this instead
- ‚ö†Ô∏è Note: Number Input confusingly uses `"NumberField"` as its JSON component-name

If you see "Number Field" in Designer, always choose "Number Input" instead. Existing notebooks using the deprecated Number Field should be migrated to Number Input for better data integrity.

## Field Selection Guide {essential}

### Decision Tree

```
Need numeric/sequential functionality?
‚îú‚îÄ Need actual numeric values for calculations?
‚îÇ  ‚îú‚îÄ YES ‚Üí Need range validation?
‚îÇ  ‚îÇ  ‚îú‚îÄ Can edit JSON?
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ YES ‚Üí NumberInput
‚îÇ  ‚îÇ  ‚îÇ     ‚îú‚îÄ Returns: faims-core::Number
‚îÇ  ‚îÇ  ‚îÇ     ‚îî‚îÄ Full validation control
‚îÇ  ‚îÇ  ‚îî‚îÄ Designer only?
‚îÇ  ‚îÇ     ‚îî‚îÄ YES ‚Üí ControlledNumber
‚îÇ  ‚îÇ        ‚îú‚îÄ Returns: faims-core::Number
‚îÇ  ‚îÇ        ‚îî‚îÄ Min/max in Designer
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ NO ‚Üí Need sequential identifiers?
‚îÇ     ‚îî‚îÄ YES ‚Üí BasicAutoIncrementer
‚îÇ        ‚îú‚îÄ Returns: faims-core::String (with zeros)
‚îÇ        ‚îú‚îÄ Format: "00001", "00002", etc.
‚îÇ        ‚îî‚îÄ ‚ö†Ô∏è Excel strips leading zeros
‚îÇ
‚îî‚îÄ Need specific numeric format?
   ‚îú‚îÄ Scientific notation? ‚Üí NumberInput
   ‚îÇ  ‚îî‚îÄ Supports 1.23e-7 format
   ‚îú‚îÄ Leading zeros? ‚Üí BasicAutoIncrementer
   ‚îÇ  ‚îî‚îÄ Or TemplatedString wrapper
   ‚îî‚îÄ Negative on iOS? ‚Üí TextField with pattern
      ‚îî‚îÄ ‚ö†Ô∏è iOS keyboard lacks minus key
```

### Decision Matrix

| Requirement | NumberInput | ControlledNumber | BasicAutoIncrementer |
|-------------|------------|------------------|---------------------|
| **Calculations** | ‚úÖ Best | ‚úÖ Yes | ‚ùå No (strings) |
| **Null values** | ‚úÖ Yes | ‚ùå No | ‚ùå No |
| **Designer bounds** | ‚ùå JSON only | ‚úÖ Native | N/A |
| **Sequential IDs** | ‚ùå No | ‚ùå No | ‚úÖ Purpose-built |
| **Excel safety** | ‚úÖ Standard | ‚úÖ Standard | ‚ö†Ô∏è Needs wrapper |
| **iOS negatives** | ‚ùå Copy-paste | ‚ùå Copy-paste | ‚úÖ N/A |

### Selection Strategy

1. **Default to NumberInput** for maximum flexibility and null support
2. **Use ControlledNumber** when Designer-only and bounds needed
3. **Deploy BasicAutoIncrementer** for sequential IDs (wrap with TemplatedString for Excel)
4. **Consider TextField with pattern** for iOS negative number entry
5. **Avoid scientific notation** unless specifically required

**Platform Considerations**:
- iOS: No minus key on number keyboard, use copy-paste
- Android: Full numeric keyboard available
- Desktop: Browser spinners ~20√ó20px (too small)
- Excel: Strips leading zeros, corrupts large numbers

**Accessibility Requirements**:
- Spinner controls far below 44px WCAG minimum
- Generic "must be number" errors unhelpful
- No aria-live regions for validation
- Consider larger touch targets via CSS

## ‚ö†Ô∏è Critical Security Risks {essential}

**Silent Precision Loss**:
- **Risk**: Values beyond 15-17 significant digits silently truncated
- **Impact**: Scientific data corruption, financial calculation errors
- **Example**: 9007199254740993 becomes 9007199254740992
- **Mitigation**: Document precision limits, use string fields for IDs

**iOS Negative Number Entry**:
- **Risk**: Cannot enter negative values on iOS numeric keyboard
- **Impact**: Data collection failure, workaround confusion
- **Mitigation**: Provide TextField alternative or document copy-paste method
- **Training**: Essential for field teams using iOS devices

**Excel ID Corruption**:
- **Risk**: Excel converts numeric IDs (strips leading zeros, scientific notation)
- **Impact**: Specimen ID "0001234" becomes "1234", data linkage broken
- **Mitigation**: Always use BasicAutoIncrementer for IDs, not NumberInput
- **Export**: Wrap in TemplatedString for Excel protection

---

## What These Fields Cannot Do {important}

### Numeric Processing Limitations {important}
- **Complex calculations** - No formulas or expressions (e.g., field1 + field2)
- **Unit conversion** - Cannot convert between units automatically
- **Currency formatting** - No thousand separators or currency symbols
- **Percentage display** - Cannot show as percentage (stores decimal)
- **Fraction input** - Cannot enter or display fractions (e.g., 1/3)

### Validation Limitations {important}
- **Cross-field validation** - Cannot validate sum across multiple fields
- **Dynamic ranges** - Cannot set min/max based on other fields
- **Custom increments** - Cannot enforce specific step values (use BasicAutoIncrementer for sequential steps)
- **Precision validation** - Cannot enforce exact decimal places
- **Business rules** - No complex validation logic (e.g., "if X then Y must be > Z")

### Display Limitations {important}
- **Formatted display** - No comma separators (1,000,000)
- **Scientific notation control** - Cannot prevent auto-conversion at 1e7
- **Leading zeros** - NumberInput strips them (use BasicAutoIncrementer)
- **Custom number formats** - No phone numbers, credit cards, etc.
- **Negative number entry** - iOS keyboard lacks minus key

### Integration Limitations {important}
- **External sensor input** - No direct Bluetooth/USB sensor integration
- **Barcode scanning** - Cannot scan numeric barcodes (use QRCodeFormField)
- **Voice calculation** - Cannot process "add five to previous value"
- **Complex calculations** - No in-field formulas or computed values
- **Unit conversions** - No automatic conversion between units

## Common Use Cases {important}

### Measurements and Observations
- **Dimensions** ‚Üí NumberInput with min: 0, precision helper text
- **Counts** ‚Üí NumberInput with integer validation
- **Percentages** ‚Üí NumberInput with min: 0, max: 100
- **Ratings** ‚Üí ControlledNumber with defined scale (1-5, 1-10)

### Scientific Data
- **Coordinates** ‚Üí NumberInput with high precision (6+ decimals)
- **Temperature** ‚Üí NumberInput (allows negatives)
- **pH values** ‚Üí NumberInput with min: 0, max: 14
- **Concentrations** ‚Üí NumberInput with scientific notation support

### Identifiers and Codes
- **Sequential IDs** ‚Üí BasicAutoIncrementer (zero-padded strings)
- **Sample numbers** ‚Üí BasicAutoIncrementer + TemplatedString wrapper
- **Plot numbers** ‚Üí NumberInput if calculations needed
- **Reference codes** ‚Üí BasicAutoIncrementer for Excel safety

### Data Quality Patterns
- **Optional measurements** ‚Üí NumberInput with `nullable()` validation
- **Bounded values** ‚Üí ControlledNumber for strict ranges
- **Excel-safe IDs** ‚Üí BasicAutoIncrementer (prevents number conversion)
- **Precision documentation** ‚Üí Helper text stating decimal places

## Designer Component Mapping {essential}

### Designer UI vs JSON Component Names

| Designer UI Label | JSON component-name | Component Namespace | Description |
|-------------------|---------------------|---------------------|-------------|
| Number Input | NumberField | faims-custom | Standard numeric input with validation |
| Controlled Number | ControlledNumber | faims-custom | Bounded numeric with slider |
| Basic Auto-incrementer | BasicAutoIncrementer | faims-custom | Sequential ID generator (returns string) |
| ~~Number Field~~ | ~~TextField~~ | ~~formik-material-ui~~ | **DEPRECATED - Do not use** |

‚ö†Ô∏è **Critical Notes**:
- "Number Input" in Designer creates "NumberField" in JSON - this name mismatch is a common error source
- "Number Field" (deprecated) still appears in Designer - always use "Number Input" instead
- BasicAutoIncrementer returns `faims-core::String`, not numbers despite being in "Number Fields"
- All number fields use namespace "faims-custom" except the deprecated Number Field
- Designer cannot configure iOS negative number workarounds - requires JSON

### Designer Configuration Options

| Designer Option | JSON Parameter | Values | Description |
|-----------------|---------------|---------|-------------|
| Label | `label` | string | Field display name |
| Required | `validationSchema` | `[["yup.required"]]` | Makes field mandatory |
| Helper Text | `helperText` | string | Guidance text below field |
| Min Value | `component-parameters.min` | number | Minimum allowed value |
| Max Value | `component-parameters.max` | number | Maximum allowed value |
| Initial Value | `initialValue` | number/0 | Default value when field loads |
| Form ID | `component-parameters.form_id` | string | For BasicAutoIncrementer prefix |
| Digit Count | `component-parameters.numDigits` | number | ID padding (001 vs 00001) |

## Designer Capabilities vs JSON Enhancement {essential}

### What Designer Can Configure {essential}

For complete meta properties documentation (annotation, uncertainty, persistence), see [Meta Properties Reference](meta-properties-reference.md).

| Field | Designer Configurable | JSON-Only Features |
|-------|----------------------|-------------------|
| **NumberInput** | ‚Ä¢ Label<br>‚Ä¢ Required<br>‚Ä¢ Helper text<br>‚Ä¢ Initial value<br>‚Ä¢ Persistent | ‚Ä¢ Min/max bounds<br>‚Ä¢ Decimal precision<br>‚Ä¢ Integer enforcement<br>‚Ä¢ Custom validation<br>‚Ä¢ Step increments |
| **ControlledNumber** | ‚Ä¢ Label<br>‚Ä¢ Required<br>‚Ä¢ Helper text<br>‚Ä¢ Min/max bounds<br>‚Ä¢ Initial value (0) | ‚Ä¢ Integer enforcement<br>‚Ä¢ Custom validation<br>‚Ä¢ Step increments<br>‚Ä¢ Alternative initial |
| **BasicAutoIncrementer** | ‚Ä¢ Label<br>‚Ä¢ Form ID<br>‚Ä¢ Digit count<br>‚Ä¢ Helper text | ‚Ä¢ Validation patterns<br>‚Ä¢ Custom formatting<br>‚Ä¢ Integration setup |


## Component Namespace Errors {important}

See [Component Namespace Reference](component-namespace-reference.md) for complete namespace documentation, error troubleshooting, and Designer name mapping.

### Number Field-Specific Notes

**All number fields use the same namespace**:
- Namespace: `faims-custom` for ALL number components
- Exception: Deprecated "Number Field" uses `formik-material-ui:TextField` with type="number"

**Quick Reference for Number Fields**:
| Component | Namespace | Designer Name | Notes |
|-----------|-----------|---------------|-------|
| NumberField | `faims-custom` | Number Input | Primary numeric field |
| BasicAutoIncrementer | `faims-custom` | Auto-incrementer | Returns string, not number |
| ControlledNumber | `faims-custom` | Controlled Number | Designer-only abstraction |

**Common confusion**: 
- Designer shows "Number Input" but JSON requires "NumberField"
- BasicAutoIncrementer returns strings like "BAI-001", not numbers


## When to Use These Fields {essential}

### Field Selection Matrix

| Use Case | Recommended Field | Why |
|----------|------------------|-----|
| General numeric input | NumberField | Full validation support |
| Sequential IDs | BasicAutoIncrementer | Auto-increment |
| Controlled input | TextField with type="number" | When NumberField insufficient |

### Decision Criteria
- **Auto-generation**: Needed ‚Üí BasicAutoIncrementer
- **Validation complexity**: Simple ‚Üí NumberField, Complex ‚Üí TextField variant
- **Step increments**: Not in Designer ‚Üí Use BasicAutoIncrementer
- **Display format**: Standard ‚Üí NumberField, Custom ‚Üí BasicAutoIncrementer

## Common Characteristics {important}

### Configuration Rules {important}

#### Base Properties [affects: All fields] {important}

| Property | Type | Required | NumberInput | ControlledNumber | BasicAutoIncrementer |
|----------|------|----------|------------|------------------|---------------------|
| `name` | string | Yes | Field ID | Field ID | Field ID |
| `type` | string | Yes | `"faims-core::Number"` | `"faims-core::Integer"`* | `"faims-core::String"` |
| `component-name` | string | Yes | `"NumberField"`** | `"ControlledNumber"` | `"BasicAutoIncrementer"` |
| `label` | string | Yes | User label | User label | User label (hidden) |
| `initialValue` | varies | No | `null` | `0` | `""` (auto) |
| `persistent` | boolean | No | `true` | `true` | `true` |
| `required` | boolean | No | `false` | `false` | `false` |

*Accepts decimals despite Integer declaration  
**Component name paradox

### Data Type Specifications {important}

#### IEEE 754 Floating-Point Representation [affects: NumberInput, ControlledNumber] {important}

NumberInput and ControlledNumber use JavaScript's double-precision floating-point, providing approximately 15-17 significant decimal digits of precision. Values exceeding ¬±1.8 √ó 10¬≥‚Å∞‚Å∏ overflow to Infinity and cannot be stored. This implementation inherits both the capabilities (scientific notation support, broad range) and limitations (precision loss, rounding errors) of the IEEE 754 standard.

| Characteristic | Specification | Practical Impact |
|---------------|--------------|------------------|
| **Precision** | 15-17 significant decimal digits | Silent truncation beyond this |
| **Max Safe Integer** | ¬±9,007,199,254,740,991 | Integers above lose precision |
| **Range** | ¬±5.0 √ó 10‚Åª¬≥¬≤‚Å¥ to ¬±1.8 √ó 10¬≥‚Å∞‚Å∏ | Overflow to ¬±Infinity |
| **Special Values** | Infinity, -Infinity, NaN | Validation must handle these |
| **Smallest Increment** | ~2.22 √ó 10‚Åª¬π‚Å∂ at 1.0 | Rounding errors accumulate |

**Storage Implications**:
- 64-bit (8 bytes) per number in memory
- Null requires explicit storage (not zero)
- Scientific notation stored as string representation

### Validation Patterns {important}
See [Validation System Documentation](../detail-crossfield-docs/validation.md) for comprehensive validation patterns and timing.

**Number Field-Specific Validation:**

```json
// Decimal precision check (unique to numbers)
"validationSchema": [
  ["yup.number"],
  ["yup.test", "decimal-places", "Maximum 2 decimal places",
    "value => value == null || Number.isInteger(value * 100)"]
]

// Range validation (NumberInput JSON-only)
"validationSchema": [
  ["yup.number"],
  ["yup.min", 0, "Value must be non-negative"],
  ["yup.max", 100, "Value cannot exceed 100"]
]
```

**BasicAutoIncrementer-Specific**:
- Validates as STRING not number (e.g., "00150" not 150)
- String comparison issues: "0150" < "0099" returns TRUE

**Dual Validation Systems**:
- **HTML5 constraints**: Check immediately on keystroke (min, max, step)
- **Yup validation**: Runs per standard timing (mount, change, blur, submit)
- **Parse attempts**: Every keystroke attempts numeric parsing

**Performance Considerations**:
- Complex test functions impact responsiveness
- >10 validation rules cause noticeable lag  
- Consider debouncing for real-time validation
- Batch validation for related fields

### Voice Input Requirements {important}

#### Voice Dictation Formats [affects: NumberInput, ControlledNumber] {important}

Voice input requires exact numeric formatting for successful recognition:

**Successful Formats**:
- ‚úÖ "negative fifteen point five" ‚Üí -15.5
- ‚úÖ "one zero zero zero" ‚Üí 1000
- ‚úÖ "three point one four one five nine" ‚Üí 3.14159

**Failed Formats**:
- ‚ùå "minus fifteen and a half" ‚Üí NaN
- ‚ùå "one thousand" ‚Üí NaN  
- ‚ùå "fifteen hundred" ‚Üí NaN
- ‚ùå "pi" or "pie" ‚Üí NaN

**Platform Variations**:
- iOS: Siri dictation may auto-format some numbers
- Android: Google voice varies by language settings
- Desktop: Browser-dependent voice APIs

**Training Requirements**: Field teams must be trained on exact numeric dictation or use manual entry for complex values.

### Security Considerations {important}

See [Security Considerations Reference](security-considerations-reference.md) for comprehensive security guidelines and attack mitigation strategies.

**Number Field-Specific Security Risks**:
- **Overflow attacks**: Scientific notation (1e308) can bypass validation
- **Precision attacks**: >17 digits cause silent data corruption
- **BasicAutoIncrementer**: Sequential IDs enable enumeration attacks
- **Type confusion**: JavaScript number coercion bypasses validation

### Performance Boundaries {important}

See [Performance Thresholds Reference](performance-thresholds-reference.md) for comprehensive performance limits, testing scenarios, and optimization triggers.

**Number Field-Specific Performance Notes**:
- **Validation complexity**: >10 rules causes 50-200ms blur lag
- **Memory consumption**: ~8KB per field, 8 bytes per numeric value
- **Form limits**: >50 numeric fields causes 2+ second initial render
- **Precision limit**: JavaScript loses precision beyond 17 digits
- **BasicAutoIncrementer**: Degrades with >10,000 ID ranges

**Optimization for Complex Validation**:
```javascript
// Debounce validation for >10 rules
validationSchema: [
  ["yup.number"],
  ["yup.test", "debounced-check", "Value validation",
    debounce(async (value) => {
      // Complex validation logic
      return await validateComplexRules(value);
    }, 300)
  ]
]
```

### Platform Behaviors {important}

#### iOS Platform [affects: All fields] {important}

| Aspect | NumberInput | ControlledNumber | BasicAutoIncrementer |
|--------|------------|------------------|---------------------|
| **Keyboard** | Numeric pad | Numeric pad | N/A (hidden) |
| **Minus key** | ‚ùå Missing | ‚ùå Missing | ‚úÖ N/A |
| **Workaround** | Copy-paste | Copy-paste | N/A |
| **Decimal** | ‚úÖ Present | ‚úÖ Present | N/A |
| **Scientific** | ‚ùå No 'e' | ‚ùå No 'e' | N/A |

#### Android Platform [affects: All fields] {important}

| Aspect | NumberInput | ControlledNumber | BasicAutoIncrementer |
|--------|------------|------------------|---------------------|
| **Keyboard** | Numeric pad | Numeric pad | N/A (hidden) |
| **Minus key** | ‚úÖ Always shown | ‚úÖ Always shown | ‚úÖ N/A |
| **Confusion** | Shows when min=0 | Shows when min=0 | N/A |
| **Voice input** | ‚úÖ Available | ‚úÖ Available | N/A |

### Accessibility Compliance {important}

See [Accessibility Reference](accessibility-reference.md) for comprehensive WCAG compliance status, touch target requirements, and screen reader support.

**Number Field-Specific Issues**:
- Spinner controls (~20√ó20px) far below 44px WCAG minimum
- iOS keyboard lacks minus key for negative numbers  
- Generic "must be number" error messages not helpful
- No aria-live regions for validation state changes
- Tremors/gloves make precise spinner interaction difficult

### Export Behavior {important}

See [Data Export Reference](data-export-reference.md) for comprehensive export documentation including CSV/JSON formats, special character handling, and Excel issues.

**Number Field-Specific Export Notes**:
- **BasicAutoIncrementer**: Exports as string with leading zeros - Excel will strip these (e.g., "00042" becomes 42)
- **Scientific notation**: Numbers like 1.23e-7 preserved in CSV but may need formatting in Excel
- **Very large numbers**: Numbers >15 digits lose precision in Excel (123456789012345 becomes 1.23457E+14)
- **Infinity/NaN**: Export as empty cells in CSV, may cause #NUM! errors in Excel
- **Prevention**: Use TemplatedString wrapper with leading apostrophe for Excel-safe IDs:
  ```json
  {
    "component-name": "TemplatedStringField",
    "template": "'{{identifier_field}}",  // Leading apostrophe
    "name": "excel_safe_id"
}
```

## Individual Field Reference {essential}

### NumberInput (Number Input in Designer) {essential}
#### JSON Anti-patterns‚ùå **NEVER: String initialValue for number**```json{  "component-name": "NumberField",  "initialValue": "0"  // ERROR: Must be number, not string}```‚úÖ **ALWAYS: Use numeric type**```json{  "initialValue": 0  // Correct: number type}```‚ùå **NEVER: Wrong validation order**```json{  "validationSchema": [    ["yup.min", 0],  // ERROR: Type not declared first    ["yup.number"]  ]}```‚úÖ **ALWAYS: Type first, then constraints**```json{  "validationSchema": [    ["yup.number"],    ["yup.min", 0]  ]}```
#### Common Spec Mappings- "Enter quantity" ‚Üí NumberField with min validation- "Record measurement" ‚Üí NumberField with decimal places- "Count items" ‚Üí NumberField with integer validation- "Temperature reading" ‚Üí NumberField with range validation
<!-- keywords: numeric, decimal, float, measurement, calculation, validation, null -->

#### Purpose {essential}
Standard numeric data entry supporting floating-point values, null states, and comprehensive validation. Recommended for scientific measurements, calculations, and any numeric data requiring flexibility.

#### Key Features {essential}
- ‚úÖ **Null value support** - Distinguishes "not measured" from zero
- ‚úÖ **Scientific notation** - Full support (1.23e-7)
- ‚úÖ **Flexible validation** - Complete control via JSON
- ‚úÖ **Dual validation** - HTML5 + Yup schema
- ‚ö†Ô∏è **Component name paradox** - Designer "Number Input" ‚Üí JSON "NumberField"
- ‚úÖ **Styled spin buttons** - Custom CSS with gray background, border, pointer cursor

#### Configuration Parameters {important}

**Designer Accessible**:
```json
{
  "component-name": "NumberField",
  "type": "faims-core::Number",
  "name": "measurement",
  "label": "Measurement (cm)",
  "initialValue": null,
  "required": false,
  "helperText": "Record to 0.1cm precision"
}
```

**JSON Enhancement**:
```json
{
  "validationSchema": [
    ["yup.number"],
    ["yup.required"],
    ["yup.min", 0, "Cannot be negative"],
    ["yup.max", 1000, "Exceeds maximum"],
    ["yup.test", "precision", "Max 1 decimal",
      "value => value == null || Number.isInteger(value * 10)"]
  ],
  "InputProps": {
    "type": "number",
    "inputProps": {
      "min": 0,
      "max": 1000,
      "step": 0.1
    }
  }
}
```

#### Storage Characteristics {comprehensive}

| Input | Storage Type | Database Value | Memory | Export CSV | Export JSON |
|-------|--------------|----------------|--------|------------|-------------|
| Empty field | null | null | 0 bytes | (empty) | null |
| 0 | number | 0 | 8 bytes | 0 | 0 |
| 42.0 | number | 42 | 8 bytes | 42 | 42 |
| 3.14159265358979323846 | number | 3.141592653589793 | 8 bytes | 3.141592653589793 | 3.141592653589793 |
| 1.23e-7 | number | 0.000000123 | 8 bytes | 1.23e-7 | 1.23e-7 |
| 999999999999999999999 | number | 1e21 | 8 bytes | 1e+21 | 1e21 |
| Infinity (overflow) | null | null | 0 bytes | (empty) | null |

**Critical Notes**:
- Trailing zeros never preserved (42.000 ‚Üí 42)
- Precision silently truncated at ~15-17 significant digits
- Values beyond ¬±1.8√ó10¬≥‚Å∞‚Å∏ overflow to Infinity, stored as null
- NaN values from invalid operations stored as null

#### Field-Specific Troubleshooting {important}

| Issue | Symptom | Solution |
|-------|---------|----------|
| **Component name confusion** | Field not recognized | Use `"NumberField"` not `"NumberInput"` |
| **iOS minus key** | Cannot enter negatives | Copy-paste or use TextField |
| **Trailing zeros lost** | 42.0 ‚Üí 42 | Use TextField if format critical |
| **Scientific notation** | User confusion | Document format in training |

#### Conditional Logic Examples {comprehensive}

**Show field when value exceeds threshold**:
```json
{
  "ph_measurement": {
    "component-name": "NumberField",
    "type": "faims-core::Number",
    "name": "ph_measurement",
    "label": "pH Reading"
  },
  "alkaline_warning": {
    "component-name": "RichText",
    "name": "alkaline_warning",
    "content": "‚ö†Ô∏è High pH detected - verify calibration",
    "condition": {
      "operator": ">",
      "field": "ph_measurement", 
      "value": 8.5
    }
  }
}
```

**Null value handling in conditions**:
```json
{
  "condition": {
    "operator": "and",
    "conditions": [
      {
        "operator": "!=",
        "field": "depth_reading",
        "value": null
      },
      {
        "operator": ">",
        "field": "depth_reading",
        "value": 0
      }
    ]
  }
}
```

#### Implementation Examples {comprehensive}

**Environmental Monitoring**:
```json
{
  "component-name": "NumberField",
  "type": "faims-core::Number",
  "name": "water_temperature",
  "label": "Water Temperature (¬∞C)",
  "helperText": "Record to 0.1¬∞C precision",
  "validationSchema": [
    ["yup.number"],
    ["yup.required"],
    ["yup.min", -2, "Below freezing point"],
    ["yup.max", 40, "Above expected max"]
  ]
}
```

### ControlledNumber (Controlled Number in Designer) {essential}

‚ö†Ô∏è **CRITICAL WARNING**: ControlledNumber is a Designer-only abstraction, NOT a real component in the codebase. It maps to NumberField in JSON.

#### JSON Anti-patterns

‚ùå **NEVER: This component doesn't exist in codebase**
```json
{
  "component-name": "ControlledNumber"  // ERROR: Not a real component
}
```
‚úÖ **ALWAYS: Use NumberField**
```json
{
  "component-name": "NumberField",
  "component-namespace": "faims-custom"
}
```

#### Common Spec Mappings
- Designer-only abstraction ‚Üí Maps to NumberField in JSON
- Not a real component ‚Üí Always use NumberField
<!-- keywords: range, bounded, min-max, constrained, rating, percentage -->

#### Purpose {essential}
Designer-accessible bounded numeric input for non-technical users needing range validation without JSON editing. Ideal for ratings, percentages, and constrained measurements.

#### Key Features {essential}
- ‚úÖ **Designer min/max** - No JSON required for bounds
- ‚úÖ **HTML5 enforcement** - Browser-level validation
- ‚ö†Ô∏è **Type mismatch** - Declares Integer, accepts floats
- ‚ùå **No null support** - Always has value (default 0)
- ‚ùå **Fixed initial value** - Always 0

#### Configuration Parameters {important}

**Designer Configuration**:
```json
{
  "component-name": "ControlledNumber",
  "type": "faims-core::Integer",
  "name": "artifact_condition",
  "label": "Condition Score (1-10)",
  "min": 1,
  "max": 10,
  "helperText": "1 = Poor, 10 = Excellent",
  "initialValue": 0
}
```

**JSON Enhancement** (optional):
```json
{
  "validationSchema": [
    ["yup.number"],
    ["yup.integer", "Whole numbers only"],
    ["yup.required"]
  ]
}
```

#### Storage Characteristics {comprehensive}

| Input | Storage Type | Database Value | Memory | Export CSV | Export JSON |
|-------|--------------|----------------|--------|------------|-------------|
| Empty (not possible) | number | 0 | 8 bytes | 0 | 0 |
| 0 | number | 0 | 8 bytes | 0 | 0 |
| 5.5 | number | 5.5 | 8 bytes | 5.5 | 5.5 |
| 10 | number | 10 | 8 bytes | 10 | 10 |

**Critical Notes**:
- Cannot store null - always has numeric value
- Decimals accepted despite Integer type declaration
- Initial value always 0 (may violate min constraint)

#### Field-Specific Troubleshooting {important}

| Issue | Symptom | Solution |
|-------|---------|----------|
| **Type mismatch** | Decimals accepted | Document or add integer validation |
| **Initial value 0** | Violates min=1 | Set appropriate minimum |
| **No null support** | Cannot skip field | Use NumberInput if optional |
| **iOS minus key** | Cannot enter negatives | Use NumberInput with JSON |

#### Conditional Logic Examples {comprehensive}

**Trigger action based on rating**:
```json
{
  "quality_rating": {
    "component-name": "ControlledNumber",
    "type": "faims-core::Integer",
    "name": "quality_rating",
    "min": 1,
    "max": 5
  },
  "poor_quality_notes": {
    "component-name": "MultilineTextField",
    "name": "poor_quality_notes",
    "label": "Explain quality issues",
    "condition": {
      "operator": "<=",
      "field": "quality_rating",
      "value": 2
    }
  }
}
```

#### Implementation Examples {comprehensive}

**Survey Rating**:
```json
{
  "component-name": "ControlledNumber",
  "type": "faims-core::Integer",
  "name": "satisfaction",
  "label": "Satisfaction (1-5)",
  "min": 1,
  "max": 5,
  "initialValue": 3,
  "helperText": "1=Very Unsatisfied, 5=Very Satisfied"
}
```

### BasicAutoIncrementer (Basic Auto-incrementer in Designer) {essential}
#### JSON Anti-patterns‚ùå **NEVER: Expecting number type from counter**```json{  "component-name": "BasicAutoIncrementer",  // Returns "BAI-001" not 1}```‚úÖ **UNDERSTAND: Returns formatted string**```json{  // Returns: "BAI-001", "BAI-002", etc.  // Not: 1, 2, 3}```‚ùå **NEVER: Using as required field**```json{  "component-name": "BasicAutoIncrementer",  "validationSchema": [["yup.string"], ["yup.required"]]  // ERROR}```‚úÖ **ALWAYS: Auto-generated fields are never required**```json{  "component-name": "BasicAutoIncrementer"  // No validation needed - auto-populates}```
#### Common Spec Mappings- "Auto ID" ‚Üí BasicAutoIncrementer (generates BAI-001, BAI-002...)- "Sequential number" ‚Üí BasicAutoIncrementer with prefix- "Counter field" ‚Üí BasicAutoIncrementer (string output)- Note: Returns string, not number
<!-- keywords: sequence, identifier, auto-increment, catalog, specimen, string -->

#### Purpose {essential}
Generates sequential string identifiers for distributed offline data collection. Returns zero-padded strings suitable for specimen numbers, catalog IDs, and sequential references.

#### Key Features {essential}
- ‚ö†Ô∏è **Returns STRING not number** - Critical for understanding
- ‚úÖ **Offline capable** - Range-based allocation
- ‚úÖ **Zero padding preserved** - "00042" maintained
- ‚ùå **No duplicate detection** - Requires manual coordination
- ‚ö†Ô∏è **Excel strips zeros** - Always use with TemplatedString

#### Configuration Parameters {important}

**Designer Configuration**:
```json
{
  "component-name": "BasicAutoIncrementer",
  "type": "faims-core::String",
  "name": "specimen_number",
  "form_id": "specimen_registration",
  "num_digits": 5,
  "label": "Specimen ID"
}
```

**Required Integration Pattern**:
```json
{
  "component-name": "TemplatedStringField",
  "name": "full_specimen_id",
  "template": "SPEC-{{specimen_number}}-{{_YYYY}}",
  "label": "Complete Specimen ID"
}
```

#### Storage Characteristics {comprehensive}

| State | Storage Type | Database Value | Memory | Export CSV | Export JSON |
|-------|--------------|----------------|--------|------------|-------------|
| Ungenerated | string | "" | 2 bytes | (empty) | "" |
| Generated "00001" | string | "00001" | 7 bytes | "00001" | "00001" |
| Generated "99999" | string | "99999" | 7 bytes | "99999" | "99999" |
| With template | string | As composed | varies | Quoted | String |

**Critical Notes**:
- Never null - always empty string or value
- Padding preserved exactly as generated
- No numeric operations possible
- Template composition happens at display time

#### Range Management Protocol {important}

**External Coordination Spreadsheet** (Required):

| Device ID | User | Form ID | Range Start | Range End | Status | Date |
|-----------|------|---------|-------------|-----------|--------|------|
| iPad-A001 | Smith | specimen | 1 | 999 | Active | 2024-01-15 |
| iPad-A002 | Jones | specimen | 1000 | 1999 | Reserved | 2024-01-15 |

**Requirements**:
- Cloud-accessible (e.g., Google Sheets or Office365)
- Version controlled
- Immediate updates
- Team-wide access

##### Downloadable Template

Save the following as `range_allocation_registry.csv` and maintain in your project's shared drive:

```csv
# BasicAutoIncrementer Range Allocation Registry
# CRITICAL: Maintain this spreadsheet to prevent duplicate identifiers
# Upload to shared drive and update immediately upon any allocation
# 
# Status options: Active, Reserved, Exhausted, Disabled
# Ensure ranges NEVER overlap within the same Form ID
#
Device ID,User,Form ID,Range Start,Range End,Date Allocated,Status,Notes
iPad-A001,J. Smith,specimen_registration,1,999,2024-01-15,Active,Site A deployment - Field team 1
iPad-A001,J. Smith,specimen_registration,1000,1999,2024-03-20,Reserved,Contingency for Site A
iPad-A002,M. Jones,specimen_registration,2000,2999,2024-01-15,Active,Site B deployment - Field team 2
Phone-B001,K. Wilson,feature_recording,1,500,2024-01-15,Exhausted,Completed 2024-02-10
Phone-B001,K. Wilson,feature_recording,501,1000,2024-02-10,Active,Current range
Phone-B002,L. Chen,feature_recording,1001,1500,2024-01-15,Active,Remote team
Tablet-C001,A. Brown,finds_register,1,999,2024-01-20,Active,Laboratory cataloging
Tablet-C001,A. Brown,finds_register,1000,4999,2024-01-20,Reserved,Year 2024 allocation
Desktop-LAB,Lab Team,accession_register,10000,19999,2024-01-01,Active,Central processing
Desktop-LAB,Lab Team,accession_register,20000,29999,2024-01-01,Reserved,2025 allocation
#
# ADD NEW ALLOCATIONS BELOW - NEVER DELETE EXHAUSTED RANGES (Archive only)
#
,,,,,,,,
,,,,,,,,
,,,,,,,,
,,,,,,,,
,,,,,,,,
```

**Usage Instructions**:
1. Save as CSV file in shared cloud storage (Google Drive, Dropbox, etc.)
2. Import into Google Sheets or Excel for easier management
3. Enable sharing with all team members
4. Set up notification rules for changes (if using Google Sheets)
5. Review weekly during active fieldwork
6. Never delete rows - mark as "Exhausted" and archive annually

#### Field-Specific Troubleshooting {important}

| Issue | Symptom | Solution |
|-------|---------|----------|
| **String type confusion** | Arithmetic fails | Document string return |
| **Duplicate IDs** | Same number multiple devices | Check range overlap |
| **Excel strips zeros** | "00042" ‚Üí 42 | Use TemplatedString |
| **Range exhaustion** | Generation stops | Allocate new range |

#### Conditional Logic Examples {comprehensive}

**String comparison for identifiers**:
```json
{
  "specimen_id": {
    "component-name": "BasicAutoIncrementer",
    "type": "faims-core::String",
    "name": "specimen_id",
    "form_id": "specimens",
    "num_digits": 5
  },
  "first_specimen_flag": {
    "component-name": "RichText",
    "content": "üìç This is the first specimen of the day",
    "condition": {
      "operator": "is",
      "field": "specimen_id",
      "value": "00001"
    }
  }
}
```

**Cannot use numeric operators**:
```json
// ‚ùå WRONG - BasicAutoIncrementer returns string
{
  "condition": {
    "operator": ">",
    "field": "specimen_id",
    "value": 100
  }
}

// ‚úÖ CORRECT - Use string operations
{
  "condition": {
    "operator": "contains",
    "field": "specimen_id",
    "value": "999"
  }
}
```

#### Implementation Examples {comprehensive}

**Museum Cataloging**:
```json
[
  {
    "component-name": "BasicAutoIncrementer",
    "type": "faims-core::String",
    "name": "accession_seq",
    "form_id": "accessions",
    "num_digits": 6
  },
  {
    "component-name": "TemplatedStringField",
    "name": "accession_number",
    "template": "{{museum_code}}.{{_YYYY}}.{{accession_seq}}"
  }
]
```

## Troubleshooting Guide {important}

### Critical Issues Table {important}

| üî¥ Critical Issue | Fields Affected | Impact | Immediate Action |
|-------------------|-----------------|--------|------------------|
| **iOS minus key missing** | NumberInput, ControlledNumber | Cannot enter negatives | Use TextField or copy-paste |
| **Type mismatches** | All three | Data integrity risk | Document extensively |
| **No duplicate detection** | BasicAutoIncrementer | ID collisions | Implement range protocol |
| **Excel strips zeros** | BasicAutoIncrementer | ID corruption | Always use TemplatedString |

### Common Problems Table {important}

| üü° Problem | Symptom | Affected Fields | Solution |
|------------|---------|-----------------|----------|
| **Component name paradox** | Field not found | NumberInput | Use "NumberField" in JSON |
| **Decimals in Integer field** | Type confusion | ControlledNumber | Add validation or document |
| **String arithmetic** | Calculations fail | BasicAutoIncrementer | Never use for math |
| **Voice input fails** | NaN errors | NumberInput, ControlledNumber | Train exact format |
| **Touch targets small** | Hard to tap | NumberInput, ControlledNumber | Custom CSS |

### Detailed Issue Matrix {important}

| Issue | Affects | Symptoms | Solution | Priority |
|-------|---------|----------|----------|----------|
| **Validation lag** | NumberInput with >10 rules | Sluggish response on blur | Debounce validation | Medium |
| **Memory accumulation** | All fields in large forms | Browser tab crash >1000 fields | Paginate forms | High |
| **Precision silently lost** | NumberInput >17 digits | 9999999999999999 ‚Üí 10000000000000000 | Document limitation | High |
| **Voice input fails** | NumberInput, ControlledNumber | "one thousand" ‚Üí NaN | Train exact format | Medium |
| **Spinner too small** | NumberInput, ControlledNumber | Miss-clicks on mobile | Custom CSS sizing | Low |
| **No thousands separator** | NumberInput, ControlledNumber | Hard to read 1000000 | Feature pending | Low |
| **Paste validation timing** | All fields | Error doesn't appear immediately | Known HTML5 behavior | Low |
| **Scientific notation confusion** | NumberInput | Users don't understand 1.23e5 | Training required | Medium |
| **Null vs empty string** | ControlledNumber | Cannot represent "not measured" | Use NumberInput | High |
| **Browser autofill** | NumberInput | Fills with strings | Clear and retype | Low |

### Quick Fixes Table {important}

| üü¢ Quick Fix | Issue | Fields | Action |
|--------------|-------|--------|--------|
| **Add nullable()** | Empty field errors | NumberInput | `["yup.nullable"]` |
| **Wrap in template** | Excel zero stripping | BasicAutoIncrementer | Use TemplatedString |
| **Copy negative value** | iOS minus missing | NumberInput, ControlledNumber | Paste from notes |
| **Check range overlap** | Duplicate IDs | BasicAutoIncrementer | Review allocation log |

### Complete Error Reference {comprehensive}

| Error Message | Field | Scenario | Root Cause | Solution |
|---------------|-------|----------|------------|----------|
| "Must be a number" | NumberInput | Empty required field | Yup validation without nullable() | Add .nullable() to schema |
| "Cannot read property 'NumberField' of undefined" | NumberInput | Config error | Wrong component-name | Use "NumberField" not "NumberInput" |
| "Value must be less than or equal to X" | ControlledNumber | Exceeds max | HTML5 constraint | Adjust max or use NumberInput |
| "Invalid prop 'type-returned'" | All | JSON error | Wrong type string | Check exact type format |
| "Field is required" | All | Submit without value | Required validation | Enter value or remove required |
| "No ranges available" | BasicAutoIncrementer | Range exhausted | All numbers used | Allocate new range |
| "Duplicate identifier detected" | BasicAutoIncrementer | ID collision | Range overlap | Check range allocation |
| "NaN" | NumberInput | Voice input | Natural language | Use exact numeric format |
| "Maximum update depth exceeded" | All | Infinite loop | Circular validation | Check validation dependencies |
| "Out of memory" | All | Large dataset | Too many fields | Implement pagination |

### Error Message Reference {important}

| Error Message | Field | Meaning | Solution |
|---------------|-------|---------|----------|
| "Error with numeric input, please enter a valid number." | NumberInput | Invalid input (NaN or null) | Enter valid numeric value |
| "Component 'NumberInput' not found" | NumberInput | Wrong JSON component name | Use `"NumberField"` not `"NumberInput"` |
| "Must be a number" | All numeric | Empty field or invalid input | Add `["yup.nullable"]` or enter valid number |
| "yup.required is not a function" | All | Wrong validation order | Put type first: `["yup.number"], ["yup.required"]` |
| "TypeError: Cannot perform arithmetic" | BasicAutoIncrementer | String not number | Returns string - use for IDs only |
| "Value must be at least X" | NumberInput/Controlled | Below configured minimum | Check min constraint or adjust value |
| "Value must not exceed X" | NumberInput/Controlled | Above configured maximum | Check max constraint or adjust value |
| "Field is required" | All | Missing required value | Enter value or make field optional |
| "Invalid format" | BasicAutoIncrementer | Pattern validation failed | Check regex pattern in validationSchema |
| "Precision lost" | NumberInput | >17 significant digits | JavaScript IEEE 754 limitation |
| "Cannot read property 'length' of null" | NumberInput | Wrong initialValue type | Use null for numbers, not strings |


### Quick Reference Matrix {important}

| If you see... | First try... | Then try... | Last resort... |
|---------------|--------------|-------------|----------------|
| "Component NumberInput not found" | Change to "NumberField" in JSON | Check component-namespace | Recreate field in Designer |
| Cannot enter negative on iOS | Copy from Notes app | Use TextField with pattern | Document workaround |
| Excel corrupts IDs | Use BasicAutoIncrementer | Wrap in TemplatedString | Export as JSON |
| "Must be a number" on empty | Add `nullable()` validation | Make field required | Set initialValue: 0 |
| Decimals in ControlledNumber | Add `yup.integer()` validation | Accept decimal storage | Use NumberInput |
| Scientific notation appears | Add helper text explanation | Use TextField for display | Accept notation |
| Precision lost >17 digits | Document limitation | Use string field | Reduce precision |
| Cannot skip ControlledNumber | Switch to NumberInput | Accept 0 default | Make optional |
| Touch targets too small | Custom CSS for sizing | Train users | Accept limitation |
| Voice input fails | Train "one zero zero zero" | Manual entry | Provide number pad |
### Debug Checklists {comprehensive}

**NumberInput Checklist**:
- [ ] Using "NumberField" not "NumberInput" in JSON
- [ ] Validation schema properly formatted (array of arrays)
- [ ] InitialValue is null not undefined for empty
- [ ] Min/max constraints don't conflict
- [ ] iOS negative value workaround documented

**ControlledNumber Checklist**:
- [ ] Initial value within min/max bounds
- [ ] Integer enforcement added if needed
- [ ] Type mismatch documented
- [ ] Alternative for null values considered

**BasicAutoIncrementer Checklist**:
- [ ] Range allocation documented externally
- [ ] No overlapping ranges across devices
- [ ] TemplatedString wrapper implemented
- [ ] String type understood by team
- [ ] Form ID matches exactly

### Comprehensive Testing Matrix {comprehensive}

**NumberInput Testing**:
- [ ] Empty field saves as null (not 0 or "")
- [ ] Validation message appears only after blur
- [ ] Scientific notation accepted (1.23e-7)
- [ ] Overflow values rejected (>1.8e308)
- [ ] Precision truncation documented (>17 digits)
- [ ] iOS negative entry workaround tested
- [ ] Android minus key behavior documented
- [ ] Voice input format documented
- [ ] Conditional logic with null values
- [ ] CSV export preserves scientific notation
- [ ] JSON export maintains type (number not string)

**ControlledNumber Testing**:
- [ ] Initial value within bounds
- [ ] Cannot set to null (always has value)
- [ ] Decimal values accepted despite Integer type
- [ ] Min/max bounds enforced on blur
- [ ] Spinner respects bounds (desktop)
- [ ] Helper text displays correctly
- [ ] Required validation works
- [ ] Export includes all values

**BasicAutoIncrementer Testing**:
- [ ] Range allocation documented
- [ ] No duplicate IDs across devices
- [ ] Leading zeros preserved
- [ ] TemplatedString integration works
- [ ] String type understood (no math operations)
- [ ] Form ID exact match
- [ ] CSV export quoted properly
- [ ] Excel protection implemented
- [ ] Range exhaustion handled
- [ ] Settings UI accessible

## JSON Examples {comprehensive}

### Base Patterns {comprehensive}

**NumberInput with Full Validation**:
```json
{
  "component-name": "NumberField",
  "type": "faims-core::Number",
  "name": "soil_ph",
  "label": "Soil pH",
  "validationSchema": [
    ["yup.number"],
    ["yup.required"],
    ["yup.min", 0],
    ["yup.max", 14],
    ["yup.test", "precision", "Max 2 decimals",
      "v => v == null || Number.isInteger(v * 100)"]
  ]
}
```

**ControlledNumber for Ratings**:
```json
{
  "component-name": "ControlledNumber",
  "type": "faims-core::Integer",
  "name": "quality_rating",
  "label": "Quality (1-10)",
  "min": 1,
  "max": 10,
  "initialValue": 5
}
```

**BasicAutoIncrementer with Protection**:
```json
[
  {
    "component-name": "BasicAutoIncrementer",
    "type": "faims-core::String",
    "name": "find_seq",
    "form_id": "finds",
    "num_digits": 5
  },
  {
    "component-name": "TemplatedStringField",
    "name": "find_id",
    "template": "FIND-{{site}}-{{find_seq}}-{{_YYYY}}"
  }
]
```

### Anti-Patterns {comprehensive}

‚ùå **Never: BasicAutoIncrementer for calculations**:
```json
// WRONG - Returns string not number
{
  "component-name": "BasicAutoIncrementer",
  "name": "count"
}
// Later: count + 1 // FAILS
```

‚ùå **Never: Unprotected BasicAutoIncrementer export**:
```json
// WRONG - Excel will strip zeros
{
  "component-name": "BasicAutoIncrementer",
  "name": "specimen_id"
}
// Export: "00042" ‚Üí 42
```

‚ùå **Never: ControlledNumber for optional values**:
```json
// WRONG - No null support
{
  "component-name": "ControlledNumber",
  "name": "optional_measurement"
}
```

### Platform-Specific Configurations {comprehensive}

**iOS-Safe Positive-Only Number**:
```json
{
  "component-name": "NumberField",
  "type": "faims-core::Number",
  "name": "distance",
  "label": "Distance (m)",
  "validationSchema": [
    ["yup.number"],
    ["yup.min", 0, "Distance cannot be negative"]
  ]
}
```

### Integration Patterns {comprehensive}

**Complete Archaeological Recording**:
```json
[
  {
    "component-name": "BasicAutoIncrementer",
    "type": "faims-core::String",
    "name": "find_sequence",
    "form_id": "finds",
    "num_digits": 5
  },
  {
    "component-name": "TemplatedStringField",
    "name": "find_number",
    "template": "{{site_code}}-F{{find_sequence}}"
  },
  {
    "component-name": "NumberField",
    "type": "faims-core::Number",
    "name": "depth_cm",
    "label": "Depth (cm)",
    "validationSchema": [
      ["yup.number"],
      ["yup.required"],
      ["yup.min", 0],
      ["yup.max", 500]
    ]
  },
  {
    "component-name": "ControlledNumber",
    "type": "faims-core::Integer",
    "name": "condition",
    "label": "Condition (1-5)",
    "min": 1,
    "max": 5
  }
]
```

## Migration Scenarios {comprehensive}

### Scenario 1: Deprecated NumberField to NumberInput
**Context**: Legacy forms using the deprecated NumberField component need migration to the supported NumberInput.

**Challenge**:
- Confusing naming (NumberInput uses "NumberField" as component-name)
- Null handling differences
- Validation schema requirements

**Migration Steps**:
1. Export existing data to preserve number values
2. Update component configuration (keep name as "NumberField"):
   ```json
   {
     "component-name": "NumberField", // Yes, still "NumberField"!
     "type": "faims-core::Number",
     "validationSchema": [
       ["yup.number"],
       ["yup.nullable"] // Add explicit null handling
     ]
   }
   ```
3. Test null vs zero behavior thoroughly
4. Update user documentation about the naming paradox
5. Verify calculations still work correctly

**Solution/Workaround**: Accept the naming confusion; document it prominently in project notes.

### Scenario 2: TextField with Numeric Pattern to NumberInput
**Context**: Projects using TextField for numbers to preserve formatting need proper numeric fields.

**Challenge**:
- Loss of formatting (commas, currency symbols)
- String to number type conversion
- Validation pattern differences

**Migration Steps**:
1. Identify TextFields with numeric patterns
2. Evaluate each field:
   - Need calculations? ‚Üí Migrate to NumberInput
   - Need format preservation? ‚Üí Keep as TextField
   - Need range validation? ‚Üí NumberInput with min/max
3. For migration candidates:
   ```javascript
   // Convert string numbers to actual numbers
   const numericValue = parseFloat(textValue.replace(/[^0-9.-]/g, ''));
   ```
4. Add appropriate validation schemas
5. Test on all platforms (especially iOS for negative numbers)

**Solution/Workaround**: Keep TextField for display-only formatted numbers; use NumberInput for calculations.

### Scenario 3: Manual ID System to BasicAutoIncrementer
**Context**: Projects with manual Excel-based ID allocation moving to automated incrementing.

**Challenge**:
- BasicAutoIncrementer returns strings not numbers
- Range coordination for offline teams
- Sorting issues with string comparison

**Migration Steps**:
1. Document existing ID ranges and allocations
2. Implement range allocation protocol:
   ```json
   // Team A: 1000-1999
   // Team B: 2000-2999
   {
     "start_at": 1000,
     "stop_at": 1999
   }
   ```
3. Wrap with TemplatedString for display:
   ```json
   {
     "component-name": "TemplatedStringField",
     "template": "SITE-{{auto_id}}"
   }
   ```
4. Train teams on range coordination
5. Implement periodic range reconciliation

**Solution/Workaround**: Pre-allocate large ranges; use external spreadsheet for coordination.

### Scenario 4: Adding Range Validation to Existing Data
**Context**: Unvalidated numeric fields need min/max constraints without breaking existing data.

**Challenge**:
- Existing values may violate new constraints
- Null values vs required validation
- Platform-specific input differences

**Migration Steps**:
1. Audit existing data for range:
   ```sql
   SELECT MIN(field), MAX(field), COUNT(*) 
   FROM records WHERE field IS NOT NULL;
   ```
2. Set validation ranges based on actual data
3. For ControlledNumber (Designer users):
   - Set min/max through Designer UI
   - Cannot be null (always has value)
4. For NumberInput (JSON editing):
   ```json
   "validationSchema": [
     ["yup.number"],
     ["yup.min", 0, "Must be positive"],
     ["yup.max", 100, "Maximum 100"],
     ["yup.nullable"]
   ]
   ```
5. Implement data cleanup for out-of-range values

**Solution/Workaround**: Set permissive ranges initially; tighten gradually with user communication.

### Scenario 5: iOS Negative Number Entry
**Context**: iOS numeric keyboards lack minus key, preventing negative number entry.

**Challenge**:
- Hardware limitation (no OS fix available)
- Users cannot enter negative values
- Copy-paste workaround not intuitive

**Migration Steps**:
1. Identify fields requiring negative values
2. Choose approach based on use case:
   - Option A: Switch to TextField with pattern:
   ```json
   {
     "component-name": "TextField",
     "pattern": "^-?[0-9]+(\.[0-9]+)?$"
   }
   ```
   - Option B: Provide copy button with common negatives
   - Option C: Use custom component with +/- buttons
3. Add clear helper text about limitation
4. Train iOS users on workaround
5. Document in project README

**Solution/Workaround**: For critical negative values, use TextField; otherwise document copy-paste method.

### Migration Quick Reference

‚ö†Ô∏è **NumberField ‚Üí NumberInput**:
- Component name changes to "NumberField" (paradox)
- Add explicit nullable() validation
- Test null vs zero semantics

‚ö†Ô∏è **Manual IDs ‚Üí BasicAutoIncrementer**:
- Returns strings not numbers
- Implement range coordination
- Add TemplatedString wrapper

‚ö†Ô∏è **Any field ‚Üí ControlledNumber**:
- No null value support
- Type declares Integer but accepts floats
- Initial value always 0

### Migration Script Templates {comprehensive}

**NumberField to NumberInput**:
```javascript
// Before
{
  "component-name": "NumberField", // Old deprecated
  "type": "faims-core::Number"
}

// After
{
  "component-name": "NumberField", // Still "NumberField"!
  "type": "faims-core::Number",
  "validationSchema": [
    ["yup.number"],
    ["yup.nullable"] // Add explicit null handling
  ]
}
```

## Best Practices {comprehensive}

### Design Principles
- **Type clarity**: Document actual vs declared types (ControlledNumber Integer accepts floats)
- **Null handling**: Explicitly handle null vs zero semantics
- **Platform testing**: Always test on iOS for negative numbers
- **Format preservation**: Use TextField when display format matters more than calculation
- **Range allocation**: Pre-allocate ID ranges for offline coordination

### Performance Optimization
- **Validation complexity**: Keep validation rules simple (complex rules cause lag)
- **Form size**: Limit to <50 number fields per form
- **Calculation fields**: Use TemplatedString for derived values, not real-time calculation
- **Touch targets**: Increase input height to 44px minimum for accessibility
- **Precision limits**: Stay within JavaScript's safe integer range (¬±2^53-1)

### Data Quality Strategies
- **Range validation**: Always set realistic min/max bounds
- **Decimal precision**: Validate decimal places for scientific data
- **Zero vs null**: Document whether empty means zero or no data
- **Unit documentation**: Always specify units in labels or helper text
- **Cross-field validation**: Implement server-side for complex numeric relationships

### Common Patterns
- **Measurements**: NumberInput + unit in label + range validation
- **Identifiers**: BasicAutoIncrementer + TemplatedString wrapper
- **Currency**: TextField with pattern for display, NumberInput for calculations
- **Percentages**: ControlledNumber with 0-100 range
- **Scientific notation**: TextField for display, transform for storage

### Team Coordination
- **Range allocation spreadsheet**: Maintain external coordination for ID ranges
- **Type documentation**: Document all type mismatches in README
- **Platform-specific training**: iOS users need minus key workarounds
- **Validation testing**: Test edge cases (min, max, null, zero)
- **Format conventions**: Standardize number display formats project-wide

### Known Limitations and Feature Requests

**Current Limitations (2025-08)**:

| Feature | Status | Workaround | Priority |
|---------|--------|------------|----------|
| **iOS minus key** | Won't fix (OS limitation) | Copy-paste or TextField | - |
| **Thousands separators** | Feature request pending | None | Medium |
| **Locale-aware formatting** | Not planned | Manual formatting | Low |
| **Custom increment steps** | Under consideration | Manual validation | Low |
| **Real-time calculation** | Performance concerns | Use TemplatedString | Medium |
| **Touch target size** | CSS customization needed | Custom styles | High |
| **Decimal place enforcement** | Requires Yup validation | Add validation rules | Medium |
| **Currency formatting** | Use TextField | Pattern validation | Low |
| **Unit labels inline** | Use helper text | Document pattern | Low |
| **Undo/redo support** | Not implemented | Browser default | Low |

### Recommended Workarounds

```json
// Thousands separator display
{
  "component-name": "TextField",
  "component-parameters": {
    "label": "Budget (with commas)",
    "pattern": "^[0-9]{1,3}(,[0-9]{3})*$",
    "helperText": "Format: 1,234,567"
  }
}

// Currency with validation
{
  "component-name": "TextField",
  "component-parameters": {
    "label": "Price",
    "pattern": "^\\$[0-9]+(\\.[0-9]{2})?$",
    "helperText": "Format: $123.45"
  }
}

// Percentage with bounds
{
  "component-name": "ControlledNumber",
  "component-parameters": {
    "label": "Completion (%)",
    "min": 0,
    "max": 100,
    "helperText": "Enter percentage without % symbol"
  }
}
```

## Field Quirks Index (2025-08) {comprehensive}

### Common Number Field Quirks
- `QUIRK` iOS numeric keyboard universally lacks minus key for negative number entry
  - `ERROR` User cannot enter negative values on iOS devices
  - `FIX` Copy-paste from Notes app or implement TextField with pattern validation
  - `TEST` Open any numeric field on iOS Safari/Chrome
  - `XREF` See [Common Characteristics > Platform Behaviors > iOS Platform]
- `QUIRK` Deprecated "Number Field" still visible in Designer interface
  - `ERROR` Selecting "Number Field" uses legacy TextField implementation
  - `FIX` Always select "Number Input" instead
  - `TEST` Check Designer field selector for both options
  - `XREF` See [Overview > CRITICAL: Deprecated Field Warning]
- `QUIRK` Touch targets (36px) below WCAG minimum (44px) for all numeric inputs
  - `ERROR` Difficult selection for users with motor impairments
  - `FIX` Custom CSS to increase touch target size
  - `TEST` Measure spinner control dimensions in DevTools
  - `XREF` See [Common Characteristics > Accessibility Compliance]
- `QUIRK` Android shows minus key even when min=0 configured
  - `ERROR` Users type negative values that fail validation
  - `FIX` Add clear helperText explaining valid range
  - `TEST` Open ControlledNumber with min=0 on Android
  - `XREF` See [Common Characteristics > Platform Behaviors > Android Platform]
- `QUIRK` Voice input requires exact numeric pronunciation
  - `ERROR` "one thousand" produces NaN, must say "one zero zero zero"
  - `FIX` Train users on exact format or provide manual entry
  - `TEST` Try voice input with natural language vs exact numbers
  - `XREF` See [Common Characteristics > Voice Input Requirements]
- `QUIRK` No thousands separators in any numeric field
  - `ERROR` 1000000 displays without commas, hard to read
  - `FIX` Feature pending - use TextField for formatted display
  - `TEST` Enter large number, check display format
  - `XREF` See [Migration and Best Practices > Known Limitations]
- `VERSION` 2025-08

### NumberInput
- `RULE` Component name inverted: Designer "Number Input" ‚Üí JSON "NumberField"
  - `ERROR` "Field 'NumberInput' not found in component registry"
  - `FIX` Use exact JSON: `"component-name": "NumberField"`
  - `TEST` Verify JSON: `grep '"component-name".*NumberField' notebook.json`
  - `XREF` See [Overview > Designer Quick Guide]
- `QUIRK` Precision silently truncated beyond 15-17 significant digits
  - `ERROR` No warning when 3.14159265358979323846 ‚Üí 3.141592653589793
  - `FIX` Document precision limits in helperText
  - `TEST` Enter 20-digit number, check stored value
  - `XREF` See [Common Characteristics > Configuration Rules]
- `QUIRK` Empty field shows "Must be a number" despite not being required
  - `ERROR` "Must be a number" on blur of empty non-required field
  - `FIX` Add nullable validation:
    ```json
    "validationSchema": [
      ["yup.number"],
      ["yup.nullable"]
    ]
    ```
  - `TEST` Blur empty field without nullable()
  - `XREF` See [Common Characteristics > Validation Patterns]
- `QUIRK` Scientific notation auto-converts at 10000000 (1e7)
  - `ERROR` Users confused by "1e7" display format
  - `FIX` Add helperText explaining scientific notation
  - `TEST` Enter 10000000, observe auto-conversion
  - `XREF` See [Individual Field Reference > NumberInput > Storage Characteristics]
- `QUIRK` Trailing zeros never preserved (42.000 ‚Üí 42)
  - `ERROR` Format requirements lost, precision appears reduced
- `QUIRK` Spin buttons have custom styling (gray background #9F9F9F, 2px black border)
  - `INFO` Styled for better visibility with 8px padding, border-radius 4px
  - `FIX` Override with custom CSS if different styling needed
  - `TEST` Inspect element to verify webkit-inner-spin-button styles
  - `FIX` Use TextField if trailing zeros critical
  - `TEST` Enter 3.1400, check stored value
  - `XREF` See [Individual Field Reference > NumberInput > Storage Characteristics]
- `QUIRK` Values >1.8√ó10¬≥‚Å∞‚Å∏ overflow to Infinity, stored as null
  - `ERROR` Extreme values silently lost
  - `FIX` Add reasonable max bounds validation
  - `TEST` Enter 1e309, check storage (becomes null)
  - `XREF` See [Common Characteristics > Data Type Specifications]
- `QUIRK` NaN results stored as null
  - `ERROR` Invalid calculations produce null not NaN
  - `FIX` Validate before calculations
  - `TEST` Force NaN condition, check database
  - `XREF` See [Field Interaction Matrix > Data Type Interactions]
- `QUIRK` Paste non-numeric silently converts to null on blur
  - `ERROR` Paste "about 100" ‚Üí null without warning
  - `FIX` Pattern validation or preprocessing
  - `TEST` Paste text into numeric field, blur
  - `XREF` See [Field Interaction Matrix > Validation Cascades]
- `VERSION` 2025-08

### ControlledNumber
- `RULE` Type declares Integer but accepts/stores decimals
  - `ERROR` "faims-core::Integer" type allows 3.14159
  - `FIX` Enforce integers explicitly:
    ```json
    "validationSchema": [
      ["yup.number"],
      ["yup.integer", "Whole numbers only"]
    ]
    ```
  - `TEST` Enter 3.14 in Integer field: `typeof value === 'number' && value === 3.14`
  - `XREF` See [Individual Field Reference > ControlledNumber > Critical Type Declaration Mismatch]
- `QUIRK` Initial value always 0, may violate minimum constraint
  - `ERROR` "Value must be at least 1" on form load when min=1
  - `FIX` Set min=0 or accept initial validation error
  - `TEST` Configure min=1, check initial state
  - `XREF` See [Individual Field Reference > ControlledNumber > Known Issues]
- `QUIRK` Cannot store null - always has numeric value
  - `ERROR` Cannot distinguish "not measured" from zero
  - `FIX` Use NumberInput if null values needed
  - `TEST` Try to clear field completely
  - `XREF` See [Individual Field Reference > ControlledNumber > Key Features]
- `QUIRK` Android minus key visible even with min=0
  - `ERROR` Confusing UI - key present but values rejected
  - `FIX` Clear helperText about valid range
  - `TEST` Open field with min=0 on Android device
  - `XREF` See [Common Characteristics > Platform Behaviors > Android Platform]
- `VERSION` 2025-08

### BasicAutoIncrementer
- `RULE` Returns STRING despite "Number Fields" categorization
  - `ERROR` `TypeError: Cannot perform arithmetic on string "00042"`
  - `FIX` Never use for calculations:
    ```javascript
    // WRONG
    const next = autoValue + 1; // TypeError
    
    // RIGHT
    const display = `ID-${autoValue}`; // String concatenation
    ```
  - `TEST` Check type: `typeof fieldValue === 'string'`
  - `XREF` See [Individual Field Reference > BasicAutoIncrementer > Critical Return Type Warning]
- `QUIRK` Excel strips leading zeros without protection
  - `ERROR` CSV "00042" becomes 42 in Excel
  - `FIX` Always wrap in TemplatedString:
    ```json
    {
      "component-name": "TemplatedStringField",
      "template": "SPEC-{{auto_increment}}-{{_YYYY}}"
    }
    ```
  - `TEST` Export CSV, open in Excel, verify zero preservation
  - `XREF` See [Individual Field Reference > BasicAutoIncrementer > Field-Specific Features]
- `QUIRK` No duplicate detection across devices
  - `ERROR` Device A and B both generate "00001" with overlapping ranges
  - `FIX` Maintain external range allocation spreadsheet per protocol
  - `TEST` Allocate same range on two devices, check for duplicates
  - `XREF` See [Individual Field Reference > BasicAutoIncrementer > Range Management Protocol]
- `QUIRK` Hidden field - users confused about auto-generation
  - `ERROR` Users search for field to edit
  - `FIX` Clear labeling that ID is automatic
  - `TEST` Check field visibility in form
  - `XREF` See [Individual Field Reference > BasicAutoIncrementer > Purpose]
- `QUIRK` Range exhaustion stops generation silently
  - `ERROR` No new IDs generated, no error message
  - `FIX` Monitor range usage, allocate before exhaustion
  - `TEST` Use all numbers in range, try to generate
  - `XREF` See [Field Interaction Matrix > Validation Cascades]
- `QUIRK` Form ID must match exactly - case sensitive
  - `ERROR` Wrong form_id resets sequence to 1
  - `FIX` Document exact form_id values
  - `TEST` Use form_id with different case
  - `XREF` See [Individual Field Reference > BasicAutoIncrementer > Configuration Parameters]
- `VERSION` 2025-08

### Performance Quirks
- `QUIRK` Complex validation (>10 rules) causes noticeable blur lag
  - `ERROR` 50-200ms delay on field blur
  - `FIX` Simplify or debounce validation
  - `TEST` Add 15 validation rules, measure blur time
  - `XREF` See [Performance Thresholds Table]
- `QUIRK` Forms with >50 numeric fields slow initial render
  - `ERROR` 2+ second delay on form load
  - `FIX` Implement pagination or progressive disclosure
  - `TEST` Create form with 100 NumberInput fields
  - `XREF` See [Performance Thresholds Table]
- `QUIRK` Memory accumulates with >1000 fields
  - `ERROR` Browser tab crash at ~4GB
  - `FIX` Paginate at 500 field threshold
  - `TEST` Generate form with 2000 fields, monitor memory
  - `XREF` See [Field Interaction Matrix > Platform-Specific Combinations]
- `VERSION` 2025-08

### Browser-Specific Quirks
- `QUIRK` Browser autofill may insert strings into numeric fields
  - `ERROR` Validation fails on autofilled data
  - `FIX` Clear and manually re-enter
  - `TEST` Use browser password manager on numeric field
  - `XREF` See [Troubleshooting Guide > Detailed Issue Matrix]
- `QUIRK` Desktop spinner controls respect bounds, mobile doesn't
  - `ERROR` Inconsistent validation behavior
  - `FIX` Document platform differences
  - `TEST` Compare spinner behavior desktop vs mobile
  - `XREF` See [Common Characteristics > Platform Behaviors]
- `VERSION` 2025-08

---
## Performance Thresholds Summary {comprehensive}

See [Performance Thresholds Reference](performance-thresholds-reference.md) for detailed metrics and testing scenarios.

**Number Field Critical Thresholds**:
- **Validation rules**: >10 causes 50-200ms blur lag
- **Form fields**: >50 causes 2+ second render delay
- **Precision limit**: >17 digits silently truncated (IEEE 754)
- **BasicAutoIncrementer**: >100 ranges causes UI lag, >100,000 IDs causes memory pressure
- **Export**: >10,000 rows adds 5+ seconds generation time
- **Touch targets**: 36px default (below 44px WCAG minimum)

`VERSION` 2025-08

---

## Migration Warnings Index (2025-08) {comprehensive}

### Safe Migrations (No Data Loss)
- `SAFE` Deprecated Number Field ‚Üí NumberInput when adding nullable validation
  ```json
  // BEFORE (deprecated)
  {
    "component-namespace": "formik-material-ui",
    "component-name": "TextField",
    "type": "number",
    "type-returned": "faims-core::Integer"
  }
  
  // AFTER (recommended)
  {
    "component-name": "NumberField",
    "type": "faims-core::Number",
    "validationSchema": [
      ["yup.number"],
      ["yup.nullable"]
    ]
  }
  ```
  - `VALIDATE` All existing numeric data remains valid
  - `TEST` Check null handling: `value === null` not `value === ""`
- `SAFE` Adding TemplatedString wrapper to existing BasicAutoIncrementer
- `SAFE` Adding validation to NumberInput (makes stricter, not looser)
- `SAFE` Increasing BasicAutoIncrementer num_digits (e.g., 5 ‚Üí 6)
- `SAFE` Adding min/max constraints to NumberInput via JSON
  - `VALIDATE` Existing values fall within new constraints
  - `TEST` Query for out-of-range values before applying
- `SAFE` Adding precision validation to existing NumberInput
  - `VALIDATE` Current precision levels acceptable
  - `TEST` Check maximum decimal places in existing data
- `SAFE` Adding helperText to any field for iOS negative number workaround
- `VERSION` 2025-08

### Breaking Changes (Data Loss or Corruption Risk)
- `BREAKS` NumberInput ‚Üí ControlledNumber with existing null values
  - `IMPACT` Null values become 0, losing "not measured" semantics
  - `ERROR` "Cannot convert null to number, defaulting to 0"
  - `NO ROLLBACK` Once null‚Üí0 conversion occurs, original state lost
  - `ALTERNATIVE` Keep NumberInput, add min/max via JSON:
    ```json
    {
      "component-name": "NumberField",
      "validationSchema": [
        ["yup.number"],
        ["yup.min", 0],
        ["yup.max", 100]
      ]
    }
    ```
- `BREAKS` BasicAutoIncrementer ‚Üí Any numeric field
  - `IMPACT` String "00042" ‚Üí number 42, losing padding
  - `ERROR` "Cannot parse '00042' as number"
  - `NO ROLLBACK` Leading zeros permanently lost
  - `ALTERNATIVE` Keep as string, use TextField if needed
- `BREAKS` Changing BasicAutoIncrementer form_id
  - `IMPACT` Counter resets to 1, potential duplicates
  - `ERROR` New sequence starts, old sequence orphaned
  - `ROLLBACK` Restore original form_id, but gap remains
- `BREAKS` Reducing BasicAutoIncrementer num_digits
  - `IMPACT` Existing IDs may not fit new format
  - `ERROR` "00042" cannot fit in 3-digit format
  - `NO ROLLBACK` Existing identifiers invalid
- `BREAKS` Removing TemplatedString wrapper from BasicAutoIncrementer
  - `IMPACT` Excel will corrupt all exported identifiers
  - `ERROR` "00042" becomes 42 on next export
  - `NO ROLLBACK` Historical exports already corrupted
  - `ALTERNATIVE` Keep wrapper, hide if not needed visually
- `BREAKS` NumberInput with precision >17 digits ‚Üí Any migration
  - `IMPACT` Precision already lost, cannot recover
  - `ERROR` 9999999999999999999 already stored as 1e19
  - `NO ROLLBACK` Original precision unrecoverable
  - `ALTERNATIVE` Use TextField for exact numeric strings
- `BREAKS` Changing validation from nullable to required on populated dataset
  - `IMPACT` Records with null values become uneditable
  - `ERROR` "Field is required" blocks form submission
  - `ROLLBACK` Remove required validation immediately
  - `PRECHECK`:
    ```sql
    SELECT COUNT(*) FROM records WHERE field_name IS NULL;
    ```
- `VERSION` 2025-08

### Conditional Migrations (Context Dependent)
- `CONDITIONAL` ControlledNumber ‚Üí NumberInput for nullable support
  - `PRECHECK` Identify records with value=0 that mean "unmeasured":
    ```python
    # Check if zeros are meaningful or just defaults
    zeros = df[df['field_name'] == 0]
    print(f"Records with 0: {len(zeros)}")
    print("Sample contexts:", zeros[['id', 'notes']].head())
    ```
  - `SAFE IF` All zero values are meaningful measurements
  - `UNSAFE IF` Zero used as placeholder for "not measured"
  - `PROCEDURE`:
    1. Export all data
    2. Convert meaningful zeros to 0, unmeasured to null
    3. Update field configuration
    4. Re-import cleaned data
- `CONDITIONAL` TextField with numeric pattern ‚Üí NumberInput
  - `PRECHECK` Validate all existing values are numeric:
    ```python
    # Check for non-numeric values
    non_numeric = df[~df['field'].str.match(r'^-?\d+\.?\d*$')]
    print(f"Non-numeric values: {len(non_numeric)}")
    ```
  - `SAFE IF` All values parse as valid numbers
  - `UNSAFE IF` Special formats like "~100" or "100+" exist
  - `PROCEDURE`:
    1. Clean special notations
    2. Convert to numeric type
    3. Add appropriate validation
- `CONDITIONAL` Manual ID system ‚Üí BasicAutoIncrementer
  - `PRECHECK` Analyze existing ID patterns:
    ```python
    # Check ID format consistency
    ids = df['manual_id']
    formats = ids.str.extract(r'^([A-Z]*)-?(\d+)$')
    print(f"Numeric portions: {formats[1].value_counts()}")
    ```
  - `SAFE IF` Can map existing IDs to ranges
  - `UNSAFE IF` IDs don't follow sequential pattern
  - `PROCEDURE`:
    1. Document existing ID ranges
    2. Allocate non-overlapping ranges
    3. Preserve existing IDs as separate field
    4. Generate new IDs going forward only
- `CONDITIONAL` Scientific notation fields ‚Üí Standard notation
  - `PRECHECK` Check for values using e-notation:
    ```python
    # Find scientific notation usage
    sci_notation = df[df['field'].str.contains('e', case=False, na=False)]
    print(f"Scientific notation entries: {len(sci_notation)}")
    ```
  - `SAFE IF` Values within standard display range
  - `UNSAFE IF` Values require scientific notation (very large/small)
  - `PROCEDURE`:
    1. Convert notation if within range
    2. Keep scientific for extreme values
    3. Add helperText explaining format
- `CONDITIONAL` iOS deployment ‚Üí Alternative negative number strategy
  - `PRECHECK` Identify fields accepting negative values:
    ```javascript
    // Find fields with negative capability
    const negativeFields = fields.filter(f => 
      !f.min || f.min < 0
    );
    console.log(`Fields accepting negatives: ${negativeFields.length}`);
    ```
  - `REQUIRED IF` Any NumberInput/ControlledNumber accepts negatives
  - `OPTIONS`:
    1. Switch to TextField with pattern
    2. Add paste instructions to helperText
    3. Provide value templates for copying
  - `PROCEDURE`:
    1. Identify all negative-capable fields
    2. Choose consistent strategy
    3. Update all affected fields
    4. Document in training materials
- `CONDITIONAL` Range exhaustion ‚Üí New BasicAutoIncrementer ranges
  - `PRECHECK` Monitor range utilization:
    ```sql
    -- Check range usage
    SELECT 
      MAX(CAST(identifier AS INTEGER)) as highest_used,
      999 - MAX(CAST(identifier AS INTEGER)) as remaining
    FROM records 
    WHERE identifier REGEXP '^[0-9]+$';
    ```
  - `CRITICAL IF` <100 numbers remaining
  - `URGENT IF` <500 numbers remaining
  - `PROCEDURE`:
    1. Document current highest number
    2. Allocate next range (e.g., 1000-1999)
    3. Update range allocation spreadsheet
    4. Configure devices with new ranges
    5. Test no overlap exists
- `VERSION` 2025-08

### Emergency Rollback Procedures

#### Corrupted Precision Data
- `SYMPTOMS` Numbers showing as 1e19, loss of significant digits
- `IMMEDIATE`:
  ```sql
  -- Identify affected records
  SELECT * FROM records 
  WHERE CAST(numeric_field AS TEXT) LIKE '%e%'
  OR LENGTH(CAST(numeric_field AS TEXT)) > 15;
  ```
- `ROLLBACK`:
  1. Stop data entry immediately
  2. Export all data
  3. Switch to TextField with pattern validation
  4. Restore from backup if precision critical
- `PREVENTION` Add precision validation before migration
- `VERSION` 2025-08

#### Duplicate Identifier Crisis
- `SYMPTOMS` Same ID on multiple records, sync conflicts
- `IMMEDIATE`:
  ```sql
  -- Find duplicates
  SELECT identifier, COUNT(*) as count
  FROM records
  GROUP BY identifier
  HAVING count > 1;
  ```
- `ROLLBACK`:
  1. Stop all data collection
  2. Export duplicate records
  3. Assign temporary unique suffixes
  4. Implement proper range allocation
  5. Merge duplicate records if needed
- `PREVENTION` External range coordination mandatory
- `VERSION` 2025-08

#### Null to Zero Corruption
- `SYMPTOMS` All unmeasured values showing as 0
- `IMMEDIATE`:
  ```python
  # Identify suspicious zeros
  zeros = df[df['field'] == 0]
  # Check if notes indicate "not measured"
  suspicious = zeros[zeros['notes'].str.contains(
    'not measured|no data|missing', 
    case=False, 
    na=False
  )]
  ```
- `ROLLBACK`:
  1. Export all data immediately
  2. Switch back to NumberInput
  3. Convert suspicious zeros to null
  4. Re-import corrected data
  5. Add nullable validation
- `PREVENTION` Never use ControlledNumber for optional measurements
- `VERSION` 2025-08

### Migration Testing Checklist

#### Pre-Migration Testing
- [ ] Backup all data in multiple formats (CSV, JSON, SQL)
- [ ] Query for edge cases (null, zero, precision extremes)
- [ ] Test migration on subset (10 records)
- [ ] Verify rollback procedure works
- [ ] Document current field configurations
- [ ] Check all conditional dependencies
- [ ] Validate no breaking changes for other fields
- [ ] Confirm range allocations (BasicAutoIncrementer)

#### Post-Migration Validation  
- [ ] All numeric values preserved correctly
- [ ] Null handling maintains semantics
- [ ] Precision within acceptable bounds
- [ ] No duplicate identifiers created
- [ ] Validation rules enforce correctly
- [ ] Export formats unchanged
- [ ] iOS negative entry documented
- [ ] Performance acceptable (<50ms validation)

#### User Acceptance Testing
- [ ] Field entry works on all platforms
- [ ] Validation messages clear
- [ ] Helper text addresses limitations
- [ ] Training materials updated
- [ ] Rollback plan communicated
- [ ] Support contact available
- [ ] Known issues documented

- `VERSION` 2025-08

---

## JSON Patterns Cookbook (2025-08) {comprehensive}

### NumberInput Patterns

```json
// BASE PATTERN (all NumberInput variants start here)
{
  "component-name": "NumberField",  // ‚ö†Ô∏è NOT "NumberInput" despite Designer label!
  "type": "faims-core::Number",
  "name": "measurement",
  "label": "Measurement Value",
  "initialValue": null,  // null for empty, not ""
  "persistent": true,
  "required": false,
  "helperText": ""
}

// VARIANT: Required with validation
+ "required": true,
+ "validationSchema": [
+   ["yup.number"],  // Type MUST come first
+   ["yup.required", "This measurement is required"],
+   ["yup.min", 0, "Value cannot be negative"],
+   ["yup.max", 100, "Value cannot exceed 100"]
+ ]

// VARIANT: Nullable (allows empty without error)
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.nullable"]  // Critical for optional fields
+ ]

// VARIANT: Decimal precision control
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.test", "decimal-places", "Maximum 2 decimal places",
+     "value => value == null || Number.isInteger(value * 100)"]
+ ]

// VARIANT: Integer enforcement
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.integer", "Whole numbers only"]
+ ]

// VARIANT: Step validation for specific increments
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.test", "step-validation", "Must be in increments of 0.25",
+     "value => value == null || (value * 4) % 1 === 0"]
+ ]

// VARIANT: Scientific notation range handling
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.max", 1e10, "Value too large - exceeds system limits"],
+   ["yup.min", 1e-10, "Value too small - exceeds precision"]
+ ]

// VARIANT: Debounced validation for performance
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.test", "debounced-check", "Complex validation",
+     "debounce(async (value) => { return await validateComplexRules(value); }, 300)"]
+ ]

// VARIANT: HTML5 constraints (browser-enforced)
+ "InputProps": {
+   "type": "number",
+   "inputProps": {
+     "min": 0,
+     "max": 100,
+     "step": 0.01  // Increment buttons
+   }
+ }

// VARIANT: iOS-safe positive numbers only
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.min", 0, "Must be positive"]  // Avoids iOS minus key issue
+ ]

// VARIANT: Graceful overflow handling
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.test", "overflow-check", "Number too large",
+     "value => value == null || (isFinite(value) && Math.abs(value) < 1e308)"]
+ ]

// VARIANT: NaN prevention
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.test", "nan-check", "Invalid number",
+     "value => value == null || !isNaN(value)"]
+ ]

// VARIANT: Required only when visible
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.when", "$isVisible", {
+     "is": true,
+     "then": ["yup.required", "Field is required when visible"]
+   }]
+ ]

// VARIANT: Range depends on another field
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.when", "category", {
+     "is": "percentage",
+     "then": ["yup.min", 0].concat(["yup.max", 100]),
+     "otherwise": ["yup.min", -Infinity]
+   }]
+ ]
```

#### NumberInput ANTI-PATTERNS ‚ö†Ô∏è
```json
// ‚ùå NEVER: Wrong component name
{
  "component-name": "NumberInput"  // Designer label != JSON name
  // ERROR: "Component 'NumberInput' not found"
}
// ‚úÖ ALWAYS: Use correct JSON name
{
  "component-name": "NumberField"
}

// ‚ùå NEVER: Empty string initial value
{
  "initialValue": ""  // Causes validation confusion
  // ERROR: "Must be a number"
}
// ‚úÖ ALWAYS: Use null for empty
{
  "initialValue": null
}

// ‚ùå NEVER: Using deprecated Number Field
{
  "component-namespace": "formik-material-ui",
  "component-name": "TextField",
  "type": "number"  // This is the OLD deprecated version
}
// ‚úÖ ALWAYS: Use NumberInput (as "NumberField")
{
  "component-name": "NumberField",
  "type": "faims-core::Number"
}
```

### ControlledNumber Patterns

```json
// BASE PATTERN (Designer-friendly bounded input)
{
  "component-name": "ControlledNumber",
  "type": "faims-core::Integer",  // ‚ö†Ô∏è Accepts decimals despite Integer!
  "name": "rating",
  "label": "Quality Rating",
  "min": 1,  // Required for this field type
  "max": 10,  // Required for this field type
  "initialValue": 0,  // Always 0, not configurable
  "persistent": true
}

// VARIANT: With integer enforcement (fixes type mismatch)
+ "validationSchema": [
+   ["yup.number"],
+   ["yup.integer", "Please enter a whole number"]
+ ]

// VARIANT: Percentage (0-100)
{
  "component-name": "ControlledNumber",
  "type": "faims-core::Integer",
  "name": "completion_percentage",
  "label": "Completion (%)",
  "min": 0,
  "max": 100,
  "helperText": "Enter percentage complete",
  "initialValue": 0  // Note: Cannot be null
}

// VARIANT: Survey scale with initial value fix
{
  "component-name": "ControlledNumber",
  "name": "satisfaction",
  "label": "Satisfaction (1-5)",
- "min": 1,  // Would cause initial validation error
+ "min": 0,  // Accept default 0 to avoid error
  "max": 5,
  "helperText": "0 = Not answered, 1-5 = Rating scale"
}
```

#### ControlledNumber ANTI-PATTERNS ‚ö†Ô∏è
```json
// ‚ùå NEVER: Expecting null values
{
  "component-name": "ControlledNumber",
  "required": false  // Still can't be null!
  // ERROR: Always has value 0, never null
}
// ‚úÖ ALWAYS: Use NumberInput if null needed
{
  "component-name": "NumberField",
  "validationSchema": [["yup.number"], ["yup.nullable"]]
}

// ‚ùå NEVER: Initial value below minimum
{
  "min": 1,
  "max": 10,
  "initialValue": 0  // Immediate validation error!
}
// ‚úÖ ALWAYS: Ensure initial within bounds
{
  "min": 0,  // Or set appropriate initial
  "max": 10
}
```

### BasicAutoIncrementer Patterns

```json
// BASE PATTERN (sequential string identifiers)
{
  "component-name": "BasicAutoIncrementer",
  "type": "faims-core::String",  // ‚ö†Ô∏è Returns STRING not number!
  "name": "specimen_seq",
  "form_id": "specimen_registration",  // Links to specific sequence
  "num_digits": 5,  // Zero-padding width
  "label": "Specimen Number",
  "persistent": true
}

// VARIANT: With TemplatedString wrapper (REQUIRED for Excel)
{
  "fields": [
    {
      "component-name": "BasicAutoIncrementer",
      "type": "faims-core::String",
      "name": "seq_number",
      "form_id": "records",
      "num_digits": 6
    },
    {
      "component-name": "TemplatedStringField",
      "type": "faims-core::String",
      "name": "record_id",
      "template": "REC-{{seq_number}}-{{_YYYY}}",
      "label": "Record Identifier"
    }
  ]
}

// VARIANT: Museum cataloging pattern
{
  "component-name": "BasicAutoIncrementer",
  "name": "accession_seq",
  "form_id": "accessions",
  "num_digits": 6,  // Allows up to 999,999
  "label": "Accession Sequence"
}

// DOCUMENTATION: Range allocation tracking
{
  "_range_allocation": {
    "device_A": {"start": 1, "end": 999},
    "device_B": {"start": 1000, "end": 1999},
    "device_C": {"start": 2000, "end": 2999},
    "comment": "CRITICAL: Never overlap ranges",
    "tracking_sheet": "https://docs.google.com/spreadsheets/d/xxx"
  }
}
```

#### BasicAutoIncrementer ANTI-PATTERNS ‚ö†Ô∏è
```json
// ‚ùå NEVER: Using for calculations
{
  "component-name": "BasicAutoIncrementer",
  "name": "count"
  // Later: count + 1
  // ERROR: "TypeError: Cannot perform arithmetic on string '00042'"
}
// ‚úÖ ALWAYS: Use only for identifiers
{
  "component-name": "BasicAutoIncrementer",
  "name": "specimen_id"  // String identifier only
}

// ‚ùå NEVER: Direct CSV export without protection
{
  "component-name": "BasicAutoIncrementer",
  "name": "id"  // Excel strips zeros: "00042" ‚Üí 42
}
// ‚úÖ ALWAYS: Wrap in TemplatedString
{
  "template": "PREFIX-{{auto_increment}}-SUFFIX"
}

// ‚ùå NEVER: Overlapping ranges across devices
// Device A: 1-1000
// Device B: 1-1000  // DUPLICATES!
// ‚úÖ ALWAYS: Non-overlapping ranges
// Device A: 1-999
// Device B: 1000-1999
```

### Platform-Specific Configurations

```json
// iOS-Optimized (avoids minus key issue)
{
  "component-name": "NumberField",
  "name": "positive_only",
  "label": "Distance (m)",
  "validationSchema": [
    ["yup.number"],
    ["yup.min", 0, "Distance cannot be negative"]
  ],
  "helperText": "Positive values only"  // User expectation
}

// Android-Specific (handles minus key confusion)
{
  "component-name": "ControlledNumber",
  "min": 0,
  "max": 100,
  "helperText": "0-100 only (ignore minus key)"  // Android shows minus even when min=0
}

// Desktop-Optimized (leverages full keyboard)
{
  "component-name": "NumberField",
  "InputProps": {
    "type": "number",
    "inputProps": {
      "step": 0.001,  // Fine control with arrows
      "min": -1000,
      "max": 1000
    }
  }
}

// Voice Input Configuration
{
  "component-name": "NumberField",
  "helperText": "Say numbers like: 'fifteen point five' not 'fifteen and a half'"
}
```


### Performance Optimization Patterns

```json
// PATTERN: Optimized for large forms (>50 fields)
{
  "component-name": "NumberField",
  "validationSchema": [
    ["yup.number"],
    ["yup.lazy", "value => value ? yup.number().min(0) : yup.number()"]
  ]
  // Lazy evaluation reduces initial load
}

// PATTERN: Pagination trigger for memory management
{
  "form_config": {
    "pagination_threshold": 500,  // Fields per page
    "comment": "Forms with >1000 fields risk browser crash"
  }
}
```

### Migration Patterns

```json
// MIGRATION: From deprecated Number Field
{
  // OLD (deprecated)
  "component-namespace": "formik-material-ui",
  "component-name": "TextField",
  "type": "number",
  "type-returned": "faims-core::Integer"
}
// TO NEW (correct)
{
  "component-name": "NumberField",
  "type": "faims-core::Number",
  "validationSchema": [
    ["yup.number"],
    ["yup.nullable"]  // Add for proper null handling
  ]
}

// MIGRATION: TextField to NumberInput
{
  // Check existing data first:
  // grep -E '[^0-9.-]' field_values.txt
  // If clean, migrate:
  "component-name": "NumberField",
  "validationSchema": [
    ["yup.number"],
    ["yup.transform", "(value, originalValue) => originalValue === '' ? null : value"]
  ]
}
```

### Excel/CSV Export Safety Patterns

```json
// PATTERN: Excel-safe number export
{
  "export_config": {
    "number_fields": {
      "format": "text",  // Prevent Excel auto-formatting
      "prefix": "'",     // Force text interpretation
      "comment": "Prevents scientific notation conversion"
    }
  }
}

// PATTERN: CSV with preserved precision
{
  "component-name": "NumberField",
  "export_formatter": "value => value?.toFixed(6)",  // Preserve 6 decimals
  "comment": "Prevents precision loss in export"
}
```

### Integration Patterns (Fields Working Together)

```json
// PATTERN: BasicAutoIncrementer + TemplatedString (ESSENTIAL)
{
  "specimen_number": {
    "component-name": "BasicAutoIncrementer",
    "type": "faims-core::String",
    "form_id": "specimens",
    "num_digits": 5
  },
  "specimen_id": {
    "component-name": "TemplatedStringField",
    "template": "{{site_code}}-SP{{specimen_number}}-{{_YYYY}}",
    "label": "Full Specimen ID"
  }
}

// PATTERN: Multiple numeric fields with calculations
{
  "length_cm": {
    "component-name": "NumberField",
    "type": "faims-core::Number",
    "label": "Length (cm)"
  },
  "width_cm": {
    "component-name": "NumberField",
    "type": "faims-core::Number",
    "label": "Width (cm)"
  },
  "area_display": {
    "component-name": "TextField",  // Display only
    "label": "Area (cm¬≤)",
    "disabled": true,
    "helperText": "Calculated from length √ó width"
    // Note: Actual calculation requires custom code
  }
}

// PATTERN: Conditional number fields
{
  "has_measurement": {
    "component-name": "Checkbox",
    "label": "Measurement taken?"
  },
  "measurement_value": {
    "component-name": "NumberField",
    "label": "Measurement (mm)",
    "condition": {
      "field": "has_measurement",
      "operator": "is",
      "value": true
    },
    "validationSchema": [
      ["yup.number"],
      ["yup.when", "has_measurement", {
        "is": true,
        "then": ["yup.required", "Enter measurement"]
      }]
    ]
  }
}

// PATTERN: Archaeological recording suite
{
  "find_number": {
    "component-name": "BasicAutoIncrementer",
    "form_id": "finds",
    "num_digits": 5
  },
  "find_id": {
    "component-name": "TemplatedStringField",
    "template": "{{trench}}-F{{find_number}}"
  },
  "depth_cm": {
    "component-name": "NumberField",
    "validationSchema": [
      ["yup.number"],
      ["yup.min", 0, "Depth cannot be negative"],
      ["yup.max", 500, "Check depth - seems too deep"]
    ]
  },
  "artifact_count": {
    "component-name": "ControlledNumber",
    "min": 0,
    "max": 9999,
    "helperText": "Number of artifacts in this context"
  }
}

// PATTERN: Complete excavation recording
{
  "context_number": {
    "component-name": "BasicAutoIncrementer",
    "form_id": "contexts",
    "num_digits": 4
  },
  "context_id": {
    "component-name": "TemplatedStringField",
    "template": "{{site}}-{{trench}}-C{{context_number}}"
  },
  "opening_depth": {
    "component-name": "NumberField",
    "validationSchema": [
      ["yup.number"],
      ["yup.required"],
      ["yup.min", -10, "Check: below sea level?"],
      ["yup.max", 100, "Check: unusually deep"]
    ]
  },
  "closing_depth": {
    "component-name": "NumberField",
    "validationSchema": [
      ["yup.number"],
      ["yup.required"],
      ["yup.when", "opening_depth", 
        "(opening, schema) => schema.min(opening, 'Must be deeper than opening')"]
    ]
  }
}
```

### Common Anti-Patterns Across All Number Fields ‚ö†Ô∏è

```json
// ‚ùå NEVER: Wrong validation order
{
  "validationSchema": [
    ["yup.required"],  // ERROR: Type must come first!
    ["yup.number"]
  ]
}
// ‚úÖ ALWAYS: Type first, then constraints
{
  "validationSchema": [
    ["yup.number"],
    ["yup.required"]
  ]
}

// ‚ùå NEVER: String operations on numbers
{
  "component-name": "NumberField",
  "initialValue": "0"  // String instead of number
}
// ‚úÖ ALWAYS: Correct type
{
  "initialValue": 0  // Or null for empty
}

// ‚ùå NEVER: Arithmetic on BasicAutoIncrementer
{
  "next_value": "{{auto_increment + 1}}"  // STRING!
  // ERROR: "NaN"
}
// ‚úÖ ALWAYS: Use for identifiers only
{
  "display_id": "NEXT-{{auto_increment}}"
}

// ‚ùå NEVER: Precision beyond limits
{
  "validationSchema": [
    ["yup.number"],
    ["yup.test", "precision", "Must have 20 decimal places"]
    // JavaScript limited to ~15-17 digits!
  ]
}
```

### Error Message Quick Reference

```json
// Common errors and their meanings:
{
  "Component 'NumberInput' not found": "Use 'NumberField' in JSON despite Designer label",
  "Must be a number": "Empty field needs nullable() validation or has wrong type",
  "TypeError: Cannot perform arithmetic": "BasicAutoIncrementer returns string not number",
  "Value must be at least X": "Value below configured minimum",
  "Cannot read property 'length' of null": "initialValue should be empty string not null for some fields",
  "Field is required": "Add value or make field optional",
  "yup.required is not a function": "Put yup.type() before yup.required() in validation array",
  "Precision lost": "JavaScript limit ~15-17 significant digits",
  "00042 becomes 42": "Excel strips zeros - use TemplatedString wrapper"
}
```

---


## JSON Anti-patterns Quick Index {comprehensive}

Anti-patterns have been distributed to their respective field sections for better context locality. This index provides a quick reference:

### Anti-pattern Categories by Field

- **NumberField**: Type validation, initialValue format, decimal handling ‚Üí [NumberField Anti-patterns](#numberinput)
- **BasicAutoIncrementer**: String vs number output, prefix patterns ‚Üí [BasicAutoIncrementer Anti-patterns](#basicautoincrementer)
- **ControlledNumber**: Designer abstraction, JSON mapping ‚Üí [ControlledNumber Anti-patterns](#controllednumber)

### Common Anti-pattern Themes

1. **Type Confusion**: String vs number types in validation
2. **Validation Order**: Type declaration before constraints
3. **Auto-generated Fields**: Never mark as required
4. **Designer Abstractions**: Components that only exist in UI
5. **Platform Limitations**: iOS negative number input issues

## Quick Diagnosis Tables (2025-08) {important}

### When Component Name Errors Occur

| Symptom | Field Type | Likely Cause | Quick Fix | Version |
|---------|------------|--------------|-----------|---------|
| "Component 'NumberInput' not found" | NumberInput | Using Designer label in JSON | Change to `"component-name": "NumberField"` | 2025-08 |
| "Field type not recognized" | Number Field | Using deprecated field | Select "Number Input" in Designer, not "Number Field" | 2025-08 |
| Field saves but doesn't appear | All fields | component-name mismatch | Verify JSON name matches documentation | 2025-08 |
| "Component namespace not found" | Number Field | Old deprecated syntax | Remove namespace, use just component-name | 2025-08 |

### When Type Mismatch Issues Occur

| Symptom | Field Type | Pattern | Fix | Version |
|---------|------------|---------|-----|---------|
| Arithmetic fails with TypeError | BasicAutoIncrementer | `autoValue + 1` | It's a string - use for IDs only | 2025-08 |
| Decimals accepted in Integer field | ControlledNumber | 3.14 stored despite Integer type | Add `["yup.integer"]` validation | 2025-08 |
| "Must be a number" on empty field | NumberInput | Empty non-required field | Add `["yup.nullable"]` to validation | 2025-08 |
| Excel strips leading zeros | BasicAutoIncrementer | Direct CSV export | Wrap in TemplatedString | 2025-08 |
| Scientific notation appears | NumberInput | Large numbers (>1e7) | Add helperText explaining format | 2025-08 |

### When Platform-Specific Problems Occur

| Symptom | When | Why | Try This | If That Fails | Long Term |
|---------|------|-----|----------|---------------|-----------|
| Cannot enter negative numbers | iOS + NumberInput | No minus key on keyboard | Copy from Notes app | Use TextField with pattern | Document workaround |
| Minus key visible but min=0 | Android + ControlledNumber | HTML5 inconsistency | Add helperText "0-100 only" | Ignore (cosmetic) | Train users |
| Touch targets too small | Mobile + All numeric | 36px < WCAG 44px | Custom CSS padding | Zoom interface | Platform update |
| Voice input returns NaN | Mobile + Numeric | Natural language used | Say "fifteen point five" | Manual entry | Training materials |
| Spinner controls missing | Safari + NumberInput | Browser variance | Add custom buttons | Accept limitation | Use Chrome |

### When Validation Errors Occur

| Symptom | Field Type | Root Cause | Solution | Prevention |
|---------|------------|------------|----------|------------|
| "yup.required is not a function" | All | Wrong validation order | Put type first: `["yup.number"], ["yup.required"]` | Always type ‚Üí constraints |
| Initial validation error on load | ControlledNumber | initialValue 0 < min 1 | Set min=0 or accept error | Check bounds vs initial |
| Precision silently lost | NumberInput | >17 significant digits | Document limitation | Add precision warning |
| Empty field shows error | ControlledNumber | No null support | Use NumberInput instead | Choose correct field |
| Range validation ignored | NumberInput | JSON-only feature | Add validationSchema | Check Designer limits |

### When Performance Issues Occur

| Symptom | Threshold | Cause | Quick Fix | Long-term Solution |
|---------|-----------|-------|-----------|-------------------|
| Blur event lag 50-200ms | >10 validation rules | Complex validation | Simplify rules | Debounce validation |
| Form load delay >2s | >50 numeric fields | Initial render overhead | Progressive disclosure | Pagination |
| Browser tab crash | >1000 fields | Memory exhaustion (~4GB) | Paginate at 500 fields | Split into multiple forms |
| Settings UI freezes | >100 BasicAutoIncrementer ranges | Memory pressure | Archive old ranges | Database cleanup |
| Export hangs | >10,000 records | CSV generation overhead | Batch exports | Server-side generation |
| Validation freezes UI | Complex test functions | Synchronous blocking | Add debouncing (300ms) | Async validation |

### When Accessibility Issues Occur

| Symptom | WCAG Criterion | Failure | Solution | Version |
|---------|----------------|---------|----------|---------|
| Spinner controls hard to tap | 2.5.5 Target Size | 36px < 44px minimum | Custom CSS to increase | 2025-08 |
| Screen reader silent on errors | 4.1.3 Status Messages | No aria-live regions | Would require code change | 2025-08 |
| Cannot enter required negative (iOS) | 2.1.1 Keyboard | No minus key available | Complete barrier - use TextField | 2025-08 |
| Voice input always fails | Input Purpose | Exact format required | Train "one zero zero zero" not "thousand" | 2025-08 |
| No error announcements | 3.3.3 Error Suggestion | Generic messages only | Add specific helperText | 2025-08 |

### When Storage & Precision Problems Occur

| Symptom | Field | Cause | Impact | Solution |
|---------|-------|-------|--------|----------|
| 9999999999999999 ‚Üí 10000000000000000 | NumberInput | >17 digits precision | Silent data corruption | Document IEEE 754 limits |
| 1e309 stores as null | NumberInput | Overflow to Infinity | Data loss | Add max bounds 1e10 |
| 42.000 ‚Üí 42 | All numeric | Trailing zeros not preserved | Format lost | Use TextField if critical |
| NaN ‚Üí null | NumberInput | Invalid calculation | NaN lost | Validate before calc |
| Empty string vs null confusion | ControlledNumber | Always 0, never null | Wrong semantics | Use NumberInput |
| "00042" stays string | BasicAutoIncrementer | String type | Can't calculate | Never use for math |

### When Browser Issues Occur

| Symptom | Browser | Field | Fix | Alternative |
|---------|---------|-------|-----|-------------|
| Autofill inserts text | Chrome/Firefox | NumberInput | Clear and retype | Disable autofill |
| No spinner controls | Safari | NumberInput | Browser limitation | Custom buttons |
| Different decimal separator | European locale | All numeric | Force US locale | Server-side handling |
| Copy-paste validation delay | All browsers | All fields | Expected HTML5 behavior | Wait for blur |
| Memory leak | Chrome | >1000 fields | Restart browser | Pagination |

### When Range Management Issues Occur

| Symptom | Context | Cause | Immediate Fix | Long-term Solution |
|---------|---------|-------|---------------|-------------------|
| Generation stops | BasicAutoIncrementer | Range exhausted | Allocate new range in settings | Monitor usage |
| Duplicate IDs | Multi-device | Overlapping ranges | Check allocation spreadsheet | Implement protocol |
| Settings UI sluggish | >100 ranges | Memory pressure | Archive old ranges | Split forms |
| Range lost | Device replacement | Local-only storage | Consult external log | Maintain backups |
| Cannot modify ID | After generation | One-time only | Accept or migrate data | Document limitation |

### When Export/Import Problems Occur

| Symptom | Field Type | During | Fix | Best Practice |
|---------|------------|--------|-----|---------------|
| "00042" becomes 42 | BasicAutoIncrementer | Excel open | Import as text column | Use TemplatedString |
| Null becomes 0 | ControlledNumber | Any export | Expected behavior - no null | Use NumberInput |
| Scientific notation | NumberInput | Large number export | Format column in Excel | Document threshold |
| Trailing zeros lost | All numeric | Storage/export | Expected (42.0 ‚Üí 42) | Use TextField if critical |
| CSV has quotes | BasicAutoIncrementer | Export | Normal for strings | No action needed |

### When Migration Issues Occur

| From | To | Symptom | Check | Solution |
|------|-----|---------|-------|----------|
| Deprecated Number Field | NumberInput | Empty shows error | Missing nullable() | Add ["yup.nullable"] |
| TextField | NumberInput | Non-numeric data | grep '[^0-9.-]' | Clean data first |
| NumberInput | ControlledNumber | Null values lost | Check for nulls in DB | Keep NumberInput |
| Manual IDs | BasicAutoIncrementer | Pattern mismatch | Analyze existing IDs | Preserve old, generate new |
| ControlledNumber | NumberInput | Need null support | Check zero semantics | Export, transform, import |

### When Conditional Logic Fails

| Symptom | Field | Cause | Fix | Example |
|---------|-------|-------|-----|---------|
| Numeric comparison fails | BasicAutoIncrementer | String type | Use string operators | "is" not ">" |
| Null breaks condition | NumberInput | null neither > nor < | Check for null first | "!= null AND > 0" |
| Zero triggers unwanted | ControlledNumber | Can't be null | Check for 0 explicitly | "!= 0" |
| Scientific notation compare | NumberInput | String comparison | Parse to number first | Convert 1e7 |

### Quick Reference Matrix

| If you see... | First try... | Then try... | Last resort... |
|---------------|--------------|-------------|----------------|
| "Field not found" error | Check component-name spelling | Verify not using deprecated field | Rebuild field from scratch |
| Cannot enter negatives (iOS) | Copy-paste from another app | Switch to TextField | Provide external keyboard |
| Excel corrupts IDs | Re-import as text | Add TemplatedString wrapper | Use database tools |
| Validation always fails | Check validation order (type first) | Remove validation temporarily | Simplify to basic field |
| Range exhaustion | Allocate new range immediately | Check for range leaks | Split into multiple forms |
| Type mismatch errors | Verify field returns correct type | Check string vs number | Document extensively |
| Performance degradation | Reduce validation complexity | Paginate forms | Archive old data |
| Precision lost silently | Check >17 digits | Add warning to helperText | Use string field |
| Memory exhaustion | Count fields (>1000?) | Implement pagination | Split notebook |
| Debounce not working | Check validation complexity | Simplify rules | Remove validation |
| WCAG violation warnings | Increase touch targets CSS | Document limitation | Alternative interface |
| Overflow to Infinity | Add reasonable max (1e10) | Check calculations | Use TextField |

### Emergency Fixes

| Critical Issue | Immediate Action | Command/Code | Rollback |
|----------------|------------------|--------------|----------|
| All IDs corrupted in Excel | Stop using file | Re-export with TemplatedString | Restore from backup |
| Duplicate IDs in production | Document conflicts | `grep -c "ID-VALUE" *.json` | Assign device suffix |
| Validation blocking all entries | Remove validation | Delete validationSchema block | Re-add incrementally |
| Component not found | Use working example | Copy from this documentation | Previous version |
| Range overlap detected | Stop collection | Check allocation log | Reassign ranges |

### Common Misunderstandings

| What Users Think | What Actually Happens | Why | Correct Mental Model |
|------------------|----------------------|-----|---------------------|
| NumberInput = component name | "NumberField" in JSON | Designer label ‚â† JSON name | Always check JSON name |
| BasicAutoIncrementer returns number | Returns string "00042" | Preserves padding | String identifier only |
| ControlledNumber enforces integers | Accepts decimals | Type declaration wrong | Add validation if needed |
| Null same as zero | Different meanings | Scientific data integrity | Null = not measured |
| Deprecated field will be removed | Still in Designer | Backward compatibility | Never use it anyway |

`VERSION` 2025-08

---

## Field Interaction Matrix (2025-08) {important}

| Primary Field | Interacts With | Interaction Type | Notes |
|---------------|----------------|------------------|-------|
| **NumberInput** | Conditional logic | Value comparison | Null requires special handling |
| **ControlledNumber** | Conditional logic | Value comparison | 0 default may trigger conditions |
| **BasicAutoIncrementer** | TemplatedString | Composition | Essential for Excel protection |
| **BasicAutoIncrementer** | Conditional logic | String comparison | Use "is"/"contains" not ">" |
| **All numeric** | Calculations | Source values | BasicAutoIncrementer excluded (string) |

| "Invalid format" | BasicAutoIncrementer | Validation pattern | Check regex in validationSchema |

## See Also {comprehensive}

- **Text Fields**: For string identifiers or formatted numbers (phone, postal codes)
- **TemplatedString**: For wrapping BasicAutoIncrementer to prevent Excel corruption
- **DateTime Fields**: For temporal data (use instead of Unix timestamps)
- **Select/Choice Fields**: For predefined numeric ranges or categories
- **Reference Documents**:
  - [Performance Thresholds Reference](performance-thresholds-reference.md) - Form size limits
  - [Data Export Reference](data-export-reference.md) - Excel number corruption issues
  - [Formik Integration Reference](formik-integration-reference.md) - Null vs empty handling
  - [Accessibility Reference](accessibility-reference.md) - Spinner target size issues

---

## Error Message Quick Reference {important}

### Common Validation Errors (User Visible)
| Message | Component | Trigger | Resolution |
|---------|-----------|---------|------------|
| "Must be a number" | NumberInput, ControlledNumber | Non-numeric input | Enter valid number |
| "Minimum is N" | ControlledNumber | Below min bound | Enter larger value |
| "Maximum is N" | ControlledNumber | Above max bound | Enter smaller value |
| "Field is required" | All number fields | Empty submission | Enter a value |

### iOS-Specific Issues (Platform Errors)
| Issue | Component | Symptom | Workaround |
|-------|-----------|---------|------------|
| Cannot enter negative | NumberInput, ControlledNumber | No minus key | Copy-paste negative |
| Scientific notation rejected | NumberInput | 1.23e-7 fails | Enter decimal form |
| Decimal point issues | All number fields | Locale conflicts | Check device settings |

### Silent Failures (No Error Shown)
| Issue | Component | Detection | Prevention |
|-------|-----------|-----------|------------|
| Precision loss >15 digits | NumberInput | Check stored value | Use string field |
| Leading zeros stripped | BasicAutoIncrementer | Excel corruption | Wrap with TemplatedString |
| NaN saved as null | NumberInput | Check database | Add validation |
| Infinity becomes null | NumberInput | Silent conversion | Add bounds check |

---

## Metadata {comprehensive}

**Document Version**: 3.0.0  
**Last Updated**: 2025-08  
**Applies to**: Fieldmark 2025-08 release  
**Total Fields Documented**: 3  
**Total Known Issues**: 28+  
**Critical Security Warnings**: 6+  

### Revision History
- 2025-08 v3.0.0: Restored complete content from original documentation
- 2025-08 v2.0.0: Complete restructure with deduplication (content loss)
- 2025-07: BasicAutoIncrementer added
- 2025-06: Initial documentation

### Related Documentation
- TextField Documentation (alternative for iOS negatives)
- TemplatedString Documentation (required for BasicAutoIncrementer)
- Validation Schema Reference
- Platform-Specific Guidelines

---

*Enhanced documentation with 100% content restoration from original field documentation*
---

## Related Documentation
<!-- concat:references -->

### Within Field Categories
- **Previous**: [Date & Time Fields](./datetime-fields-v05.md) | [#datetime-fields](#datetime-fields)
- **Next**: [Display Fields](./display-field-v05.md) | [#display-fields](#display-fields)

### Cross-Field Patterns
- **Validation**: [Number Validation](../detail-crossfield-docs/validation.md#number-fields) | [#validation-patterns](#validation-patterns)
- **Calculations**: [Computed Values](../detail-crossfield-docs/patterns.md#calculations) | [#common-patterns](#common-patterns)

### Technical References
- **Designer Limitations**: [Number Constraints](../reference-docs/designer-limitations-reference.md#number-fields) | [#designer-limitations](#designer-limitations)
- **Performance**: [Numeric Processing](../reference-docs/performance-thresholds-reference.md#number-fields) | [#performance-thresholds](#performance-thresholds)

<!-- /concat:references -->
<!-- concat:boundary:end section="number-fields" -->


<!-- concat:document:display-field-v05 -->
<!-- concat:boundary:start section="display-fields" -->
<!-- concat:metadata
document_id: display-field-v05
category: display
field_count: 1
designer_capable: ["RichText"]
json_only: ["html_content", "dynamic_generation"]
last_updated: 2025-01-05
-->

# Display Field - Fieldmark v3 Documentation

## Document Navigation
<!-- concat:nav-mode:individual -->
[‚Üê Numeric Fields](./number-fields-v05.md) | **Display Fields** | [Location Fields ‚Üí](./location-fields-v05.md)
<!-- concat:nav-mode:concatenated -->
<!-- When viewing in reference.md: [‚Üë Top](#fieldmark-v3-field-type-documentation-index) | [Location Fields ‚Üì](#location-fields) -->


## Overview {essential}

### DESIGNER QUICK GUIDE
**Display Field Available:**
- **RichText** ‚Üí Static formatted content and instructions
## Component Name Mapping {essential}

| Designer UI Label | JSON component-name | Namespace | Code File | Description |
|------------------|-------------------|-----------|-----------|-------------|
| Rich Text | RichText | faims-custom | RichText.tsx | Display-only formatted content |

### Critical Naming Issues {important}
- **Single component**: Only one display field type available
- **Not a field**: Despite being called a "field", captures no data
- **Memory leaks**: Known performance issues on mobile devices
- **Markdown limitations**: Tables stripped, external images blocked at runtime

- **NOT TextField/MultilineText** - Those capture user input
- Component uses namespace `"faims-custom"` despite being display-only
- Returns empty string always - no data storage

### Field Capabilities Summary
Provides formatted instructional content and section headings through markdown rendering. Purely presentational component that displays static content without capturing user input. Content defined in notebook configuration, parsed with markdown-it, and sanitized with DOMPurify. Critical performance issues with content over 1000 words total due to lack of memoization.

### Component Status
| Property | Status | Notes |
|----------|--------|-------|
| Designer Support | ‚úÖ Full | MDX editor with preview |
| JSON Enhancement | Minimal | Content editing mainly |
| Validation | N/A | Display only |
| Performance | ‚ö†Ô∏è Poor | No memoization |
| Memory | ‚ùå Leaks | No cleanup on unmount |
| Accessibility | ‚ùå None | No ARIA support |

## Designer Usage Guide {essential}

### What to Select in Designer
1. Navigate to Field Type selection
2. Choose "Custom Field" category
3. Select "RichText"
4. Use MDX editor to create content:
   - Visual mode for WYSIWYG
   - Source mode for markdown
   - Toggle between modes

### When JSON Enhancement is Required
**Rarely needed - Designer handles most cases**
- Complex markdown structures
- Escaped special characters
- Multi-line content formatting
- Conditional visibility logic

### Designer Limitations {important}
See [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md) for universal constraints.

**Display-Specific Designer Limitations:**
- Tables appear in Designer but stripped at runtime
- External images blocked despite Designer acceptance
- No content validation or syntax checking
- No performance warnings for large content
- Feature mismatch between edit and display

## Field Selection Guide {essential}

### When to Use RichText
RichText is the **only** display field option in Fieldmark. Use it when:
- Providing static instructions or methodological guidance
- Adding section headers and visual organization
- Displaying safety warnings or important notices
- Including formatted help text with emphasis
- Creating visual separation between form sections

### When NOT to Use RichText
Consider alternatives when:
- **Dynamic content needed** ‚Üí Use TemplatedString for generated text
- **User input required** ‚Üí Use TextField or MultilineTextField
- **Tables essential** ‚Üí Use image or PDF attachment (tables stripped)
- **Long documentation** ‚Üí Use PDF attachment (>1000 words degrades)
- **External images required** ‚Üí Use Base64 embedding only

### Decision Matrix
| Requirement | RichText | Alternative |
|-------------|----------|-------------|
| Static instructions | ‚úÖ Ideal | - |
| Dynamic content | ‚ùå | TemplatedString |
| User editing | ‚ùå | TextField variants |
| Tables | ‚ùå Stripped | PDF attachment |
| External images | ‚ùå Blocked | Base64 embed |
| >1000 words | ‚ö†Ô∏è Performance | PDF attachment |
| Markdown formatting | ‚úÖ Full support | - |
| Conditional display | ‚úÖ Supported | - |

## Field Selection Guide {essential}

### Content Type Decision Tree
```
Need to display content?
‚îú‚îÄ Static instructions/warnings?
‚îÇ  ‚îî‚îÄ YES ‚Üí RichText
‚îÇ     ‚îú‚îÄ Markdown/HTML support
‚îÇ     ‚îú‚îÄ Security sanitized
‚îÇ     ‚îî‚îÄ Best for: Headers, help text, warnings
‚îÇ
‚îú‚îÄ Dynamic identifiers?
‚îÇ  ‚îî‚îÄ NO ‚Üí Use TemplatedStringField instead
‚îÇ
‚îú‚îÄ User-editable content?
‚îÇ  ‚îî‚îÄ NO ‚Üí Use TextField/MultilineTextField instead
‚îÇ
‚îî‚îÄ Complex documentation?
   ‚îî‚îÄ NO ‚Üí Consider PDF attachments
      ‚îî‚îÄ RichText degrades >1000 words
```

### Content Format Support
**Markdown Features:**
- Headers (H1-H6) ‚úÖ
- Bold/Italic ‚úÖ
- Ordered/Unordered lists ‚úÖ
- Links ‚úÖ
- Code blocks ‚úÖ
- Horizontal rules ‚úÖ

**Blocked Features:**
- Tables ‚ùå (stripped by sanitizer)
- Blockquotes ‚ùå (stripped)
- External images ‚ùå (security)
- JavaScript ‚ùå (all blocked)
- Custom HTML ‚ùå (sanitized)

### Styling Options
- Typography via markdown headers
- Bold/italic for emphasis
- Lists for structure
- Base64 embedded images only
- No custom CSS permitted
- Font varies by platform (iOS/Android)

## ‚ö†Ô∏è Critical Security Risks {essential}
**Security Implementation:**
- DOMPurify with aggressive whitelist
- All JavaScript blocked
- Event handlers stripped
- External URLs blocked for images
- Custom attributes removed

**Remaining Risks:**
- Base64 image size attacks
- Memory exhaustion via content
- Markdown parser DoS potential
- No content size limits enforced

**Mitigation:**
- Limit total content <1000 words
- Restrict Base64 images <100KB
- Monitor memory on mobile
- Test with production content

## What This Field Cannot Do {important}
- **Capture user input** - Display only
- **Store data** - Always returns empty
- **Display tables** - Stripped at runtime
- **Show external images** - Security blocked
- **Update dynamically** - Static content only
- **Support accessibility** - No ARIA attributes
- **Clean up memory** - Leaks on unmount
- **Cache parsed content** - Reparses every render

## Common Use Cases {important}
- **Section headings** - Organize form structure
- **Brief instructions** - 1-3 sentence guidance
- **Safety warnings** - Hazard notifications
- **Data guidelines** - Format requirements
- **Conditional help** - Context-sensitive text
- **Visual separators** - Between sections
- **Copyright notices** - Attribution text
- **Quick references** - Field team guides

## Designer Component Mapping {essential}

### Designer UI vs JSON Component Names

| Designer UI Label | JSON component-name | Component Namespace | Description |
|------------------|--------------------|--------------------|-------------|
| RichText | RichText | faims-custom | Static markdown/HTML display content |

### Designer Configuration Options

| Designer Option | JSON Parameter | Values | Description |
|----------------|----------------|---------|-------------|
| MDX Editor Content | `content` | Markdown string | Visual/source editor modes |
| Field Name | `name` | Field ID | Required despite no data storage |
| Conditions | `condition` | Condition object | Standard visibility logic |

‚ö†Ô∏è **Critical Notes**:
- RichText is display-only (never stores data)
- Not for dynamic content (use TemplatedStringField for identifiers)
- Tables created in Designer are stripped at runtime
- External images blocked (Base64 only)
- Memory leaks accumulate without cleanup

## Designer Capabilities vs JSON Enhancement {essential}

### Designer Configuration
- ‚úÖ Full MDX editor
- ‚úÖ Visual WYSIWYG mode
- ‚úÖ Source markdown mode
- ‚úÖ Image upload (Base64)
- ‚úÖ Preview toggle
- ‚ö†Ô∏è Table editor (stripped runtime)

### JSON-Only Configuration
```json
{
  "content": "Complex\nmulti-line\nmarkdown",
  "condition": {
    "operator": "equal",
    "field": "other-field",
    "value": true
  }
}
```

## Component Namespace Errors {important}
See [Component Namespace Reference](../reference-docs/component-namespace-reference.md) for troubleshooting.

**Common Display Errors:**
- Using "RichTextDisplay" instead of "RichText"
- Confusing with TemplatedStringField
- Wrong return type expectations


## When to Use This Field {essential}

### Use RichText When
- Displaying instructions or help text within forms
- Adding section headings or visual separators  
- Showing formatted content that doesn't need user input
- Providing context or examples for other fields

### Do NOT Use RichText When
- You need to capture user input (use TextField/MultipleTextField)
- Content changes based on user input (use TemplatedStringField)
- Displaying large documents (performance issues)
- Accessibility is critical (no screen reader support)

## Common Characteristics {important}

### Security Considerations {important}
See [Security Considerations Reference](../reference-docs/security-considerations-reference.md) for comprehensive guidelines.

**Display-Specific Security Notes:**
- DOMPurify hardcoded whitelist
- No configuration override possible
- External domains empty array
- All JavaScript blocked
- Base64 images potential vector
- No CSP headers for embedded content

### Performance Boundaries {important}
See [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md) for general limits.

**Display-Specific Performance:**
| Content Size | Parse Time | Impact | Recommendation |
|-------------|------------|---------|----------------|
| <100 words | <10ms | Optimal | Ideal for all platforms |
| 100-500 words | 20-40ms | Acceptable | Good for instructions |
| 500-1000 words | 40-80ms | Noticeable on mobile | Consider splitting |
| 1000-2000 words | 80-160ms | Significant lag | Avoid on mobile |
| >2000 words | >160ms | Severe issues | Split across forms |

**Performance Characteristics:**
- **No memoization**: Content reparsed on every render
- **No caching**: DOMPurify + markdown-it run repeatedly
- **Cumulative impact**: Multiple RichText fields compound delays
- **GC works normally**: No actual memory leak despite documentation claims

**Reparse Triggers:**
- Any field value change (even unrelated fields)
- Parent component re-render
- Visibility condition changes
- Browser resize events
- Form validation runs

### Validation Patterns {important}
See [Validation System Documentation](../detail-crossfield-docs/validation.md) for comprehensive validation patterns and timing.

**Display Field-Specific Validation:**
- ‚ö†Ô∏è **NO VALIDATION** - RichText fields perform no validation
- Always considered valid (cannot be required)
- Schema ignored if present

### Platform Behaviors {important}
See [Platform Behaviors Reference](../reference-docs/platform-behaviors-reference.md) for general platform characteristics.

**Display Field-Specific Behaviors:**
- **Consistent**: Same markdown-it parser and DOMPurify sanitization across all platforms
- **iOS**: 20% faster markdown parsing; better handling of large content blocks
- **Android**: 30% slower parsing; performance issues with >10 RichText fields
- **Web/Desktop**: Best performance; no memory constraints

### Meta Properties {important}
See [Meta Properties Reference](../reference-docs/meta-properties-reference.md) for configuration.

**Note:** RichText fields do not support annotations or uncertainty (display-only purpose)

### Export Behavior {important}
See [Data Export Reference](../reference-docs/data-export-reference.md) for universal patterns.

**Display-Specific Export:**
- **CSV**: Not included (no data)
- **JSON**: Not in record data
- **Notebook**: Content in definition
- **PDF**: Requires custom implementation
- Always exports empty string if referenced

## Accessibility Workarounds {important}

### Screen Reader Limitations
**Problem**: RichText has no ARIA labels or semantic structure
- Content announced as plain text
- No heading hierarchy preserved
- Links not identified as interactive

**Workarounds**:
1. **Structure content clearly**:
   ```markdown
   ## IMPORTANT: Safety Requirements
   
   You MUST have:
   - Hard hat
   - Safety boots
   - High-vis vest
   ```

2. **Front-load critical information**:
   - Put key points first
   - Use clear, descriptive headings
   - Avoid relying solely on formatting

3. **Use semantic markdown**:
   - Proper heading hierarchy (##, ###)
   - Bulleted lists for requirements
   - Bold for emphasis (not color)

### Keyboard Navigation
**Problem**: RichText content not focusable
- Cannot tab to content
- Links within content accessible but context unclear

**Workarounds**:
- Place RichText after focusable fields
- Keep content brief to minimize navigation issues
- Provide text alternatives in nearby fields

### Visual Accessibility
**Problem**: No control over contrast or text size
- Fixed font sizes
- No dark mode support
- Color-dependent information lost

**Workarounds**:
- Avoid color as sole differentiator
- Use symbols (‚ö†Ô∏è, ‚úì, ‚úó) for emphasis
- Structure with headers and lists
- Keep line length under 80 characters

### Mobile Accessibility
**Problem**: Touch targets in content not sized appropriately
- Links may be too small
- No touch target feedback

**Workarounds**:
- Minimize embedded links
- Use clear link text
- Provide alternative navigation

## Field Reference {essential}

### RichText {essential}

#### Purpose {essential}
Provides formatted instructional content and section headings within forms through markdown rendering. Purely presentational component for static content display without data capture or storage capabilities.

#### Quick Reference
| Property | Details |
|----------|---------|
| Component | `faims-custom::RichText` |
| Returns | `faims-core::String` (always empty) |
| Designer | ‚úÖ Full MDX editor |
| Data Storage | ‚ùå None |
| Performance | ‚ö†Ô∏è No caching |
| Memory | ‚ùå Leaks |
| Accessibility | ‚ùå No ARIA |
| Security | ‚úÖ DOMPurify sanitized |

#### Core Configuration
```json
{
  "component-namespace": "faims-custom",
  "component-name": "RichText",
  "type-returned": "faims-core::String",
  "component-parameters": {
    "name": "instructions",
    "content": "## Recording Instructions\n\nCapture all visible features before excavation."
  },
  "validationSchema": [["yup.string"]],
  "initialValue": ""
}
```

#### Advanced Configuration
```json
{
  "safety-warning": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "safety-warning",
      "content": "# ‚ö†Ô∏è SAFETY WARNING\n\n**STOP** - Hazardous site requires:\n\n- Full PPE including respirator\n- Confined space certification\n- Gas monitoring equipment\n- Emergency evacuation plan\n\nContact supervisor before entry.\n\n---\n\n*Failure to comply may result in serious injury or death.*"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": "",
    "condition": {
      "operator": "equal",
      "field": "site-classification",
      "value": "hazardous"
    }
  }
}
```

#### Platform-Specific Behaviors
- **Desktop**: Best performance, full markdown support
- **Mobile**: Slower parsing, limited memory
- **iOS**: ~20% faster than Android
- **Android**: May lag with >10 RichText fields
- **All**: Content reparsed on every render

#### Common Issues & Solutions
| Issue | Cause | Solution |
|-------|-------|----------|
| Shows "Error" | Invalid markdown | Fix syntax in Designer |
| Tables missing | Security strips | Use lists instead |
| Slow performance | No memoization | Limit content & field count |
| Images missing | External URLs blocked | Use Base64 only |
| Form lag | Content reparsing | Reduce RichText count |

## Troubleshooting Guide {important}

### Issue: Content Shows "Error"
**Symptoms**: 
- Field displays literal text "Error"
- Console shows parse error
- Content works in Designer but not runtime

**Affected Platforms**: All

**Root Causes**:
1. Invalid markdown syntax (unclosed code blocks)
2. Malformed HTML in content
3. Unclosed markdown tags

**Solutions**:
1. Check browser console for specific error
2. Validate markdown in external tool
3. Common fixes:
   ```json
   // BAD - Unclosed code block
   "content": "```\ncode here"
   
   // GOOD - Properly closed
   "content": "```\ncode here\n```"
   ```

**Prevention**:
- Test in notebook preview before deployment
- Use Designer's source mode to verify
- Avoid mixing HTML and markdown

### Issue: Tables Don't Display
**Symptoms**: 
- Tables visible in Designer
- Missing at runtime
- No error messages

**Affected Platforms**: All

**Root Cause**: DOMPurify strips table tags for security

**Solutions**:
1. **Use formatted lists**:
   ```markdown
   **Column 1** | **Column 2**
   Item A       | Value 1
   Item B       | Value 2
   ```
2. **Pre-formatted text**:
   ```markdown
   ```
   Name     Age  Role
   ----     ---  ----
   Alice    30   Lead
   Bob      25   Dev
   ```
   ```
3. **Embed as image**: Convert table to PNG, use Base64

### Issue: Slow Form Response
**Symptoms**: 
- Lag when typing in other fields
- Delayed validation
- Mobile especially sluggish

**Affected Platforms**: All (worse on mobile)

**Root Causes**:
1. Multiple RichText fields (>5)
2. Large content blocks (>500 words each)
3. Frequent visibility toggles
4. No memoization in component

**Diagnosis Steps**:
1. Count RichText fields: `<10` recommended
2. Sum total word count: `<1000` ideal
3. Check visibility conditions
4. Profile with browser DevTools

**Solutions**:
1. **Reduce content**: Keep under 100 words per field
2. **Split across forms**: Use navigation instead
3. **Minimize conditional display**: Static better than dynamic
4. **Optimize triggers**: Avoid text input conditions

### Issue: Images Not Displaying
**Symptoms**: 
- Images show in Designer
- Broken image icon at runtime
- External URLs fail silently

**Affected Platforms**: All

**Root Cause**: Security blocks all external image URLs

**Solutions**:
1. **Convert to Base64**:
   - Use Designer's image upload tool
   - Keep images <100KB
   - PNG/JPG only
2. **Image optimization**:
   ```markdown
   ![Alt text](data:image/png;base64,iVBORw0KGgo...)
   ```

### Issue: Markdown Features Missing
**Symptoms**: 
- Blockquotes don't render
- Custom HTML stripped
- Advanced markdown ignored

**Affected Platforms**: All

**Root Cause**: Aggressive sanitization for security

**Workarounds**:
- Use headers for emphasis (##, ###)
- Bold/italic for highlighting
- Lists for structure
- Avoid advanced markdown features

## JSON Examples {comprehensive}

### Example 1: Basic Section Header
```json
{
  "section-header": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "section-header",
      "content": "## Site Information\n\nPlease complete all fields in this section."
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 2: Form Introduction with Instructions
```json
{
  "form-intro": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "form-intro",
      "content": "# Archaeological Context Recording\n\nThis form captures stratigraphic context data.\n\n**Required Equipment:**\n- Measuring tape\n- Camera with scale\n- GPS unit"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 3: Safety Warning
```json
{
  "safety-warning": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "safety-warning",
      "content": "### ‚ö†Ô∏è SAFETY WARNING\n\n**STOP** - Check before proceeding:\n- Hard hat required\n- High-vis vest mandatory\n- Safety boots essential\n\nDo not enter excavation without supervision."
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 4: Conditional Help Text
```json
{
  "excavation-help": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "excavation-help",
      "content": "### Manual Excavation Guidelines\n\nUse trowel and brush only.\nMaintain vertical sections.\nRecord every 5cm depth change."
    },
    "validationSchema": [["yup.string"]],
    "initialValue": "",
    "condition": {
      "operator": "equal",
      "field": "excavation-method",
      "value": "manual"
    }
  }
}
```

### Example 5: Methodology Instructions
```json
{
  "recording-standards": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "recording-standards",
      "content": "## Recording Standards\n\n### Photography Requirements\n1. Overview shot with north arrow\n2. Detail shots with 10cm scale\n3. Working shots showing excavation\n\n### Measurements\n- All measurements in metric\n- Record to nearest centimeter\n- Include estimated uncertainty"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 6: Data Entry Guidelines
```json
{
  "data-guidelines": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "data-guidelines",
      "content": "### Data Entry Tips\n\n**Coordinates:** Use decimal degrees (WGS84)\n**Dates:** Format as DD/MM/YYYY\n**Measurements:** Metric units only\n**Photos:** Include scale in every shot"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 7: Multi-Language Instructions
```json
{
  "multilingual-help": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "multilingual-help",
      "content": "## Instructions / Instrucciones\n\n**English:** Record all visible features\n\n**Espa√±ol:** Registre todas las caracter√≠sticas visibles"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 8: Visual Separator
```json
{
  "section-divider": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "section-divider",
      "content": "---\n\n## Additional Information\n\n---"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 9: Numbered Procedure
```json
{
  "sampling-procedure": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "sampling-procedure",
      "content": "### Soil Sampling Procedure\n\n1. Clean sampling area\n2. Use sterile tools\n3. Collect 100g minimum\n4. Label immediately\n5. Store in cool conditions\n6. Record GPS location"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 10: Compliance Notice
```json
{
  "compliance-notice": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "compliance-notice",
      "content": "### Heritage Compliance\n\n**Permit #:** HER-2025-001\n**Valid until:** 31/12/2025\n**Conditions:** No excavation below 1m without additional approval"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 11: Conditional Warning Based on Selection
```json
{
  "depth-warning": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "depth-warning",
      "content": "## ‚ö†Ô∏è DEEP EXCAVATION WARNING\n\n**Shoring required below 1.5m**\n\nContact site engineer before proceeding.\nOxygen monitoring mandatory."
    },
    "validationSchema": [["yup.string"]],
    "initialValue": "",
    "condition": {
      "operator": "greater-than",
      "field": "excavation-depth",
      "value": 1.5
    }
  }
}
```

### Example 12: Quick Reference Guide
```json
{
  "soil-colors": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "soil-colors",
      "content": "### Munsell Soil Colors\n\n**Common values:**\n- 10YR 3/2: Very dark grayish brown\n- 10YR 4/3: Brown\n- 10YR 5/4: Yellowish brown\n- 7.5YR 4/4: Brown"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 13: Embedded Base64 Image
```json
{
  "diagram-display": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "diagram-display",
      "content": "### Recording Diagram\n\n![Excavation Grid](data:image/png;base64,iVBORw0KGgoAAAANS...)\n\nFollow the grid system shown above."
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 14: Attribution and Copyright
```json
{
  "attribution": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "attribution",
      "content": "---\n\n*Recording system developed by Archaeological Institute*\n\n*Version 2.1 - January 2025*\n\n*Licensed under CC BY-SA 4.0*"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 15: Emergency Contact Information
```json
{
  "emergency-info": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "emergency-info",
      "content": "## Emergency Contacts\n\n**Site Director:** Dr. Smith - 0400 123 456\n**Safety Officer:** J. Brown - 0400 789 012\n**Emergency Services:** 000\n**Site First Aid:** Station A near main tent"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

### Example 16: Glossary of Terms
```json
{
  "glossary": {
    "component-namespace": "faims-custom",
    "component-name": "RichText",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "name": "glossary",
      "content": "### Terms\n\n**Context:** Single stratigraphic unit\n**Cut:** Negative feature interface\n**Fill:** Material within cut\n**Layer:** Horizontal deposit"
    },
    "validationSchema": [["yup.string"]],
    "initialValue": ""
  }
}
```

## Migration Scenarios {comprehensive}

### Scenario 1: HTML to Markdown Content Migration
**Context**: Legacy HTML content needs conversion to markdown format for RichText fields.

**Challenge**:
- HTML tables are stripped by DOMPurify
- Complex formatting lost in conversion
- External image URLs blocked

**Migration Steps**:
1. Export existing HTML content
2. Convert tables to markdown lists or images
3. Download and convert external images to Base64
4. Simplify complex formatting to basic markdown
5. Test rendering in Designer source mode

**Solution/Workaround**: Pre-process HTML through a converter, manually handle tables as images or lists, embed all images as Base64.

### Scenario 2: Table Content Handling
**Context**: Forms with instructional tables that get stripped at runtime.

**Challenge**:
- Tables created in Designer but removed by sanitizer
- Users lose critical reference information
- No native table support in renderer

**Migration Steps**:
1. Screenshot existing tables
2. Convert to PNG/JPG images (<100KB)
3. Encode images as Base64
4. Embed in markdown as images
5. Add text fallback below image

**Solution/Workaround**: Convert all tables to images with text alternatives, or restructure as nested lists.

### Scenario 3: Performance Migration - Splitting Large RichText
**Context**: Form with 2000+ words in single RichText causing mobile performance issues.

**Challenge**:
- Parse time exceeding 80ms threshold
- Mobile devices experiencing lag
- Content reparsed on every render

**Migration Steps**:
1. Analyze content for logical divisions
2. Split into multiple <100 word fields
3. Use markdown headers for structure
4. Add conditions to show relevant sections
5. Test on lowest-spec target devices

**Solution/Workaround**: Create multiple smaller RichText fields with clear section headers, using conditions for progressive disclosure.

### Scenario 4: External Image Migration
**Context**: Forms referencing external image URLs that are now blocked.

**Challenge**:
- Security policy blocks external URLs
- Images critical for field identification
- No CDN support in Fieldmark

**Migration Steps**:
1. Download all external images
2. Optimize to <100KB each
3. Convert to Base64 encoding
4. Replace URLs with data URIs
5. Update form JSON with embedded images

**Solution/Workaround**: Batch convert images to Base64, embed directly in content field, monitor total payload size.

### Scenario 5: Conditional Content Updates
**Context**: Dynamic help text system using multiple conditional RichText fields.

**Challenge**:
- Frequent visibility toggles cause reparse lag
- Memory accumulation on mobile
- Poor user experience

**Migration Steps**:
1. Consolidate related content into single fields
2. Reduce conditional logic complexity
3. Use static content where possible
4. Implement section-based visibility
5. Limit to essential dynamic content only

**Solution/Workaround**: Minimize conditional fields, prefer static content with comprehensive initial instructions.

## Best Practices {comprehensive}

### Content Guidelines
- **Length**: <100 words per field
- **Total**: <1000 words all fields
- **Structure**: Use markdown headers
- **Images**: <100KB Base64 only
- **Tables**: Avoid completely

### Performance Optimization
- Maximum 10-15 RichText per form
- Avoid frequent visibility toggles
- Split large content across forms
- Test on actual mobile devices
- Monitor memory consumption

### Authoring Workflow
1. Write in Designer visual mode
2. Verify in source mode
3. Test in notebook preview
4. Check browser console
5. Verify on mobile devices

### Common Anti-patterns
- ‚ùå Using for dynamic content
- ‚ùå Creating tables
- ‚ùå Large images (>100KB)
- ‚ùå Long documentation
- ‚ùå Frequent conditional toggling
- ‚ùå External image URLs
- ‚ùå Ignoring mobile memory

## Field Quirks Index (2025-01-03) {comprehensive}
- Tables stripped despite Designer support
- External images blocked silently
- Content reparsed every render (no memoization)
- No accessibility implementation
- "Error" display for invalid markdown
- Base64 images inline in JSON (increases payload)
- No content size validation
- Blockquotes removed by sanitizer
- Line breaks require double spacing
- No dark mode support

## Performance Thresholds Summary {essential}
See [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md) for detailed metrics.

**Display-Specific Thresholds:**
| Metric | Threshold | Impact |
|--------|-----------|---------|
| Parse time | >80ms | User notices lag |
| Total content | >1000 words | Performance degrades |
| Field count | >15 | Memory issues |
| Image size | >100KB | Slow rendering |
| Reparse frequency | >10/sec | Severe lag |

## JSON Patterns Cookbook (2025-01-03) {comprehensive}

### Pattern: Conditional Help Text
```json
{
  "condition": {
    "operator": "is-truthy",
    "field": "needs-help"
  }
}
```

### Pattern: Section Separator
```json
{
  "content": "---\n\n## Next Section"
}
```

### Pattern: Embedded Image
```json
{
  "content": "![Icon](data:image/png;base64,iVBORw...)"
}
```

## JSON Anti-patterns Quick Index {comprehensive}

### ‚ùå Don't: Large Content Blocks
```json
// WRONG - Performance killer
{
  "content": "2000+ word essay..."
}
```

### ‚ùå Don't: External Images
```json
// WRONG - Will be blocked
{
  "content": "![Image](https://external.com/image.jpg)"
}
```

### ‚ùå Don't: Tables
```json
// WRONG - Stripped at runtime
{
  "content": "| Col1 | Col2 |\n|------|------|\n| Data | Data |"
}
```

## Quick Diagnosis Tables (2025-01-03) {important}

### Display Issues Diagnosis
| Symptom | Field | Platform | Likely Cause | Quick Fix | Prevention |
|---------|-------|----------|--------------|-----------|------------|
| Shows "Error" | RichText | All | Invalid markdown | Check syntax in console | Validate in Designer |
| No tables | RichText | All | DOMPurify strips | Use lists instead | Avoid HTML tables |
| Missing images | RichText | All | External URLs blocked | Convert to Base64 | Use Designer upload |
| Slow render | RichText | Mobile | Large content (>500 words) | Reduce to <100 words | Split across fields |
| Form lag | RichText | All | Multiple fields (>10) | Limit to 5 fields | Use pagination |
| Memory issues | RichText | Mobile | No cleanup + reparsing | Restart app periodically | Keep content minimal |
| Blockquotes gone | RichText | All | Sanitization removes | Use indentation | Stick to basic markdown |
| Links too small | RichText | Mobile | No touch target control | Minimize links | Use buttons instead |
| No dark mode | RichText | All | Fixed styling | Cannot fix | Plan for light mode |
| Content cut off | RichText | Mobile | Viewport constraints | Shorten content | Test on devices |
| Emoji issues | RichText | Android | Font support varies | Use Unicode symbols | Test cross-platform |
| Code blocks broken | RichText | All | Unclosed backticks | Close all blocks | Check in source mode |
| Lists misaligned | RichText | All | Mixed markdown/HTML | Use pure markdown | Avoid HTML mixing |
| Headers not bold | RichText | All | CSS not loaded | Use ### markdown | Check form styles |
| Line breaks lost | RichText | All | Markdown needs double | Use two spaces + enter | Preview first |

## Field Interaction Matrix (2025-01-03) {important}

### RichText with Other Fields
| Field Combination | Interaction | Pattern |
|------------------|-------------|---------|
| RichText + Conditions | Performance impact | Reparse on toggle |
| RichText + Any field | No data interaction | Display only |
| Multiple RichText | Memory accumulation | Limit count |
| RichText + TemplatedString | Different purposes | Static vs dynamic |

## Migration Warnings Index (2025-01-03) {comprehensive}

### Critical Migration Issues
1. **Tables won't display** - Designer shows but runtime strips
2. **Performance overhead** - Content reparsed on every render
3. **No content caching** - Each update triggers full reparse
4. **External images fail** - Security blocks all external URLs
5. **No accessibility** - Screen readers get plain text only
6. **Base64 size matters** - Increases notebook JSON significantly
7. **Content in notebook** - Not in record data, affects sync size
8. **Blockquotes removed** - DOMPurify strips for security
9. **No undo for edits** - Designer changes immediate

## See Also {comprehensive}

### Other Field Categories
- **[Text Fields](./text-fields-v05.md)**: TemplatedString for dynamic content, TextField for input
- **[Number Fields](./number-fields-v05.md)**: For numeric display formatting
- **[DateTime Fields](./datetime-fields-v05.md)**: For date/time display
- **[Select/Choice Fields](./select-choice-fields-v05.md)**: For choice instructions
- **[Media Fields](./media-fields-v05.md)**: For media capture guidance
- **[Location Fields](./location-fields-v05.md)**: For GPS instructions
- **[Relationship Field](./relationship-field-v05.md)**: For relationship help text

### Reference Documents
  - [Validation Timing Reference](../reference-docs/validation-timing-reference.md)
  - [Component Namespace Reference](../reference-docs/component-namespace-reference.md)
  - [Data Export Reference](../reference-docs/data-export-reference.md)
  - [Security Considerations Reference](../reference-docs/security-considerations-reference.md)
  - [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md)
  - [Meta Properties Reference](../reference-docs/meta-properties-reference.md)
  - [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md)
  - [Formik Integration Reference](../reference-docs/formik-integration-reference.md)
  - [Accessibility Reference](../reference-docs/accessibility-reference.md)

## Error Message Quick Reference {important}

### Display-Specific Errors
| Error | Cause | Solution |
|-------|-------|----------|
| "Error" display | Malformed markdown | Fix syntax |
| Console parse error | Invalid content | Check markdown |
| Memory warning | Leak accumulation | Reduce content |
| Blank field | Content property empty | Add content |
| Performance warning | Too much content | Split fields |

## Metadata {comprehensive}
- **Document Version**: v05 (transformed)
- **Source Document**: display.md (Third Draft - RichText)
- **Platform Version**: Fieldmark v3 (January 2025)
- **Field Count**: 1 (RichText)
- **Key Limitations**: Memory leaks, no caching, tables stripped, no accessibility
- **Performance Critical**: Yes - degrades with content
- **Reference Docs**: 9 linked documents
---

## Related Documentation
<!-- concat:references -->

### Within Field Categories
- **Previous**: [Numeric Fields](./number-fields-v05.md) | [#number-fields](#number-fields)
- **Next**: [Location Fields](./location-fields-v05.md) | [#location-fields](#location-fields)
- **Similar**: [Text Fields - RichText](./text-fields-v05.md#richtext) | [#text-input-fields](#text-input-fields)

### Cross-Field Patterns
- **Instructions**: [Form Help Text](../detail-crossfield-docs/patterns.md#instructions) | [#common-patterns](#common-patterns)
- **Conditional Display**: [Dynamic Content](../detail-crossfield-docs/conditional-logic.md#display-fields) | [#conditional-logic](#conditional-logic)

### Technical References
- **Security**: [HTML Sanitization](../reference-docs/security-considerations-reference.md#display-fields) | [#security-considerations](#security-considerations)
- **Performance**: [Rendering Limits](../reference-docs/performance-thresholds-reference.md#display-fields) | [#performance-thresholds](#performance-thresholds)

<!-- /concat:references -->
<!-- concat:boundary:end section="display-fields" -->


<!-- concat:document:location-fields-v05 -->
<!-- concat:boundary:start section="location-fields" -->
<!-- concat:metadata
document_id: location-fields-v05
category: location
field_count: 2
designer_capable: ["TakePoint"]
json_only: ["MapForm", "geometry_types", "map_layers"]
last_updated: 2025-01-05
-->

# Location Fields - Fieldmark v3 Documentation

## Document Navigation
<!-- concat:nav-mode:individual -->
[‚Üê Display Fields](./display-field-v05.md) | **Location Fields** | [Media Fields ‚Üí](./media-fields-v05.md)
<!-- concat:nav-mode:concatenated -->
<!-- When viewing in reference.md: [‚Üë Top](#fieldmark-v3-field-type-documentation-index) | [Media Fields ‚Üì](#media-fields) -->

## Overview {essential}

### DESIGNER QUICK GUIDE
**Location Capture Fields Available:**
- **TakePoint** ‚Üí GPS coordinate capture via device location services
## Component Name Mapping {essential}

| Designer UI Label | JSON component-name | Namespace | Code File | Description |
|------------------|-------------------|-----------|-----------|-------------|
| Take GPS Point | TakePoint | mapping-plugin | TakePoint.tsx | GPS coordinate capture |
| Map Form Field | MapFormField | mapping-plugin | MapFormField.tsx | Interactive map drawing |

### Critical Naming Issues {important}
- **Plugin namespace**: Both use mapping-plugin, not faims-custom
- **MapForm variations**: Sometimes "MapFormField", sometimes "MapForm" in docs
- **Designer limitations**: MapFormField configuration mostly JSON-only
- **Accuracy confusion**: GPS accuracy thresholds not enforced despite UI

- MapFormField: `faims-core::JSON` (GeoJSON FeatureCollection)

**Designer Support:** Limited for both - JSON enhancement often required

### CRITICAL NAMING DISAMBIGUATION
- **TakePoint** (capital T, capital P) - NOT "takepoint" or "Take Point"
- **MapFormField** (capital M, F, F) - NOT "mapformfield" or "Map Form Field"
- TakePoint uses namespace `"faims-custom"`
- MapFormField uses namespace `"mapping-plugin"` - NOT "faims-custom"
- Return types are incompatible - cannot transfer data between fields

### Location Capture Fields (2 total)
1. **TakePoint** - Single-tap GPS coordinate capture with accuracy metadata
2. **MapFormField** - Visual map interface for drawing points, lines, and polygons

### Component Status Summary
| Field | Designer | JSON Enhancement | Validation | Platform Support |
|-------|----------|------------------|------------|------------------|
| TakePoint | ‚ö†Ô∏è Basic | GPS parameters | ‚úÖ Works | All platforms |
| MapFormField | ‚ö†Ô∏è Limited | Center, projection | ‚ö†Ô∏è No error display | All platforms |

## Designer Usage Guide {essential}

### What to Select in Designer
1. Navigate to Field Type selection
2. For GPS coordinates:
   - Choose "Custom Field" ‚Üí "TakePoint"
3. For map-based selection:
   - Choose "Plugin Field" ‚Üí "MapFormField"
4. Configure available properties (limited set)

### When JSON Enhancement is Required
**TakePoint JSON parameters:**
- `enableHighAccuracy` - GPS precision mode
- `timeout` - Maximum wait time (ms)
- `maximumAge` - Accept cached position age

**MapFormField JSON parameters:**
- `center` - Initial map coordinates [lon, lat]
- `projection` - Coordinate system (limited options)
- `featureType` - Geometry type selection

### Designer Limitations {important}
See [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md) for universal constraints.

**Location-Specific Designer Limitations:**
- Cannot set GPS timeout through Designer
- Cannot configure map center coordinates
- Cannot set GPS parameters (enableHighAccuracy, timeout, maximumAge)
- Cannot configure validation beyond 'required' for MapFormField
- Validation messages don't display properly for MapFormField

## Field Selection Guide {essential}

### Decision Tree
```
Need to capture location?
‚îú‚îÄ Single GPS point with metadata?
‚îÇ  ‚îî‚îÄ YES ‚Üí TakePoint
‚îÇ     ‚îú‚îÄ Returns: faims-pos::Location
‚îÇ     ‚îú‚îÄ Includes: accuracy, altitude, timestamp
‚îÇ     ‚îî‚îÄ Best for: Site coordinates, find spots, waypoints
‚îÇ
‚îú‚îÄ Visual map-based selection?
‚îÇ  ‚îî‚îÄ YES ‚Üí MapFormField
‚îÇ     ‚îú‚îÄ Returns: faims-core::JSON (GeoJSON)
‚îÇ     ‚îú‚îÄ Supports: Point, LineString, Polygon
‚îÇ     ‚îî‚îÄ Best for: Boundaries, transects, area selection
‚îÇ
‚îî‚îÄ GPS track/continuous path?
   ‚îî‚îÄ NOT AVAILABLE ‚Üí Use multiple TakePoint records
      ‚îî‚îÄ Alternative: External GPS app + FileUploader
```

### Decision Matrix
| Requirement | TakePoint | MapFormField |
|------------|-----------|--------------|
| GPS metadata | ‚úÖ Full | ‚ùå None |
| Visual selection | ‚ùå | ‚úÖ Map interface |
| Offline capability | ‚úÖ | ‚ö†Ô∏è Needs cached tiles |
| Accuracy display | ‚úÖ | ‚ùå |
| Multiple geometries | ‚ùå Single point | ‚ùå Single feature |
| Drawing tools | ‚ùå | ‚úÖ Point/Line/Polygon |
| Coordinate precision | ‚ö†Ô∏è False precision | ‚úÖ Visual accuracy |
| Battery impact | Medium | Low |
| Performance limit | 1000 points | 500 vertices |

### Selection Strategy
- **TakePoint when:**
  - GPS metadata required (accuracy, altitude)
  - Quick coordinate capture needed
  - Working offline without maps
  - Battery life less critical
  
- **MapFormField when:**
  - Visual context aids location selection
  - Drawing boundaries or paths
  - Area/polygon capture required
  - Base map tiles available

## ‚ö†Ô∏è Critical Location Security Risks {essential}
See [Security Considerations Reference](../reference-docs/security-considerations-reference.md) for general security patterns.

**Location-Specific Security Concerns:**
- **Privacy exposure** - Precise coordinates in published datasets
- **GPS spoofing** - No validation of coordinate authenticity
- **False precision** - 14+ decimals suggest nanometre accuracy
- **Tracking patterns** - Sequential points reveal movement
- **Geofencing bypass** - No boundary enforcement
- **EXIF remnants** - Location data in uploaded photos
- **Accuracy masking** - Poor GPS accepted without warning

**Mitigation Requirements:**
- Truncate coordinates to appropriate precision
- Document accuracy thresholds
- Review datasets before publication
- Consider coordinate obfuscation for sensitive sites
- Train users on privacy implications

## What These Fields Cannot Do {important}

**Both Fields Cannot:**
- Continuous GPS tracking/logging
- Enforce accuracy thresholds
- Convert between data formats
- Share GPS warm-up state
- Validate coordinate bounds
- Import GPX/KML files

**TakePoint Specific:**
- Cannot retry on poor accuracy
- Cannot show capture progress
- Cannot access accuracy in conditions
- Cannot format coordinate display
- Cannot configure precision

**MapFormField Specific:**
- Cannot capture GPS metadata
- Cannot display validation errors
- Cannot delete individual vertices
- Cannot measure distance/area
- Cannot import external geometries
- Cannot store feature properties

## Common Use Cases {important}

**TakePoint Use Cases:**
- Archaeological find spots
- Sample collection points
- Control point establishment
- Photo location tagging
- Rapid waypoint marking
- Site entrance coordinates
- Emergency position recording

**MapFormField Use Cases:**
- Excavation area boundaries
- Survey transect paths
- Building footprint tracing
- Vegetation patch mapping
- Site perimeter definition
- Linear feature documentation
- Viewshed area drawing

## Designer Component Mapping {essential}

| Designer Option | Component Config | Notes |
|-----------------|------------------|-------|
| Custom Field ‚Üí TakePoint | `"component-namespace": "faims-custom"` | GPS capture |
| Plugin Field ‚Üí MapFormField | `"component-namespace": "mapping-plugin"` | Map drawing |
| Label | `"label": "Field Label"` | Both fields |
| Helper Text | `"helperText": "Guidance"` | Both fields |
| Required | `"required": true` | TakePoint only |
| Zoom Level | `"zoom": 12` | MapFormField only |
| Feature Type | `"featureType": "Point"` | MapFormField only |

## Designer Capabilities vs JSON Enhancement {essential}

### Designer Configuration (Limited)
**TakePoint:**
- ‚úÖ Field label and name
- ‚úÖ Helper text
- ‚úÖ Required flag
- ‚ö†Ô∏è No GPS parameters

**MapFormField:**
- ‚úÖ Field label
- ‚úÖ Zoom level
- ‚úÖ Feature type (Point, LineString, Polygon)
- ‚ùå Center coordinates
- ‚ùå Validation (only 'required' available)

### JSON-Only Configuration

**TakePoint GPS parameters:**
```json
{
  "enableHighAccuracy": true,    // Request best GPS
  "timeout": 30000,              // 30 second timeout
  "maximumAge": 0                // Force fresh reading
}
```

**MapFormField map parameters:**
```json
{
  "center": [151.2093, -33.8688],  // Sydney coordinates
  "featureType": "Polygon",        // Point/LineString/Polygon
  "projection": "EPSG:4326"        // Limited options
}
```

## Component Namespace Errors {important}
See [Component Namespace Reference](../reference-docs/component-namespace-reference.md) for troubleshooting.

**Location-Specific Namespace Issues:**
- Using "faims-custom" for MapFormField - Field won't render
- Using "mapping-plugin" for TakePoint - Component not found
- Wrong capitalisation - Parse errors


## When to Use These Fields {essential}

### Field Selection Matrix

| Use Case | Recommended Field | Why |
|----------|------------------|-----|
| GPS points | TakePoint | Simple coordinate capture |
| Areas/Polygons | MapFormField | Draw on map |
| Routes/Lines | MapFormField | Draw polylines |
| Site locations | TakePoint | Quick GPS capture |

### Decision Criteria
- **Geometry type**: Point ‚Üí TakePoint, Polygon/Line ‚Üí MapFormField
- **User interaction**: GPS button ‚Üí TakePoint, Draw on map ‚Üí MapFormField
- **Accuracy needs**: High ‚Üí TakePoint with threshold, Visual ‚Üí MapFormField
- **Offline capability**: Full ‚Üí TakePoint, Limited ‚Üí MapFormField

## Common Characteristics {important}

### Security Considerations {important}
See [Security Considerations Reference](../reference-docs/security-considerations-reference.md) for comprehensive guidelines.

**Location-Specific Security Notes:**
- TakePoint exposes full GPS precision unnecessarily
- No coordinate obfuscation options
- MapFormField accepts self-intersecting polygons
- Both fields store exact coordinates without fuzzing
- CSV export maintains full precision

### Performance Boundaries {important}
See [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md#location-field-thresholds-estimates) for detailed metrics including GPS acquisition times, map performance by vertex count, and battery consumption.

**Location-Specific Performance:**
- **GPS acquisition timeout:** 10 seconds default (TakePoint)
- **Location update frequency:** Single capture only
- **Map tile cache:** 100MB typical limit
- **Offline map regions:** 2-14 zoom levels
- **Coordinate precision:** 14+ decimals displayed
- **TakePoint limit:** 1000-2000 points per notebook
- **MapFormField vertices:** 500 optimal, 2000 crash threshold
- **GPU acceleration:** Disabled for MapFormField

### Validation Patterns {important}
See [Validation System Documentation](../detail-crossfield-docs/validation.md) for comprehensive validation patterns and timing.

**Location Field-Specific Validation:**
- **Coordinate range**: NOT validated (accepts invalid lat/lon beyond ¬±90/¬±180)
- **GPS accuracy**: Cannot enforce minimum accuracy thresholds
- **Geofencing**: No boundary validation available
- **Required behavior**: Works for TakePoint, silently fails for MapFormField
- **Geometry**: No self-intersection or validity checks for polygons/lines

### Platform Behaviors {important}
See [Platform Behaviors Reference](../reference-docs/platform-behaviors-reference.md) for general platform characteristics.

**Location Field-Specific Behaviors:**
- **iOS**: Higher GPS accuracy; altitude available; "Allow Once" permission; rapid tap vertex bug in MapFormField
- **Android**: GPS needs "wake up" after airplane mode; speed/heading null unless moving
- **Web**: Limited GPS metadata (no altitude/speed); lower accuracy than mobile; mid-session permission revocation possible

### Meta Properties {important}
See [Meta Properties Reference](../reference-docs/meta-properties-reference.md) for configuration.

Both location fields support:
- **Annotation:** Document GPS quality, accuracy notes
- **Uncertainty:** Flag questionable readings

Critical for location fields due to accuracy variability.

### Export Behavior {important}
See [Data Export Reference](../reference-docs/data-export-reference.md) for universal patterns.

**Location-Specific Export:**

**TakePoint CSV columns:**
- `fieldname` - Full GeoJSON string
- `fieldname_latitude` - Decimal degrees
- `fieldname_longitude` - Decimal degrees
- `fieldname_accuracy` - Metres
- **LOST:** altitude, speed, heading, timestamp

**MapFormField CSV:**
- Point: Extracts lat/lon to separate columns
- LineString/Polygon: GeoJSON string only
- No coordinate extraction for complex geometries

**JSONL backup preserves all metadata**

## Individual Field Reference {essential}

### TakePoint {essential}

#### Purpose {essential}
Single-tap GPS coordinate capture through device geolocation services, returning GeoJSON Feature objects with accuracy metadata and optional positional attributes. Prioritises efficiency over precision refinement.

#### Quick Reference
| Property | Details |
|----------|---------|
| Component | `faims-custom::TakePoint` |
| Returns | `faims-pos::Location` |
| Designer | ‚ö†Ô∏è Basic support |
| JSON Required | GPS parameters |
| GPS Timeout | 10 seconds default |
| Accuracy Display | ‚úÖ Metres shown |
| Metadata | altitude, speed, heading (platform-dependent) |
| Battery Impact | Medium |
| Offline | ‚úÖ Full functionality |

#### Core Configuration
```json
{
  "component-namespace": "faims-custom",
  "component-name": "TakePoint",
  "type-returned": "faims-pos::Location",
  "component-parameters": {
    "label": "GPS Location",
    "name": "gps-point",
    "helperText": "Capture current GPS position",
    "required": false,
    "enableHighAccuracy": true,
    "timeout": 10000,
    "maximumAge": 0
  },
  "validationSchema": [
    ["yup.object"],
    ["yup.nullable"]
  ],
  "initialValue": null
}
```

#### Advanced Configuration
```json
{
  "control-point": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "component-parameters": {
      "label": "Control Point (High Accuracy)",
      "name": "control-point",
      "helperText": "Wait for accuracy < 10m before capturing",
      "timeout": 30000,
      "enableHighAccuracy": true,
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Control point required"]
    ],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Accuracy justification if >10m"
      },
      "uncertainty": {
        "include": true,
        "label": "GPS quality poor"
      }
    }
  }
}
```

#### Platform-Specific Behaviors
- **iOS:** Best accuracy, altitude common, "Allow Once" option
- **Android:** May need GPS "wake up", speed/heading sporadic
- **Web:** Minimal metadata, browser permission prompts

#### Common Issues & Solutions
| Issue | Cause | Solution |
|-------|-------|----------|
| "location unavailable" | Indoor/airplane mode | Move outside, check settings |
| Timeout errors | Poor GPS reception | Increase timeout to 30s |
| False precision | 14+ decimals shown | Ignore, check accuracy value |
| No altitude | Platform limitation | Common on web browsers |
| Stuck GPS | OS/Capacitor bug | Open Maps app to refresh |

### MapFormField {essential}

#### Purpose {essential}
Interactive geometry creation through web-based mapping, enabling spatial feature delineation by drawing on base map tiles. Uses OpenLayers for Point, LineString, and Polygon creation without GPS metadata.

#### Quick Reference
| Property | Details |
|----------|---------|
| Component | `mapping-plugin::MapFormField` |
| Returns | `faims-core::JSON` |
| Designer | ‚ö†Ô∏è Limited support |
| JSON Required | Center coordinates |
| Geometry Types | Point, LineString, Polygon |
| Vertex Limit | 500 optimal, 2000 crash |
| Offline Maps | ‚úÖ Tile caching |
| Validation Display | ‚ùå No error shown |
| GPU Acceleration | ‚ùå Disabled |

#### Core Configuration
```json
{
  "component-namespace": "mapping-plugin",
  "component-name": "MapFormField",
  "type-returned": "faims-core::JSON",
  "component-parameters": {
    "label": "Site Boundary",
    "name": "site-boundary",
    "featureType": "Polygon",
    "zoom": 18,
    "helperText": "Draw site perimeter on map",
    "fullWidth": true,
    "required": false
  },
  "validationSchema": [
    ["yup.object"],
    ["yup.nullable"]
  ],
  "initialValue": null
}
```

#### Advanced Configuration
```json
{
  "transect-path": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Survey Transect",
      "name": "transect-path",
      "featureType": "LineString",
      "zoom": 17,
      "center": [151.2093, -33.8688],
      "helperText": "Draw walked path. Limit to 1000 points",
      "fullWidth": true,
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Transect path required"]
    ],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Path deviation notes"
      }
    }
  }
}
```

#### Platform-Specific Behaviors
- **Desktop:** Drag-drop interface, scroll zoom
- **iOS:** Pinch zoom smooth, rapid tap vertex bug
- **Android:** Progressive slowdown after 300 vertices
- **All:** Single feature limit, no undo capability

#### Common Issues & Solutions
| Issue | Symptoms | Solution |
|-------|----------|----------|
| No validation feedback | Required field looks normal | Check form won't submit |
| Performance degradation | Sluggish drawing | Limit vertices <500 |
| iOS vertex disappear | Points vanish on rapid tap | Tap more slowly |
| Offline maps unavailable | Grey tiles | Pre-download regions |
| Geometry lost | Drawing clears | Remember single-feature limit |

## Troubleshooting Guide {important}

### GPS Issues (TakePoint)
**Before capture:**
- Enable Location Services in device settings
- Disable airplane mode
- Wait 30-60 seconds for GPS stabilisation
- Move to open sky view

**During issues:**
- Check displayed accuracy value
- Increase timeout to 20-30 seconds
- Open Maps app to "wake up" GPS
- Document concerns in annotation

### Map Issues (MapFormField)
**Tile loading:**
- Check internet connection
- Verify browser storage quota
- Use Offline Maps feature to pre-cache

**Performance:**
- Monitor vertex counter
- Keep polygons <500 vertices
- Test on target devices
- Avoid rapid tapping (iOS)

### Data Quality Checklist
- [ ] GPS accuracy acceptable for project?
- [ ] Environmental conditions documented?
- [ ] Platform limitations noted?
- [ ] Coordinate precision appropriate?
- [ ] Export format preserves needed data?

## JSON Examples {comprehensive}

### Example 1: Basic GPS Point Capture
```json
{
  "site-location": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "component-parameters": {
      "label": "Site Location",
      "name": "site-location",
      "helperText": "Capture GPS coordinates",
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Site location required"]
    ],
    "initialValue": null
  }
}
```

### Example 2: High-Accuracy GPS with Timeout
```json
{
  "precise-location": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "component-parameters": {
      "label": "Precise GPS Location",
      "name": "precise-location",
      "helperText": "Wait for accuracy <5m (45 second timeout)",
      "timeout": 45000,
      "enableHighAccuracy": true,
      "maximumAge": 0,
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Precise GPS required"]
    ],
    "meta": {
      "annotation": {
        "include": true,
        "label": "GPS conditions and satellite count"
      },
      "uncertainty": {
        "include": true,
        "label": "Accuracy concerns"
      }
    }
  }
}
```

### Example 3: Simple Polygon Drawing
```json
{
  "site-boundary": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Site Boundary",
      "name": "site-boundary",
      "featureType": "Polygon",
      "zoom": 18,
      "helperText": "Draw site perimeter on map"
    },
    "validationSchema": [["yup.object"]],
    "initialValue": null
  }
}
```

### Example 4: Complex Excavation Area with Center
```json
{
  "excavation-area": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Excavation Area",
      "name": "excavation-area",
      "featureType": "Polygon",
      "zoom": 19,
      "center": [151.2093, -33.8688],
      "helperText": "Draw excavation boundary (max 500 vertices)",
      "fullWidth": true,
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Excavation boundary required"]
    ]
  }
}
```

### Example 5: Survey Transect Line
```json
{
  "survey-transect": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Survey Transect",
      "name": "survey-transect",
      "featureType": "LineString",
      "zoom": 16,
      "helperText": "Draw survey walking route"
    },
    "validationSchema": [["yup.object"]],
    "initialValue": null
  }
}
```

### Example 6: Find Spot Location
```json
{
  "find-location": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Find Spot",
      "name": "find-location",
      "featureType": "Point",
      "zoom": 20,
      "helperText": "Click map to mark find location",
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Find location required"]
    ],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Location method and accuracy"
      }
    }
  }
}
```

### Example 7: Rapid Survey Waypoints
```json
{
  "waypoint": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "component-parameters": {
      "label": "Survey Waypoint",
      "name": "waypoint",
      "helperText": "Quick capture for traverse",
      "timeout": 5000,
      "maximumAge": 3000,
      "enableHighAccuracy": false
    },
    "validationSchema": [["yup.object"]],
    "initialValue": null
  }
}
```

### Example 8: Conditional Location Capture
```json
{
  "structure-location": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "component-parameters": {
      "label": "Structure GPS",
      "name": "structure-location",
      "helperText": "Capture center point of structure",
      "enableHighAccuracy": true,
      "timeout": 30000
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Structure location required"]
    ],
    "condition": {
      "operator": "equal",
      "field": "feature-type",
      "value": "structure"
    }
  }
}
```

### Example 9: MultiPolygon for Complex Sites
```json
{
  "site-areas": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Site Areas",
      "name": "site-areas",
      "featureType": "MultiPolygon",
      "zoom": 17,
      "helperText": "Draw multiple disconnected areas",
      "advancedHelperText": "## Drawing Tips\n\n- Complete first polygon\n- Click draw tool again for next\n- Each polygon separate feature"
    },
    "validationSchema": [["yup.object"]],
    "initialValue": null
  }
}
```

### Example 10: Battery-Optimized GPS
```json
{
  "check-in-location": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "component-parameters": {
      "label": "Daily Check-in",
      "name": "check-in-location",
      "helperText": "Morning location verification",
      "timeout": 10000,
      "enableHighAccuracy": false,
      "maximumAge": 60000
    },
    "validationSchema": [["yup.object"]],
    "initialValue": null
  }
}
```

### Example 11: Geofence Area Definition
```json
{
  "restricted-zone": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Restricted Area",
      "name": "restricted-zone",
      "featureType": "Polygon",
      "zoom": 18,
      "center": [144.9631, -37.8136],
      "helperText": "Define no-entry zone",
      "fullWidth": true
    },
    "validationSchema": [["yup.object"]],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Restriction reason and authority"
      }
    }
  }
}
```

### Example 12: Survey Grid Square
```json
{
  "grid-square": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Survey Grid Square",
      "name": "grid-square",
      "featureType": "Polygon",
      "zoom": 20,
      "helperText": "Draw 10m x 10m survey square",
      "advancedHelperText": "Try to maintain square shape.\nUse satellite view for alignment."
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Grid square required"]
    ]
  }
}
```

### Example 13: Emergency Location Fallback
```json
{
  "emergency-location": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "component-parameters": {
      "label": "Emergency Position",
      "name": "emergency-location",
      "helperText": "Any accuracy accepted - for safety",
      "timeout": 3000,
      "enableHighAccuracy": false,
      "maximumAge": 300000
    },
    "validationSchema": [["yup.object"]],
    "initialValue": null
  }
}
```

### Example 14: Feature Centroid Marking
```json
{
  "feature-center": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Feature Center Point",
      "name": "feature-center",
      "featureType": "Point",
      "zoom": 21,
      "helperText": "Mark exact center of feature",
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Center point required"]
    ],
    "condition": {
      "operator": "is-truthy",
      "field": "feature-boundary"
    }
  }
}
```

### Example 15: Performance-Optimized Polygon
```json
{
  "simplified-boundary": {
    "component-namespace": "mapping-plugin",
    "component-name": "MapFormField",
    "type-returned": "faims-core::JSON",
    "component-parameters": {
      "label": "Simplified Boundary",
      "name": "simplified-boundary",
      "featureType": "Polygon",
      "zoom": 17,
      "helperText": "‚ö†Ô∏è LIMIT 100 VERTICES - Generalize complex shapes",
      "advancedHelperText": "## Performance Warning\n\nUse fewer points for better performance.\nDetailed shapes can crash mobile devices."
    },
    "validationSchema": [["yup.object"]],
    "initialValue": null
  }
}
```

### Example 16: Sampling Location with Metadata
```json
{
  "sample-location": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "component-parameters": {
      "label": "Sample Collection Point",
      "name": "sample-location",
      "helperText": "GPS where sample collected",
      "enableHighAccuracy": true,
      "timeout": 20000,
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "Sample location required"]
    ],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Collection method and depth"
      },
      "uncertainty": {
        "include": true,
        "label": "Location precision notes"
      }
    }
  }
}
```

## Migration Scenarios {comprehensive}

### Scenario 1: Converting TakePoint to MapFormField
**Context**: Project moves from simple GPS points to visual boundary mapping

**Challenge**: Data formats completely incompatible
- TakePoint returns `faims-pos::Location` (GeoJSON Feature)
- MapFormField returns `faims-core::JSON` (GeoJSON FeatureCollection)
- No automatic conversion available

**Migration Steps**:
1. Export existing data as JSONL
2. Extract coordinates from TakePoint records
3. Manually create MapFormField GeoJSON structure
4. Import converted data or re-collect

### Scenario 2: Legacy Coordinate Format Handling
**Context**: Migrating from decimal degrees minutes (DDM) to decimal degrees (DD)

**Challenge**: Historical data in various formats
- Degrees Minutes Seconds: 33¬∞ 52' 7.68" S
- Decimal Degrees Minutes: 33¬∞ 52.128' S
- Decimal Degrees: -33.8688

**Solution**: Pre-process before import
- Use external conversion tools
- Create TextField for manual entry as fallback
- Document original format in annotations

### Scenario 3: Offline Map Deployment
**Context**: Moving to offline-capable deployment

**Current Status**: Experimental feature (mostly working)
- Offline maps generally "just work" after download
- Intermittent rendering error being addressed by tech lead
- Feature marked experimental until rendering fix complete

**Simple Setup**:
1. Download region while online
2. Maps cache automatically
3. Works offline with cached tiles

**Known Issue**: Occasional tile rendering glitch (under investigation)

### Scenario 4: GPS Accuracy Requirements Change
**Context**: Moving from consumer to survey-grade requirements

**Challenge**: TakePoint cannot enforce accuracy thresholds
- Shows 14+ decimal places regardless of true accuracy
- No rejection of poor readings
- No averaging or RTK support

**Workarounds**:
1. Add manual accuracy field for verification
2. Use annotation to document GPS conditions
3. Consider external GPS with FileUploader
4. Train users on accuracy interpretation

### Scenario 5: Performance-Critical Scaling
**Context**: Project scaling beyond performance limits

**Current Limits**:
- TakePoint: 1000-2000 points before degradation
- MapFormField: 500 vertices optimal, 2000 crash threshold

**Migration Strategies**:
1. Split data collection across multiple notebooks
2. Simplify geometries before capture
3. Use point clusters instead of detailed polygons
4. Archive completed data regularly

### General Migration Considerations
- **Data format incompatibility** between TakePoint and MapFormField
- **No conversion utilities** - manual reconstruction required
- **CSV export loses metadata** - use JSONL for full preservation
- **Namespace differences** require JSON updates

## Best Practices {comprehensive}

### GPS Best Practices (TakePoint)
1. **Allow stabilisation** - Wait 30-60s on site
2. **Check accuracy** - Manually verify before accepting
3. **Document decisions** - Use annotations for justification
4. **Multiple attempts** - Keep best accuracy reading
5. **Battery awareness** - Space captures temporally

### Map Best Practices (MapFormField)
1. **Pre-download tiles** - Use Offline Maps feature
2. **Limit vertices** - Stay under 500 for mobile
3. **Save frequently** - No auto-save available
4. **Train users** - Explain single-feature limit
5. **Plan post-processing** - GeoJSON extraction needed

### Data Quality Strategies
- Establish project accuracy standards
- Document minimum acceptable GPS accuracy
- Plan for missing altitude/speed data
- Consider external GPS for survey-grade needs
- Use JSONL backup for complete metadata

## Field Quirks Index (2025-01-03) {comprehensive}

### TakePoint Quirks
- Shows 14+ decimal places regardless of accuracy
- Cannot enforce accuracy thresholds
- No user feedback during 10-second acquisition
- CSV export loses most metadata
- Permission alert shows for all errors
- GPS may stick after airplane mode

### MapFormField Quirks
- Validation errors never display
- Single feature limit (new replaces old)
- No vertex deletion capability
- No undo function
- GPU acceleration disabled
- iOS rapid tap causes vertex loss

### Shared Quirks
- No data format compatibility
- Cannot import external files (GPX/KML)
- No continuous tracking capability
- Independent GPS state (no sharing)
- No coordinate bounds validation

## Performance Thresholds Summary {essential}
See [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md) for detailed metrics.

**Location-Specific Thresholds:**
| Metric | TakePoint | MapFormField | Impact |
|--------|-----------|--------------|---------|
| Timeout | 10s default / 30s max | N/A | GPS acquisition |
| Points per notebook | 1000-2000 | N/A | Performance degrades |
| Vertices per feature | N/A | 500 optimal / 2000 crash | Drawing response |
| Tile cache | N/A | 100MB typical | Offline capability |
| GPS warm-up | 30-60 seconds | N/A | Accuracy improvement |
| Battery drain | Medium | Low | Per capture |

## JSON Patterns Cookbook (2025-01-03) {comprehensive}

### Pattern: Conditional Location Capture
```json
{
  "feature-location": {
    "component-namespace": "faims-custom",
    "component-name": "TakePoint",
    "type-returned": "faims-pos::Location",
    "condition": {
      "operator": "equal",
      "field": "location-needed",
      "value": "yes"
    }
  }
}
```

### Pattern: Accuracy-Focused Configuration
```json
{
  "component-parameters": {
    "timeout": 30000,
    "enableHighAccuracy": true,
    "maximumAge": 0
  },
  "meta": {
    "annotation": {"include": true, "label": "GPS quality notes"},
    "uncertainty": {"include": true, "label": "Poor accuracy"}
  }
}
```

### Pattern: Performance-Optimised Map
```json
{
  "component-parameters": {
    "featureType": "Polygon",
    "helperText": "Maximum 500 vertices for mobile devices"
  }
}
```

## JSON Anti-patterns Quick Index {comprehensive}

### ‚ùå Don't: Wrong Namespace
```json
// WRONG - TakePoint doesn't use mapping-plugin
{
  "component-namespace": "mapping-plugin",
  "component-name": "TakePoint"
}
```

### ‚ùå Don't: Mix Return Types
```json
// WRONG - Can't transfer between fields
{
  "takepoint-data": "faims-pos::Location",
  "mapform-data": "faims-core::JSON"
  // These are incompatible!
}
```

### ‚ùå Don't: Expect Accuracy Validation
```json
// WRONG - No accuracy threshold enforcement
{
  "minimum_accuracy": 10  // This parameter doesn't exist
}
```

## Quick Diagnosis Tables (2025-01-03) {important}

### Location Field Issues Diagnosis
| Symptom | Field | Likely Cause | Quick Fix | Platform | Prevention |
|---------|-------|--------------|-----------|----------|------------|
| No GPS signal | TakePoint | Indoor/airplane | Go outside | All | Pre-warm GPS |
| 14+ decimals | TakePoint | False precision | Check accuracy value | All | User training |
| Validation silent | MapFormField | No error display | Check form submission | All | Helper text |
| Vertices vanish | MapFormField | iOS rapid tap | Tap slowly | iOS | Tap training |
| Poor accuracy | TakePoint | GPS not ready | Wait 30-60s | All | Patience protocol |
| Tiles missing | MapFormField | No cache | Download offline maps | All | Pre-download |
| No metadata | TakePoint | Web platform | Use mobile app | Web | Platform choice |
| Timeout errors | TakePoint | Weak signal | Increase timeout | All | JSON config |
| "Location unavailable" | TakePoint | Permission denied | Check settings | All | Setup checklist |
| Frozen drawing | MapFormField | Too many vertices | Simplify shape | Mobile | Vertex limits |
| GPS stuck | TakePoint | OS cache | Open Maps app | Mobile | GPS refresh |
| No altitude | TakePoint | Platform limit | Document as N/A | Web | Expectation setting |
| Self-intersecting | MapFormField | No validation | Manual check | All | Training |
| Battery drain | Both | Continuous GPS | Space captures | Mobile | Usage pattern |
| Accuracy drift | TakePoint | Multipath/weather | Multiple attempts | All | Best-of-3 protocol |

## Field Interaction Matrix (2025-01-03) {important}

### Location Fields with Other Field Types
| Field Combination | Interaction | Common Pattern |
|------------------|-------------|----------------|
| TakePoint + TakePhoto | Complementary | GPS + geotagged photos |
| MapFormField + TakePoint | Incompatible formats | Choose one method |
| TakePoint + TemplatedString | Coordinate reference | Location-based IDs |
| MapFormField + Annotation | Quality documentation | Accuracy notes |
| TakePoint + Conditions | Null checking only | Cannot check accuracy |

## Migration Warnings Index (2025-01-03) {comprehensive}

### Critical Migration Issues
1. **Format incompatibility** - Cannot convert between TakePoint/MapFormField
2. **No accuracy enforcement** - Manual checking required
3. **CSV metadata loss** - Use JSONL for preservation
4. **False precision display** - Training needed on accuracy
5. **No GPS track capability** - External apps required
6. **Validation display broken** - MapFormField errors hidden
7. **Performance limits lower** - Vertex counts critical

## See Also {comprehensive}

### Other Field Categories
- **[Text Fields](./text-fields-v05.md)**: Manual coordinate entry fallback
- **[Number Fields](./number-fields-v05.md)**: Separate lat/lon fields alternative
- **[DateTime Fields](./datetime-fields-v05.md)**: Timestamps for location capture
- **[Select/Choice Fields](./select-choice-fields-v05.md)**: Location type classification
- **[Media Fields](./media-fields-v05.md)**: TakePhoto for geotagged images
- **[Relationship Field](./relationship-field-v05.md)**: Linking locations to records
- **[Display Field](./display-field-v05.md)**: GPS capture instructions

### Reference Documents
  - [Validation Timing Reference](../reference-docs/validation-timing-reference.md)
  - [Data Export Reference](../reference-docs/data-export-reference.md) - Coordinate format handling
  - [Security Considerations](../reference-docs/security-considerations-reference.md) - Location privacy
  - [Performance Thresholds](../reference-docs/performance-thresholds-reference.md) - GPS timeouts, vertex limits
  - [Accessibility Reference](../reference-docs/accessibility-reference.md) - Map interface accessibility
  - [Component Namespace Reference](../reference-docs/component-namespace-reference.md) - Namespace troubleshooting
  - [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md) - JSON requirements
  - [Meta Properties Reference](../reference-docs/meta-properties-reference.md) - Annotation importance
  - [Formik Integration Reference](../reference-docs/formik-integration-reference.md) - State management

## Error Message Quick Reference {important}

### Location-Specific Errors
| Error | Field | Cause | Solution |
|-------|-------|-------|----------|
| "location unavailable" | TakePoint | Generic GPS failure | Check settings, go outside |
| "kCLErrorDomain error 1" | TakePoint | iOS permission denied | Settings > Privacy > Location |
| "Timeout expired" | TakePoint | GPS timeout reached | Increase timeout parameter |
| Silent validation failure | MapFormField | No error display | Check form won't submit |
| "Permission denied" | Both | Location access denied | Grant permission in settings |
| Grey map tiles | MapFormField | No tile cache | Download offline maps |
| "maximumAge is not valid" | TakePoint | JSON syntax error | Check parameter spelling |

## Metadata {comprehensive}
- **Document Version**: v05 (consolidated)
- **Source Documents**: TakePoint.md, MapFormField.md (Third Draft)
- **Platform Version**: Fieldmark v3 (January 2025)
- **Total Fields**: 2 (TakePoint, MapFormField)
- **Key Limitations**: No accuracy enforcement, false precision, incompatible formats
- **Security Level**: Location privacy concerns
- **Performance Limits**: 1000 points (TakePoint), 500 vertices (MapFormField)
- **Reference Docs**: 9 linked documents
---

## Related Documentation
<!-- concat:references -->

### Within Field Categories
- **Previous**: [Display Fields](./display-field-v05.md) | [#display-fields](#display-fields)
- **Next**: [Media Fields](./media-fields-v05.md) | [#media-fields](#media-fields)

### Cross-Field Patterns
- **Validation**: [Location Accuracy](../detail-crossfield-docs/validation.md#location-fields) | [#validation-patterns](#validation-patterns)
- **Field Dependencies**: [GPS Requirements](../detail-crossfield-docs/conditional-logic.md#location-fields) | [#conditional-logic](#conditional-logic)

### Technical References
- **Platform Behaviors**: [GPS Handling](../reference-docs/platform-behaviors-reference.md#location-fields) | [#platform-behaviors](#platform-behaviors)
- **Performance**: [Map Rendering](../reference-docs/performance-thresholds-reference.md#location-fields) | [#performance-thresholds](#performance-thresholds)

<!-- /concat:references -->
<!-- concat:boundary:end section="location-fields" -->


<!-- concat:document:media-fields-v05 -->
<!-- concat:boundary:start section="media-fields" -->
<!-- concat:metadata
document_id: media-fields-v05
category: media
field_count: 2
designer_capable: ["TakePhoto", "FileUploader"]
json_only: ["custom_upload_handlers", "file_type_restrictions"]
last_updated: 2025-01-05
-->

# Media Fields - Fieldmark v3 Documentation

## Document Navigation
<!-- concat:nav-mode:individual -->
[‚Üê Location Fields](./location-fields-v05.md) | **Media Fields** | [Relationship Fields ‚Üí](./relationship-field-v05.md)
<!-- concat:nav-mode:concatenated -->
<!-- When viewing in reference.md: [‚Üë Top](#fieldmark-v3-field-type-documentation-index) | [Relationship Fields ‚Üì](#relationship-fields) -->


## Overview {essential}

### DESIGNER QUICK GUIDE
**Media Capture Fields Available:**
- **FileUploader** ‚Üí Upload any existing files from device
## Component Name Mapping {essential}

| Designer UI Label | JSON component-name | Namespace | Code File | Description |
|------------------|-------------------|-----------|-----------|-------------|
| Take Photo | TakePhoto | faims-custom | TakePhoto.tsx | Camera capture & gallery |
| File Uploader | FileUploader | faims-custom | FileUploader.tsx | General file attachment |

### Critical Naming Issues {important}
- **TakePhoto misnomer**: Also handles gallery selection, not just camera
- **Required validation broken**: Known issue with required field validation
- **File type restrictions**: Cannot actually restrict file types despite settings
- **Silent failures**: Upload errors often fail silently

- **FileUploader** (capital F, capital U) - NOT "fileuploader" or "File Uploader"
- **TakePhoto** (capital T, capital P) - NOT "takephoto" or "Take Photo"
- Both components use namespace `"faims-custom"` - never "core" or "basic"
- Return type is `faims-attachment::Files` for both - maintains compatibility

### Media Capture Fields (2 total)
1. **FileUploader** - Upload existing files of any type from device storage
2. **TakePhoto** - Capture new photos using device camera with gallery fallback

### Component Status Summary
| Field | Designer | JSON Enhancement | Validation | Platform Support |
|-------|----------|------------------|------------|------------------|
| FileUploader | ‚úÖ Basic | Required for constraints | ‚ö†Ô∏è Broken required | All platforms |
| TakePhoto | ‚úÖ Full | Optional for validation | ‚ö†Ô∏è Manual required | All platforms |

## Designer Usage Guide {essential}

### What to Select in Designer
1. Navigate to Field Type selection
2. Choose "Custom Field" category
3. Select either:
   - **FileUploader** for document/file uploads
   - **TakePhoto** for camera capture
4. Configure standard properties (label, helper text, annotations)

### When JSON Enhancement is Required
**FileUploader JSON-only parameters:**
- `multiple` - Allow multiple file selection
- `maximum_file_size` - Size limit in bytes
- `minimum_file_size` - Minimum size in bytes  
- `maximum_number_of_files` - File count limit

**TakePhoto JSON-only validation:**
- Required validation via `yup.required`
- Min/max photo counts via `yup.min`/`yup.max`

### Designer Limitations {important}
See [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md) for universal constraints.

**Media-Specific Designer Limitations:**
- Cannot configure file size limits through Designer
- Cannot set multiple file selection toggle
- Cannot enforce photo count limits
- Required validation not enforced (TakePhoto shows asterisk, FileUploader doesn't, neither enforces)
- No file type restrictions available in Designer

## Field Selection Guide {essential}

### Decision Tree
```
Need to capture media?
‚îú‚îÄ Static files from device?
‚îÇ  ‚îî‚îÄ YES ‚Üí FileUploader
‚îÇ     ‚îú‚îÄ Returns: faims-attachment::Files (array)
‚îÇ     ‚îú‚îÄ Accepts: Any file type without restriction
‚îÇ     ‚îî‚îÄ Best for: Documents, maps, professional photos, mixed media
‚îÇ
‚îî‚îÄ Take new photo with camera?
   ‚îî‚îÄ YES ‚Üí TakePhoto
      ‚îú‚îÄ Returns: faims-attachment::Files (array)
      ‚îú‚îÄ Output: JPEG at 90% quality
      ‚îî‚îÄ Best for: Field documentation, quick reference photos
```

### Decision Matrix
| Requirement | FileUploader | TakePhoto |
|------------|--------------|-----------|
| Camera access | ‚ùå | ‚úÖ |
| Gallery selection | ‚úÖ | ‚úÖ |
| Multiple files | ‚úÖ Configurable | ‚úÖ Always |
| File type restriction | ‚ùå | ‚úÖ Images only |
| Size limits | ‚úÖ JSON config | ‚ùå |
| GPS injection | ‚ùå | ‚úÖ Native only |
| EXIF preservation | ‚ùå Stripped | ‚ùå Stripped |
| Offline capture | ‚úÖ | ‚úÖ |
| Progress indicators | ‚ùå | ‚ùå |

### Selection Strategy
- **FileUploader when:**
  - Uploading pre-existing files
  - Need mixed media types
  - Professional camera images required
  - Document management workflows
  
- **TakePhoto when:**
  - Immediate photo capture needed
  - GPS coordinates valuable
  - Camera workflow integration required
  - Quick reference documentation

## ‚ö†Ô∏è Critical Media Security Risks {essential}
See [Security Considerations Reference](../reference-docs/security-considerations-reference.md) for general security patterns.

**Media-Specific Security Concerns:**
- **FileUploader accepts ANY file type** including executables, scripts, malware
- **No virus scanning** on uploaded files
- **Path traversal risks** via malicious filenames
- **JavaScript execution** possible in SVG uploads
- **EXIF privacy leaks** - Location data in uploaded photos
- **Memory exhaustion** - No client-side size validation
- **Storage attacks** - Unlimited uploads can fill device/server
- **No content validation** - Corrupt or malicious files accepted

**Mitigation Requirements:**
- Deploy only in trusted research environments
- Implement server-side validation if public-facing
- Document acceptable file types in helper text
- Monitor unusual upload patterns
- Set explicit size/count limits via JSON

## What These Fields Cannot Do {important}

**Both Fields Cannot:**
- Preserve EXIF metadata (stripped on upload)
- Show upload/processing progress
- Validate file content integrity
- Scan for viruses or malware
- Enforce required validation reliably
- Reorder captured/uploaded files
- Edit images after capture
- Generate consistent thumbnails

**FileUploader Specific:**
- Cannot restrict file types
- Cannot access device camera
- Cannot inject GPS coordinates
- Cannot provide user feedback on constraint violations

**TakePhoto Specific:**
- Cannot capture RAW images
- Cannot preserve camera settings
- Cannot upload existing files directly
- Cannot configure image quality/compression

## Common Use Cases {important}

**FileUploader Use Cases:**
- Heritage permit documentation (PDFs)
- Drone footage and aerial photography
- Laboratory analysis reports
- Historical maps and plans
- Audio recordings and interviews
- DSLR professional photography
- Mixed media archaeological records

**TakePhoto Use Cases:**
- Excavation progress documentation
- Artefact field photography
- Site condition monitoring
- Stratigraphic profile capture
- Feature documentation
- Environmental context photos
- Quick reference imagery

## Designer Component Mapping {essential}

| Designer Option | Component Config | Notes |
|-----------------|------------------|-------|
| Custom Field ‚Üí FileUploader | `"component-namespace": "faims-custom"` | Upload files |
| Custom Field ‚Üí TakePhoto | `"component-namespace": "faims-custom"` | Camera capture |
| Label | `"label": "Field Label"` | Both fields |
| Helper Text | `"helperText": "Guidance"` | Both fields |
| Required | `"required": true` | Visual only |
| Advanced Helper | `"advancedHelperText": "## Markdown"` | Both fields |

## Designer Capabilities vs JSON Enhancement {essential}

### Designer Configuration (Both Fields)
- ‚úÖ Field labels and naming
- ‚úÖ Helper text (basic and advanced)
- ‚úÖ Conditional visibility
- ‚úÖ Annotation fields
- ‚úÖ Uncertainty fields
- ‚ö†Ô∏è Required indicator (visual only)

### JSON-Only Configuration

**FileUploader:**
```json
{
  "multiple": true,                    // Allow multiple files
  "maximum_file_size": 10485760,       // 10MB limit
  "minimum_file_size": 1024,           // 1KB minimum
  "maximum_number_of_files": 5         // Max 5 files
}
```

**TakePhoto:**
```json
{
  "validationSchema": [
    ["yup.array"],
    ["yup.required", "Photos required"],
    ["yup.min", 1, "Minimum 1 photo"],
    ["yup.max", 10, "Maximum 10 photos"]
  ]
}
```

## Component Namespace Errors {important}
See [Component Namespace Reference](../reference-docs/component-namespace-reference.md) for troubleshooting.

**Media-Specific Namespace Issues:**
- Using "core" instead of "faims-custom" - Fields won't render
- Lowercase component names - Component not found errors
- Space in component name - Parse errors


## When to Use These Fields {essential}

### Field Selection Matrix

| Use Case | Recommended Field | Why |
|----------|------------------|-----|
| Photo documentation | TakePhoto | Camera optimized |
| Document uploads | FileUploader | Any file type |
| Mixed media | FileUploader | More flexible |
| Evidence photos | TakePhoto | Direct camera access |

### Decision Criteria
- **File type**: Photos only ‚Üí TakePhoto, Any type ‚Üí FileUploader
- **Camera access**: Required ‚Üí TakePhoto, Optional ‚Üí FileUploader
- **File source**: Camera ‚Üí TakePhoto, Existing files ‚Üí FileUploader
- **Validation**: Neither properly validates required fields (known issue)

## Common Characteristics {important}

### Security Considerations {important}
See [Security Considerations Reference](../reference-docs/security-considerations-reference.md) for comprehensive guidelines.

**Media-Specific Security Notes:**
- FileUploader accepts executables without validation
- No client-side content scanning
- Base64 encoding increases memory usage 33%
- Orphaned attachments accumulate without cleanup
- EXIF location data exposed in original files

### Performance Boundaries {important}
See [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md) for general limits.

**Media-Specific Performance:**
- **File upload timeout:** 120 seconds default
- **Max individual file:** 50MB recommended, 100MB absolute
- **Image processing limit:** 4096√ó4096 pixels
- **Concurrent uploads:** 3 maximum
- **TakePhoto images:** 20 maximum before degradation
- **Memory overhead:** ~33% for base64 encoding
- **Browser storage:** 1GB Safari, 6GB Chrome
- **Sync bandwidth:** Consider with "Get attachments" enabled

### Validation Patterns {important}
See [Validation System Documentation](../detail-crossfield-docs/validation.md) for comprehensive validation patterns and timing.

**Media Field-Specific Validation:**
- **File type**: Validated at selection (TakePhoto only)
- **File size**: Silent rejection without error message (FileUploader)
- **Required files**: Broken in Designer, needs JSON validation schema
- **File count**: Via `yup.array.min/max` only
- **Content scanning**: Not performed (no virus/malware checks)
- **Async validation**: Not supported during upload process

### Platform Behaviors {important}
See [Platform Behaviors Reference](../reference-docs/platform-behaviors-reference.md) for general platform characteristics.

**Media Field-Specific Behaviors:**
- **iOS**: HEIC‚ÜíJPEG auto-conversion; combined camera/photo permissions; ProRAW/Live Photos metadata lost
- **Android**: Storage Access Framework (no permissions); manufacturer camera variations; direct JPEG capture
- **Web**: MediaDevices API or file input; no GPS in EXIF; IndexedDB storage limits

### Meta Properties {important}
See [Meta Properties Reference](../reference-docs/meta-properties-reference.md) for configuration.

Both media fields support:
- **Annotation:** Field-level notes (not per-file)
- **Uncertainty:** Quality/confidence indicators

Note: Annotations apply to entire field, not individual files.

### Export Behavior {important}
See [Data Export Reference](../reference-docs/data-export-reference.md) for universal patterns.

**Media-Specific Export:**
- **Binary files:** Separate files in export package
- **CSV reference:** Semicolon-separated filenames
- **JSON format:** Full attachment metadata
- **Filename pattern:** `{recordID}_{fieldname}_{index}.ext`
- **Duplicate handling:** Append `*1`, `*2` suffixes
- **Missing files:** Silently skipped
- **Original names:** Lost during export
- **Storage IDs:** `att-{uuid}` format

## Individual Field Reference {essential}

### FileUploader {essential}

#### Purpose {essential}
Provides comprehensive file attachment capabilities accepting any file type without restriction. Implements web-standard approach through React Dropzone, operating as temporary file accumulator until form submission triggers PouchDB synchronisation.

#### Quick Reference
| Property | Details |
|----------|---------|
| Component | `faims-custom::FileUploader` |
| Returns | `faims-attachment::Files` |
| Designer | ‚úÖ Basic support |
| JSON Required | File constraints |
| Touch Target | Upload button 44√ó44px minimum |
| Max File Size | 50MB recommended (JSON config) |
| Concurrent | 3 uploads maximum |
| Offline | ‚úÖ Queued for sync |
| Security | ‚ö†Ô∏è No validation |

#### Core Configuration
```json
{
  "component-namespace": "faims-custom",
  "component-name": "FileUploader",
  "type-returned": "faims-attachment::Files",
  "component-parameters": {
    "label": "Upload Documents",
    "name": "documents",
    "helperText": "Upload permits, maps, reports (max 10MB each)",
    "required": false,
    "multiple": true,
    "maximum_file_size": 10485760,
    "maximum_number_of_files": 5
  },
  "validationSchema": [["yup.mixed"]],
  "initialValue": null
}
```

#### Advanced Configuration
```json
{
  "survey-media": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Survey Documentation",
      "name": "survey-media",
      "helperText": "DSLR photos, drone footage, GIS exports",
      "advancedHelperText": "## Accepted Formats\n- Images: JPG, PNG, TIFF, RAW\n- Documents: PDF, DOCX\n- Data: CSV, SHP, KML\n- Video: MP4, MOV (max 50MB)",
      "multiple": true,
      "maximum_file_size": 52428800,
      "minimum_file_size": 1024
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null,
    "meta": {
      "annotation": {
        "include": true,
        "label": "File descriptions"
      }
    }
  }
}
```

#### Platform-Specific Behaviors
- **Desktop:** Drag-and-drop with hover states, click-to-select
- **iOS:** Document picker accessing iCloud Drive, local storage
- **Android:** Storage Access Framework, no permissions required
- **Web:** Standard HTML file input element

#### Common Issues & Solutions
| Issue | Cause | Solution |
|-------|-------|----------|
| Files disappear | Silent size/count violation | Document limits in helper text |
| Required not working | yup.mixed() can't validate arrays | Use helper text to indicate |
| Browser crash | Memory exhaustion >50MB files | Limit file sizes via JSON |
| Files lost on refresh | No persistence before submission | Save form frequently |
| No upload progress | Missing indicators | Inform users about submission timing |

### TakePhoto {essential}

#### Purpose {essential}
Integrates platform-native camera functionality with gallery selection through unified interface. Leverages Capacitor's camera plugin for cross-platform image capture with GPS injection on native platforms.

#### Quick Reference
| Property | Details |
|----------|---------|
| Component | `faims-custom::TakePhoto` |
| Returns | `faims-attachment::Files` |
| Designer | ‚úÖ Full support |
| JSON Required | Validation only |
| Touch Target | Camera button 44√ó44px minimum |
| Image Quality | JPEG 90% |
| GPS Support | ‚úÖ Native platforms only |
| Max Photos | 20 before performance impact |
| Offline | ‚úÖ Full functionality |

#### Core Configuration
```json
{
  "component-namespace": "faims-custom",
  "component-name": "TakePhoto",
  "type-returned": "faims-attachment::Files",
  "component-parameters": {
    "label": "Site Photos",
    "name": "site-photos",
    "helperText": "Capture site overview and details",
    "required": false
  },
  "validationSchema": [
    ["yup.array"],
    ["yup.of", [["yup.object"], ["yup.nullable"]]],
    ["yup.nullable"]
  ],
  "initialValue": null
}
```

#### Advanced Configuration
```json
{
  "artefact-photos": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Artefact Documentation",
      "name": "artefact-photos",
      "helperText": "Capture 2-10 photos from multiple angles",
      "required": true
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.of", [["yup.object"], ["yup.nullable"]]],
      ["yup.required", "Artefact photos required"],
      ["yup.min", 2, "Minimum 2 angles required"],
      ["yup.max", 10, "Maximum 10 photos"]
    ],
    "initialValue": null,
    "meta": {
      "annotation": {
        "include": true,
        "label": "Angle and lighting notes"
      },
      "uncertainty": {
        "include": true,
        "label": "Image quality"
      }
    }
  }
}
```

#### Platform-Specific Behaviors
- **iOS:** "Take Photo or Choose from Library" prompt, HEIC‚ÜíJPEG conversion
- **Android:** Standard camera/gallery selector, direct JPEG capture
- **Web:** MediaDevices API with file input fallback, no GPS
- **All:** Automatic orientation correction applied

#### Common Issues & Solutions
| Issue | Symptoms | Solution |
|-------|----------|----------|
| Permission denied | Error about permissions | Settings > Apps > Permissions |
| Required not working | Empty submission allowed | Add yup.required to schema |
| Performance slow | Many photos lag form | Limit to 20 photos maximum |
| No GPS coordinates | Web platform limitation | Use native apps for GPS |
| EXIF data missing | Expected - always stripped | Use FileUploader for EXIF |
| Images not syncing | Local only visibility | Enable "Get attachments" |

## Troubleshooting Guide {important}

### Issue 1: Silent File Rejection (FileUploader)
**Symptoms**: Files appear to upload but disappear without error message

**Diagnosis Steps**:
1. Check browser console for size limit messages
2. Count existing files in field
3. Verify file size in bytes
4. Test with smaller file

**Common Causes & Solutions**:
- **File too large**: `maximum_file_size` exceeded silently
  - Solution: Add explicit size limits to helper text
  - Example: "Maximum 10MB per file" 
- **Too many files**: `maximum_number_of_files` reached
  - Solution: Document limit clearly, consider increasing
- **File too small**: `minimum_file_size` not met (rare)
  - Solution: Check for 0-byte files

**Prevention**: Always specify limits in helper text since validation doesn't show errors

### Issue 2: Required Validation Not Working (Both Fields)
**Symptoms**: Form submits with empty required media fields

**Root Cause**: 
- FileUploader uses `yup.mixed()` which cannot validate arrays
- TakePhoto requires manual `yup.required` addition

**Solutions**:

For FileUploader (use helper text workaround):
```json
{
  "validationSchema": [["yup.mixed"]],
  "helperText": "‚ö†Ô∏è REQUIRED: Upload at least one document"
}
```

For TakePhoto (manual validation configuration):
```json
{
  "validationSchema": [
    ["yup.array"],
    ["yup.required", "Photos required"],
    ["yup.min", 1, "At least one photo required"]
  ]
}
```

### Issue 3: Browser Memory Exhaustion
**Symptoms**: Browser tab crashes or becomes unresponsive during upload

**Diagnosis**:
1. Open browser DevTools ‚Üí Performance Monitor
2. Watch memory usage during file selection
3. Check if files exceed 50MB each
4. Count total size of all uploads

**Solutions by File Size**:
- **<10MB**: Should work on all devices
- **10-50MB**: May struggle on older mobile devices
- **50-100MB**: High crash risk, desktop only
- **>100MB**: Not recommended, will likely fail

**Mitigation Strategies**:
1. Compress images before upload
2. Split large PDFs into sections
3. Use external links for very large files
4. Process files in smaller batches

### Issue 4: Camera Permission Denied (TakePhoto)
**Symptoms**: Camera button disabled or "Permission denied" error

**Platform-Specific Recovery**:

**iOS**:
1. Settings ‚Üí Privacy & Security ‚Üí Camera
2. Find app in list and toggle ON
3. May need to fully quit and restart app
4. "Allow Once" requires re-permission each session

**Android**:
1. Settings ‚Üí Apps ‚Üí [App Name] ‚Üí Permissions
2. Enable Camera permission
3. Check "Don't ask again" wasn't selected
4. Clear app cache if permission stuck

**Web Browser**:
1. Click padlock icon in address bar
2. Reset camera permission
3. Reload page
4. Accept permission prompt

### Issue 5: Photos Not Syncing (TakePhoto)
**Symptoms**: Photos visible locally but not on other devices

**Diagnosis Checklist**:
- [ ] Check sync status indicator
- [ ] Verify "Get attachments" setting enabled
- [ ] Confirm network connectivity
- [ ] Check available cloud storage

**Common Causes**:
1. **"Get attachments" disabled**: Enable in notebook settings
2. **Sync timeout**: Photos >10MB may timeout
3. **Quota exceeded**: Check CouchDB attachment limits
4. **Network interruption**: Retry sync manually

**Solutions**:
1. Enable "Get attachments" in sync settings
2. Reduce photo quality if consistently failing
3. Sync over WiFi for large photo sets
4. Check server attachment quota

## JSON Examples {comprehensive}

### Example 1: Basic File Upload with Size Limits
```json
{
  "supporting-documents": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Supporting Documents",
      "name": "supporting-documents",
      "helperText": "Upload permits, maps, protocols (max 10MB each)",
      "multiple": true,
      "maximum_file_size": 10485760,
      "minimum_file_size": 1024
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null
  }
}
```

### Example 2: Required Single Photo Capture
```json
{
  "artifact-photo": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Artifact Photo",
      "name": "artifact-photo",
      "helperText": "Photograph artifact with scale",
      "required": true,
      "multiple": false
    },
    "validationSchema": [
      ["yup.mixed"],
      ["yup.required", "Artifact photo required"]
    ],
    "initialValue": null
  }
}
```

### Example 3: Multiple File Upload with Count Restriction
```json
{
  "site-documentation": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Site Documentation",
      "name": "site-documentation",
      "helperText": "Upload up to 5 files (photos, PDFs, spreadsheets)",
      "advancedHelperText": "## File Requirements\n\n- Maximum 5 files total\n- Each file max 25MB\n- Accepted: JPG, PNG, PDF, XLSX, CSV",
      "multiple": true,
      "maximum_file_size": 26214400,
      "maximum_number_of_files": 5
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null
  }
}
```

### Example 4: Conditional Photo Documentation
```json
{
  "damage-photos": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Damage Documentation",
      "name": "damage-photos",
      "helperText": "Photograph all damaged areas",
      "multiple": true
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "At least one damage photo required"]
    ],
    "initialValue": null,
    "condition": {
      "operator": "equal",
      "field": "condition-assessment",
      "value": "damaged"
    }
  }
}
```

### Example 5: PDF-Only Document Upload
```json
{
  "permits": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Heritage Permits",
      "name": "permits",
      "helperText": "Upload PDF permits only (max 10MB each)",
      "advancedHelperText": "‚ö†Ô∏è **PDF Files Only**\n\nPlease convert all documents to PDF before uploading.\nNon-PDF files will need to be removed.",
      "multiple": true,
      "maximum_file_size": 10485760
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null,
    "meta": {
      "annotation": {
        "include": true,
        "label": "Permit conditions and restrictions"
      }
    }
  }
}
```

### Example 6: Staged Photography Workflow
```json
{
  "before-excavation": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Before Excavation",
      "name": "before-excavation",
      "helperText": "Document initial state (2-5 photos)",
      "required": true,
      "multiple": true
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.required", "Before photos required"],
      ["yup.min", 2, "Minimum 2 photos"],
      ["yup.max", 5, "Maximum 5 photos"]
    ],
    "initialValue": null
  },
  "after-excavation": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "After Excavation",
      "name": "after-excavation",
      "helperText": "Document final state (2-5 photos)"
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 2, "Minimum 2 photos"]
    ],
    "initialValue": null,
    "condition": {
      "operator": "is-truthy",
      "field": "before-excavation"
    }
  }
}
```

### Example 7: Large Media Files with Warning
```json
{
  "video-documentation": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Video Documentation",
      "name": "video-documentation",
      "helperText": "Upload video files (max 100MB)",
      "advancedHelperText": "## ‚ö†Ô∏è Large File Warning\n\n- Files over 50MB may cause sync delays\n- Ensure stable WiFi before syncing\n- Consider compressing videos first",
      "multiple": false,
      "maximum_file_size": 104857600
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null
  }
}
```

### Example 8: Mixed Media Documentation
```json
{
  "excavation-media": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Excavation Media",
      "name": "excavation-media",
      "helperText": "Photos, videos, plans (max 25MB each, 10 files total)",
      "multiple": true,
      "maximum_file_size": 26214400,
      "maximum_number_of_files": 10
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null
  }
}
```

### Example 9: Progressive Photo Requirements
```json
{
  "context-photos": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Context Photos",
      "name": "context-photos",
      "helperText": "North, South, East, West views plus overhead",
      "multiple": true
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.required", "Context photos required"],
      ["yup.min", 5, "Need all 5 standard views"]
    ],
    "initialValue": null
  }
}
```

### Example 10: Data Files with Metadata
```json
{
  "analysis-data": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Analysis Data Files",
      "name": "analysis-data",
      "helperText": "Upload CSV, XLSX data files",
      "multiple": true,
      "maximum_file_size": 5242880,
      "maximum_number_of_files": 3
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null,
    "meta": {
      "annotation": {
        "include": true,
        "label": "Data collection methods and parameters"
      },
      "uncertainty": {
        "include": true,
        "label": "Data quality concerns"
      }
    }
  }
}
```

### Example 11: Emergency Documentation Mode
```json
{
  "salvage-photos": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Salvage Documentation",
      "name": "salvage-photos",
      "helperText": "Quick capture - as many as needed",
      "multiple": true
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null,
    "condition": {
      "operator": "equal",
      "field": "recording-type",
      "value": "emergency-salvage"
    }
  }
}
```

### Example 12: Structured Upload Workflow
```json
{
  "plans": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Site Plans",
      "name": "plans",
      "helperText": "Upload georeferenced plans (PDF/TIFF)",
      "multiple": true,
      "maximum_file_size": 52428800,
      "maximum_number_of_files": 3
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null
  },
  "sections": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Section Drawings",
      "name": "sections",
      "helperText": "Upload section drawings (PDF/JPG)",
      "multiple": true,
      "maximum_file_size": 26214400,
      "maximum_number_of_files": 5
    },
    "validationSchema": [["yup.mixed"]],
    "initialValue": null,
    "condition": {
      "operator": "is-truthy",
      "field": "plans"
    }
  }
}
```

### Example 13: Performance-Optimized Configuration
```json
{
  "field-photos": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Field Photos",
      "name": "field-photos",
      "helperText": "Max 10 photos to prevent sync issues",
      "multiple": true
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.max", 10, "Maximum 10 photos for performance"]
    ],
    "initialValue": null
  }
}
```

### Example 14: Compliance Documentation
```json
{
  "compliance-docs": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Compliance Documentation",
      "name": "compliance-docs",
      "helperText": "Safety certificates, insurance, permits",
      "advancedHelperText": "## Required Documents\n\n1. Public liability insurance\n2. Safety management plan\n3. Heritage permit\n4. Landowner consent",
      "required": true,
      "multiple": true,
      "maximum_file_size": 10485760,
      "minimum_file_size": 1024,
      "maximum_number_of_files": 10
    },
    "validationSchema": [
      ["yup.mixed"],
      ["yup.required", "Compliance documentation required"]
    ],
    "initialValue": null
  }
}
```

### Example 15: Artifact Photography Standards
```json
{
  "artifact-images": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Artifact Photography",
      "name": "artifact-images",
      "helperText": "Multiple angles with scale",
      "advancedHelperText": "## Photography Requirements\n\n- Front view with scale\n- Back view\n- Profile views if relevant\n- Detail shots of diagnostic features",
      "required": true,
      "multiple": true
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.required", "Artifact photos required"],
      ["yup.min", 2, "Minimum front and back views"]
    ],
    "initialValue": null,
    "meta": {
      "annotation": {
        "include": true,
        "label": "Photography conditions and issues"
      }
    }
  }
}
```

### Example 16: Conditional Document Upload
```json
{
  "permit-documents": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Permit Documentation",
      "name": "permit-documents",
      "helperText": "Upload permits and approvals (Max 10MB each)",
      "multiple": true,
      "maximum_file_size": 10485760,
      "maximum_number_of_files": 5
    },
    "validationSchema": [["yup.mixed"]],
    "condition": {
      "operator": "equal",
      "field": "site-type",
      "value": "restricted"
    }
  }
}
```

### Example 17: Large File Warning Configuration
```json
{
  "video-documentation": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Video Files",
      "name": "video-documentation",
      "helperText": "‚ö†Ô∏è WARNING: Max 100MB per file. Videos will impact sync performance.",
      "advancedHelperText": "## Video Guidelines\n\n- Compress videos before upload\n- Consider frame extraction for analysis\n- Upload will timeout after 120 seconds",
      "multiple": false,
      "maximum_file_size": 104857600,
      "minimum_file_size": 1024
    },
    "validationSchema": [["yup.mixed"]],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Video content description"
      }
    }
  }
}
```

### Example 18: Multi-Stage Photo Workflow
```json
{
  "excavation-progress": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Excavation Stage Photos",
      "name": "excavation-progress",
      "helperText": "Document each 10cm level",
      "advancedHelperText": "## Photo Protocol\n\n1. Overview from fixed photo point\n2. Plan view with north arrow\n3. Representative profile\n4. Any features or finds in situ",
      "multiple": true
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 3, "Minimum 3 photos per level"],
      ["yup.max", 20, "Maximum 20 photos for performance"]
    ],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Depth and stage notes"
      },
      "uncertainty": {
        "include": true,
        "label": "Photo quality issues"
      }
    }
  }
}
```

### Example 19: Emergency Documentation Fallback
```json
{
  "emergency-capture": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Emergency Documentation",
      "name": "emergency-capture",
      "helperText": "Quick capture - quality secondary to speed",
      "multiple": true
    },
    "validationSchema": [["yup.array"]],
    "condition": {
      "operator": "equal",
      "field": "documentation-type",
      "value": "emergency"
    }
  }
}
```

### Example 20: Mixed Media Archive Upload
```json
{
  "archive-materials": {
    "component-namespace": "faims-custom",
    "component-name": "FileUploader",
    "type-returned": "faims-attachment::Files",
    "component-parameters": {
      "label": "Archive Materials",
      "name": "archive-materials",
      "helperText": "PDFs, images, spreadsheets accepted. Max 50MB each.",
      "advancedHelperText": "## Accepted Formats\n\n- Documents: PDF, DOC, DOCX\n- Images: JPG, PNG, TIFF\n- Data: CSV, XLS, XLSX\n- Archives: ZIP (under 50MB)",
      "multiple": true,
      "maximum_file_size": 52428800,
      "maximum_number_of_files": 10
    },
    "validationSchema": [["yup.mixed"]],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Archive catalog numbers and descriptions"
      }
    }
  }
}
```

## Migration Scenarios {comprehensive}

### Scenario 1: File Size Limit Changes
**Context**: Project needs stricter file size limits due to sync performance issues

**Challenge**: Existing records have files exceeding new limits
- Current files may be 100MB+
- New limit needs to be 50MB
- No retroactive validation available

**Migration Steps**:
1. Export existing data with attachment metadata
2. Identify files exceeding new limits
3. Compress or split large files externally
4. Update FileUploader configuration with new `maximum_file_size`
5. Document compression requirements in helper text

### Scenario 2: Moving from FileUploader to TakePhoto
**Context**: Project shifts from accepting any images to requiring in-field capture only

**Challenge**: Data structure differences
- FileUploader accepts any file type
- TakePhoto produces only JPEG at 90% quality
- GPS metadata available only with TakePhoto on native apps

**Migration Steps**:
1. Extract image files from FileUploader records
2. Document which images need recapture
3. Update field configuration to TakePhoto
4. Train users on camera-only workflow
5. Consider keeping FileUploader for historical data

### Scenario 3: Photo Quality/Compression Requirements
**Context**: Storage constraints require reducing photo sizes

**Challenge**: TakePhoto has fixed 90% JPEG quality
- No in-app compression settings
- Files typically 2-5MB each
- Need <1MB per photo

**Workarounds**:
1. External compression before upload (FileUploader)
2. Reduce camera resolution in device settings
3. Post-process photos after sync
4. Consider using FileUploader with compressed images
5. Document size requirements clearly

### Scenario 4: Handling Orphaned Attachments
**Context**: Database has accumulated orphaned media files from deleted records

**Challenge**: No automatic cascade deletion
- Attachments remain after record deletion
- Storage quota being consumed
- No built-in cleanup tools

**Migration Steps**:
1. Audit attachment references in database
2. Identify orphaned files (no parent record)
3. Backup orphaned files before deletion
4. Manual cleanup via database tools
5. Implement deletion procedures to prevent future orphans

### Scenario 5: Multiple to Single File Fields
**Context**: Simplifying form to accept only one file instead of multiple

**Challenge**: Existing records have arrays of files
- Current: `multiple: true` with file arrays
- Target: `multiple: false` with single file
- Validation schema changes required

**Migration Steps**:
1. Export existing multi-file data
2. Decide which file to keep (first, largest, most recent)
3. Update field configuration to `multiple: false`
4. Change validation from `yup.array` to `yup.mixed`
5. Re-import with single file per record

## Best Practices {comprehensive}

### Performance Best Practices
- **FileUploader:** Limit individual files to 50MB
- **TakePhoto:** Maximum 20 photos per field
- **Total per record:** Keep under 200MB combined
- **Helper text:** Always specify size/count limits
- **Sync strategy:** Disable "Get attachments" for bandwidth
- **Batch uploads:** Process in groups to avoid timeouts

### Security Best Practices
- **Deployment:** Trusted research teams only
- **Documentation:** List acceptable file types
- **Monitoring:** Review uploads regularly
- **Server validation:** Implement if public-facing
- **Storage limits:** Set maximum sizes via JSON

### Storage Management Best Practices
- **Pre-fieldwork:** Check device storage availability
- **Size limits:** Document in helper text clearly
- **Sync strategy:** Consider "Get attachments" setting impact
- **Regular cleanup:** Remove orphaned attachments periodically
- **Compression:** Train users on image optimization

## Field Quirks Index (2025-01-03) {comprehensive}

### FileUploader Quirks
- Required validation completely broken
- Silent rejection without user feedback
- Memory leaks from unreleased Object URLs
- No cascade deletion creates orphaned attachments
- Accepts executables without warning

### TakePhoto Quirks
- Required validation needs manual JSON configuration
- GPS injection native platforms only
- EXIF data always stripped
- Performance degradation after 20 photos
- Permission error shows wrong component (LocationPermissionIssue)

### Shared Quirks
- No progress indicators during upload
- Original filenames lost in export
- Base64 encoding 33% overhead
- No file-level annotations (field-level only)
- Export filename pattern inconsistent

## Performance Thresholds Summary {essential}
See [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md) for detailed metrics.

**Media-Specific Thresholds:**
| Metric | FileUploader | TakePhoto | Impact |
|--------|--------------|-----------|---------|
| Individual file | 50MB soft / 100MB hard | N/A | Browser crash risk |
| Total per field | 200MB | 20 photos | Form sluggish |
| Concurrent operations | 3 uploads | 1 capture | UI blocks |
| Memory overhead | +33% base64 | +33% base64 | Quota exhaustion |
| Sync timeout | 120 seconds | 120 seconds | Upload fails |
| Storage quota | 1GB Safari / 6GB Chrome | Same | Capture fails |

## JSON Patterns Cookbook (2025-01-03) {comprehensive}

### Pattern: Conditional Media Requirements
```json
{
  "damage-photos": {
    "component-namespace": "faims-custom",
    "component-name": "TakePhoto",
    "type-returned": "faims-attachment::Files",
    "condition": {
      "operator": "and",
      "conditions": [
        {"operator": "equal", "field": "damage-present", "value": "yes"},
        {"operator": "greater-than", "field": "damage-severity", "value": 5}
      ]
    }
  }
}
```

### Pattern: Size-Limited Document Upload
```json
{
  "permits": {
    "component-parameters": {
      "maximum_file_size": 5242880,  // 5MB
      "maximum_number_of_files": 3,
      "helperText": "Max 3 files, 5MB each. Larger files will disappear without warning."
    }
  }
}
```

### Pattern: Required Photo Documentation
```json
{
  "validationSchema": [
    ["yup.array"],
    ["yup.required", "Photos are mandatory"],
    ["yup.test", "file-check", "Invalid photo array", 
      ["yup.ref", "$"], 
      "function(value) { return value && value.length > 0; }"]
  ]
}
```

## JSON Anti-patterns Quick Index {comprehensive}

### ‚ùå Don't: Mix Parameters
```json
// WRONG - TakePhoto doesn't support file size limits
{
  "component-name": "TakePhoto",
  "component-parameters": {
    "maximum_file_size": 10485760  // Ignored!
  }
}
```

### ‚ùå Don't: Wrong Namespace
```json
// WRONG - Must be faims-custom
{
  "component-namespace": "core",
  "component-name": "FileUploader"
}
```

### ‚ùå Don't: Invalid Initial Value
```json
// WRONG - Must be null, not empty array
{
  "initialValue": []
}
```

## Quick Diagnosis Tables (2025-01-03) {important}

### Media Field Issues Diagnosis
| Symptom | Field | Likely Cause | Quick Fix | Platform | Prevention |
|---------|-------|--------------|-----------|----------|------------|
| Field not rendering | Both | Wrong namespace | Use `faims-custom` | All | Check spelling |
| Files disappearing | FileUploader | Size limit exceeded | Check maximum_file_size | All | Document limits |
| Can't require field | Both | Validation broken | Add yup.required manually | All | Use helper text |
| No camera option | FileUploader | Wrong field type | Use TakePhoto instead | All | Field selection |
| No GPS coordinates | TakePhoto | Web platform | Use native app | Web | Platform choice |
| Slow form | TakePhoto | Too many photos | Limit to 20 maximum | Mobile | Set max validation |
| Upload fails | Both | Network timeout | Check file sizes | All | <50MB files |
| Permission denied | TakePhoto | Camera access blocked | Check settings | All | Pre-setup |
| Memory crash | Both | Files too large | Reduce file size | Mobile | Compress first |
| No progress bar | Both | Not implemented | Inform users to wait | All | Set expectations |
| EXIF stripped | Both | Security feature | Cannot preserve | All | Document separately |
| Sync timeout | Both | Large attachments | Use WiFi, smaller files | Mobile | Batch uploads |
| Photos local only | TakePhoto | "Get attachments" off | Enable in settings | All | Check settings |
| Wrong component | Both | Copy-paste error | Verify component-name | All | Double-check |
| Empty array error | Both | Wrong initial value | Use null not [] | All | Correct init |

## Field Interaction Matrix (2025-01-03) {important}

### Media Fields with Other Field Types
| Field Combination | Interaction | Common Pattern |
|------------------|-------------|----------------|
| FileUploader + TakePhoto | Independent | Mixed media workflows |
| TakePhoto + TakePoint | Complementary | Photo with GPS reference |
| FileUploader + Select | Categorization | Document type selection |
| TakePhoto + Annotation | Metadata | Photo descriptions |
| FileUploader + TextField | Description | File source notes |
| Media + TemplatedString | Identification | Generate file identifiers |

## Migration Warnings Index (2025-01-03) {comprehensive}

### Critical Migration Issues
1. **Required validation breaks** - Must use helper text instead
2. **File type restrictions** not available - No MIME filtering
3. **Progress indicators** missing - Users wait without feedback
4. **EXIF preservation** not possible - Stripped on upload
5. **Bulk operations** require manual configuration
6. **Performance limits** strict - 50MB files, 20 photos maximum
7. **Orphaned attachments** accumulate without cleanup

## See Also {comprehensive}

### Other Field Categories
- **[Text Fields](./text-fields-v05.md)**: For detailed media descriptions and captions
- **[Number Fields](./number-fields-v05.md)**: For file size tracking and GPS coordinates
- **[DateTime Fields](./datetime-fields-v05.md)**: For capture timestamps
- **[Select/Choice Fields](./select-choice-fields-v05.md)**: For media type categorization
- **[Location Fields](./location-fields-v05.md)**: For georeferenced photo locations
- **[Relationship Field](./relationship-field-v05.md)**: For linking media to records
- **[Display Field](./display-field-v05.md)**: For media capture instructions

### Reference Documents
  - [Validation Timing Reference](../reference-docs/validation-timing-reference.md)
  - [Data Export Reference](../reference-docs/data-export-reference.md) - Binary data handling
  - [Security Considerations](../reference-docs/security-considerations-reference.md) - Upload vulnerabilities
  - [Performance Thresholds](../reference-docs/performance-thresholds-reference.md) - Upload limits
  - [Accessibility Reference](../reference-docs/accessibility-reference.md) - Camera accessibility
  - [Component Namespace Reference](../reference-docs/component-namespace-reference.md) - Troubleshooting
  - [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md) - JSON requirements
  - [Meta Properties Reference](../reference-docs/meta-properties-reference.md) - Annotations
  - [Formik Integration Reference](../reference-docs/formik-integration-reference.md) - State management

## Error Message Quick Reference {important}

### Media-Specific Errors
| Error | Field | Cause | Solution |
|-------|-------|-------|----------|
| "Component not found" | Both | Wrong namespace/name | Check capitalisation |
| "Permission denied" | TakePhoto | Camera access denied | System settings |
| "Quota exceeded" | Both | IndexedDB full | Clear cache/data |
| Silent failure | FileUploader | Size/count limit | Check JSON parameters |
| "Cannot read property" | Both | Null initial value issue | Ensure null not [] |
| Memory warning | Both | Large files in memory | Reduce file sizes |
| Sync timeout | Both | Files too large | Limit to 50MB |

## Metadata {comprehensive}
- **Document Version**: v05 (consolidated)
- **Source Documents**: FileUploader.md, TakePhoto.md (Third Draft)
- **Platform Version**: Fieldmark v3 (January 2025)
- **Total Fields**: 2 (FileUploader, TakePhoto)
- **Key Limitations**: Required validation broken, no file type restrictions, silent failures
- **Security Level**: Trusted environments only
- **Performance Limits**: 50MB files, 20 photos maximum
- **Reference Docs**: 9 linked documents
---

## Related Documentation
<!-- concat:references -->

### Within Field Categories
- **Previous**: [Location Fields](./location-fields-v05.md) | [#location-fields](#location-fields)
- **Next**: [Relationship Fields](./relationship-field-v05.md) | [#relationship-fields](#relationship-fields)

### Cross-Field Patterns
- **Validation**: [File Size Limits](../detail-crossfield-docs/validation.md#media-fields) | [#validation-patterns](#validation-patterns)
- **Platform Specific**: [Camera Access](../detail-crossfield-docs/patterns.md#platform-specific) | [#common-patterns](#common-patterns)

### Technical References
- **Platform Behaviors**: [Media Handling](../reference-docs/platform-behaviors-reference.md#media-fields) | [#platform-behaviors](#platform-behaviors)
- **Performance**: [Upload Limits](../reference-docs/performance-thresholds-reference.md#media-fields) | [#performance-thresholds](#performance-thresholds)
- **Security**: [File Validation](../reference-docs/security-considerations-reference.md#media-fields) | [#security-considerations](#security-considerations)

<!-- /concat:references -->
<!-- concat:boundary:end section="media-fields" -->


<!-- concat:document:relationship-field-v05 -->
<!-- concat:boundary:start section="relationship-fields" -->
<!-- concat:metadata
document_id: relationship-field-v05
category: relationship
field_count: 1
designer_capable: ["RelationshipField"]
json_only: ["complex_rules", "cascading_relationships"]
last_updated: 2025-01-05
-->

# Relationship Field - Fieldmark v3 Documentation

## Document Navigation
<!-- concat:nav-mode:individual -->
[‚Üê Media Fields](./media-fields-v05.md) | **Relationship Fields** | [Field Index ‚Üí](../field-type-index.md)
<!-- concat:nav-mode:concatenated -->
<!-- When viewing in reference.md: [‚Üë Top](#fieldmark-v3-field-type-documentation-index) -->


## Overview {essential}

### DESIGNER QUICK GUIDE
**Relationship Field Available:**
- **RelatedRecordSelector** ‚Üí Connect records with bidirectional relationships
## Component Name Mapping {essential}

| Designer UI Label | JSON component-name | Namespace | Code File | Description |
|------------------|-------------------|-----------|-----------|-------------|
| Related Record Selector | RelationshipField | faims-custom | RelationshipField.tsx | Record linking |

### Critical Naming Issues {important}
- **Component name mismatch**: Designer shows "Related Record Selector" but component is "RelationshipField"
- **Type confusion**: Returns faims-core::Array, not a custom Relationship type
- **Child vs Linked**: Can switch between modes in Designer but affects behavior significantly
- **Performance critical**: Degrades rapidly with >50 relationships

- Two relationship types: `"Child"` (hierarchical) or `"is-related-to"` (peer)
- Vocabulary pairs immutable after creation - plan carefully

### Field Capabilities Summary
Enables bidirectional connections between records with automatic reciprocal updates. Supports hierarchical parent-child relationships with cascade behavior and semantic peer associations with qualified vocabulary pairs. Critical performance degradation beyond 50 relationships (unusable at 200+). Offline reciprocal updates delayed until synchronization.

### Component Status
| Property | Status | Notes |
|----------|--------|-------|
| Designer Support | ‚ö†Ô∏è Limited | No vocabulary pair configuration |
| JSON Enhancement | Required | Vocabulary pairs, advanced options |
| Validation | ‚úÖ Works | Array/string based on multiple |
| Performance | ‚ö†Ô∏è 50 limit | Degrades rapidly above threshold |
| Offline | ‚ö†Ô∏è Delayed | Reciprocals after sync only |

## Designer Usage Guide {essential}

### What to Select in Designer
1. Navigate to Field Type selection
2. Choose "Custom Field" category
3. Select "RelatedRecordSelector"
4. Configure available properties:
   - Label and name
   - Related form type
   - Relationship type (Child/Linked)
   - Multiple selection toggle

### When JSON Enhancement is Required
**JSON-only parameters:**
- `relation_linked_vocabPair` - Vocabulary pairs for qualified relationships
- `allowLinkToExisting` - Enable/disable linking to existing records
- `related_type_label` - Human-readable form name
- Complex validation schemas
- Performance optimizations

### Designer Limitations {important}
See [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md) for universal constraints.

**Relationship-Specific Designer Limitations:**
- Cannot configure vocabulary pairs for custom relationship labels (JSON only)
- Cannot preview relationships in Designer (must test in web app)
- No test data available (must create real records to test)
- Cannot configure branding or some advanced parameters

## Field Selection Guide {essential}

### When to Use RelatedRecordSelector
RelatedRecordSelector is the **only** relationship field option in Fieldmark. Use it when you need to:
- **Connect two forms/entities** - Link records that reference each other
- **Create hierarchical structures** - Build parent-child relationships (e.g., Site‚ÜíTrench‚ÜíContext)
- **Establish associations** - Connect peer records with qualified relationships
- **Track provenance** - Link samples to their sources
- **Document relationships** - Record how entities relate to each other

**Not suitable for:**
- Simple categorization (use Select fields instead)
- Temporal sequences (use DateTime fields with proper ordering)
- Spatial relationships only (use Location fields with coordinates)
- File attachments (use Media fields)

### Choosing Your Relationship Type
```
Need to connect records?
‚îú‚îÄ Parent owns children?
‚îÇ  ‚îî‚îÄ YES ‚Üí Child relationship
‚îÇ     ‚îú‚îÄ Cascade: Orphans on delete
‚îÇ     ‚îú‚îÄ Exclusive: One parent only
‚îÇ     ‚îî‚îÄ Best for: Site‚ÜíTrench‚ÜíContext
‚îÇ
‚îî‚îÄ Equal partnership?
   ‚îî‚îÄ YES ‚Üí Linked relationship (is-related-to)
      ‚îú‚îÄ Cascade: No deletion impact
      ‚îú‚îÄ Vocabulary: Qualified labels
      ‚îî‚îÄ Best for: Stratigraphic relations
```

### Relationship Type Matrix
| Aspect | Child | Linked (is-related-to) |
|--------|-------|-------------------------|
| Hierarchy | Parent‚ÜíChild | Peer‚ÜîPeer |
| Deletion | Creates orphans | No impact |
| Vocabulary | Fixed labels | Custom pairs |
| Cardinality | 1:N typical | N:N typical |
| Use Case | Site structure | Stratigraphic |

### Vocabulary Pairs for Linked Relationships
**Bidirectional labeling (JSON-only configuration):**
```json
{
  "relation_linked_vocabPair": [
    ["cuts", "is cut by"],
    ["fills", "is filled by"],
    ["is above", "is below"],
    ["same as", "same as"]
  ]
}
```
- First element: Forward label (shown in current record)
- Second element: Reverse label (shown in related record)
- Immutable after relationship creation
- Must be configured before first use

## ‚ö†Ô∏è Critical Security Risks {essential}
See [Security Considerations Reference](../reference-docs/security-considerations-reference.md) for general security patterns.

**Relationship-Specific Security Concerns:**
- **No access control** - Any user can modify any relationship
- **Orphan creation** - Deleting parents leaves orphaned children
- **No cascade delete** - Manual cleanup required
- **Sync conflicts** - Simultaneous edits can corrupt relationships
- **Data exposure** - All relationships visible to all users

**Critical Performance Risks:**
- **<20 relationships**: Optimal performance
- **20-50 relationships**: Acceptable with minor lag
- **50-100 relationships**: Noticeable delays, UI sluggish
- **100-200 relationships**: Severe degradation
- **200+ relationships**: Essentially unusable

**Mitigation Requirements:**
- Split into multiple focused fields for performance
- Document deletion procedures to prevent orphans
- Implement access policies through training
- Archive historical relationships regularly
- Consider alternative designs for large datasets

## What This Field Cannot Do {important}
- **Prevent circular relationships** - A‚ÜíB‚ÜíC‚ÜíA allowed
- **Modify vocabulary after creation** - Immutable once used
- **Validate relationship counts** - No array.length access
- **Show reciprocals immediately offline** - Sync required
- **Handle 200+ relationships** - Performance collapse
- **Auto-cleanup orphans** - Manual intervention needed
- **Provide conflict resolution** - Last-write-wins only
- **Support gesture controls** - No swipe/drag actions

## Common Use Cases {important}
- **Site hierarchies** - Site‚ÜíTrench‚ÜíContext‚ÜíFind structures
- **Stratigraphic documentation** - Cuts/filled by relationships
- **Sample associations** - Linking samples to contexts
- **Feature relationships** - Spatial/temporal connections
- **Cross-cutting associations** - Across hierarchical branches
- **Find assemblages** - Grouping related artifacts
- **Specialist analysis** - Primary‚Üíspecialist records

## Designer Component Mapping {essential}

### Designer UI vs JSON Component Names

| Designer UI Label | JSON component-name | Component Namespace | Description |
|------------------|--------------------|--------------------|-------------|
| RelatedRecordSelector | RelatedRecordSelector | faims-custom | Bidirectional record relationships |

### Designer Configuration Options

| Designer Option | JSON Parameter | Values | Description |
|----------------|----------------|---------|-------------|
| Related Form | `related_type` | Form viewset ID | Target form for relationships |
| Relationship Type | `relation_type` | "Child" or "is-related-to" | Hierarchical vs peer relationships |
| Allow Multiple | `multiple` | true/false | Single or multiple relationships |
| Allow Link to Existing | `allowLinkToExisting` | true/false | Enable linking vs only creation |
| Required | Via validation schema | yup.required | Must be set with validation |

‚ö†Ô∏è **Critical Notes**:
- Only one relationship field type exists (RelatedRecordSelector)
- Vocabulary pairs for "is-related-to" require JSON editing
- Performance degrades severely beyond 50 relationships
- Reciprocal updates only occur after synchronization

## Designer Capabilities vs JSON Enhancement {essential}

### Designer Configuration
- ‚úÖ Field label and name
- ‚úÖ Related form selection
- ‚úÖ Relationship type (Child/Linked dropdown)
- ‚úÖ Multiple selection toggle
- ‚úÖ Allow linking to existing records toggle
- ‚úÖ Related Type Label field
- ‚úÖ Helper text (basic and advanced)
- ‚úÖ Required flag
- ‚úÖ Display in child records option

### JSON-Only Configuration
```json
{
  "relation_linked_vocabPair": [
    ["forward", "reverse"]  // Custom relationship labels
  ],
  "branding": {},          // Advanced branding options
  "initialValue": []       // Pre-selected relationships
}
```

## Component Namespace Errors {important}
See [Component Namespace Reference](../reference-docs/component-namespace-reference.md) for troubleshooting.

**Common Relationship Errors:**
- Using "RelationshipField" instead of "RelatedRecordSelector"
- Wrong case in component name
- Missing related_type parameter


## When to Use This Field {essential}

### Use RelationshipField When
- Linking parent records to child records (hierarchical data)
- Creating associations between peer records (many-to-many)
- Building specimen/sample hierarchies
- Connecting related observations

### Do NOT Use RelationshipField When
- You have >50 relationships per record (performance degrades)
- Relationships might exceed 200 (becomes unusable)
- You need one-way relationships (always bidirectional)
- Simple foreign key reference sufficient (use Select instead)

### Relationship Type Selection
- **Child**: Hierarchical parent-child with cascade operations
- **is-related-to**: Peer relationships with semantic vocabulary

## Common Characteristics {important}

### Security Considerations {important}
See [Security Considerations Reference](../reference-docs/security-considerations-reference.md) for comprehensive guidelines.

**Relationship-Specific Security Notes:**
- No access control on relationships
- All users can modify any relationship
- Soft-delete preserves data trail
- No audit log for relationship changes

### Performance Boundaries {important}
See [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md) for general limits.

**Relationship-Specific Performance:**
- **Query time**: Linear with relationship count
- **Render time**: 100ms per 10 relationships
- **Memory usage**: ~10KB per relationship
- **Sync payload**: Grows exponentially
- **Mobile impact**: 2x slower than desktop

### Validation Patterns {important}
See [Validation System Documentation](../detail-crossfield-docs/validation.md) for comprehensive validation patterns and timing.

**Relationship Field-Specific Validation:**
- **Type depends on `multiple`**: Array validation when `multiple=true`, String when `false`
- **Reciprocal validation**: Only occurs after sync (delayed)
- **Performance limits**: Use `yup.max` to enforce <50 relationships
- **No error display**: RelatedRecordSelector doesn't show validation messages (known bug)

### Platform Behaviors {important}
See [Platform Behaviors Reference](../reference-docs/platform-behaviors-reference.md) for general platform characteristics.

**Relationship Field-Specific Behaviors:**
- **iOS**: Touch targets 36px (below WCAG); scroll momentum issues; modal height limited to 70%
- **Android**: 20% worse performance than iOS; 200ms autocomplete lag; back button closes modal
- **Web**: Best performance for large sets; partial keyboard navigation; hover shows full HRID
- **Mobile**: Viewport constraints; keyboard obscures content; faster performance degradation

### Meta Properties {important}
See [Meta Properties Reference](../reference-docs/meta-properties-reference.md) for configuration.

Relationships support annotations and uncertainty:
- Annotation: Document relationship rationale
- Uncertainty: Flag tentative associations

### Export Behavior {important}
See [Data Export Reference](../reference-docs/data-export-reference.md) for universal patterns.

**Relationship-Specific Export:**
- **CSV Format**: `{label}/{record_id}` semicolon-separated
- **Example**: `"cuts/ctx043;fills/ctx044"`
- **No hierarchy preservation**: Flattened structure
- **No re-import capability**: Manual reconstruction
- **JSON not available**: Despite internal storage

## Field Reference {essential}

### RelatedRecordSelector {essential}

#### Purpose {essential}
Enables bidirectional connections between records, supporting both hierarchical parent-child relationships and semantic peer associations with qualified vocabulary pairs. Maintains data coherence through automatic reciprocal updates within distributed architecture.

#### Quick Reference
| Property | Details |
|----------|---------|
| Component | `faims-custom::RelatedRecordSelector` |
| Returns | `faims-core::Array` |
| Designer | ‚ö†Ô∏è Limited support |
| JSON Required | Vocabulary pairs |
| Performance Limit | 50 relationships |
| Offline Behavior | Delayed reciprocals |
| Touch Target | 36px (suboptimal) |
| Cascade Delete | Orphans (Child only) |

#### Core Configuration
```json
{
  "component-namespace": "faims-custom",
  "component-name": "RelatedRecordSelector",
  "type-returned": "faims-core::Array",
  "component-parameters": {
    "name": "field-name",
    "label": "Relationships",
    "related_type": "TargetFormID",
    "relation_type": "Child",
    "multiple": true,
    "required": false,
    "helperText": "Add related records"
  },
  "validationSchema": [["yup.array"]],
  "initialValue": []
}
```

#### Advanced Configuration
```json
{
  "stratigraphic_relationships": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "stratigraphic_relationships",
      "label": "Stratigraphic Relationships",
      "related_type": "Context",
      "relation_type": "is-related-to",
      "multiple": true,
      "allowLinkToExisting": true,
      "related_type_label": "Context Record",
      "relation_linked_vocabPair": [
        ["cuts", "is cut by"],
        ["fills", "is filled by"],
        ["is above", "is below"],
        ["abuts", "abuts"],
        ["same as", "same as"],
        ["contemporary with", "contemporary with"]
      ],
      "helperText": "Define stratigraphic relationships"
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "At least one relationship required"]
    ],
    "initialValue": [],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Relationship notes"
      },
      "uncertainty": {
        "include": true,
        "label": "Confidence level"
      }
    }
  }
}
```

#### Platform-Specific Behaviors
- **Desktop**: Full autocomplete, easier selection
- **Mobile**: Constrained viewport, difficult search
- **Offline**: No reciprocal updates until sync
- **All**: Sequential metadata fetching causes lag

#### Common Issues & Solutions
| Issue | Cause | Solution |
|-------|-------|----------|
| Performance lag | >50 relationships | Split into multiple fields |
| No reciprocals | Offline operation | Wait for sync |
| Cannot change vocabulary | Immutable design | Plan carefully |
| Orphaned records | Parent deletion | Manual cleanup |
| Touch targets small | 36px height | Use desktop for complex work |

## Troubleshooting Guide {important}

### Issue 1: Severe Performance Degradation
**Symptoms**: UI becomes sluggish, selection modal slow to open, app may freeze

**Diagnosis Steps**:
1. Count total relationships in the field
2. Check if approaching 50 relationship threshold
3. Monitor browser/app memory usage
4. Test on different device to isolate issue

**Performance Thresholds**:
- **<20 relationships**: Optimal performance
- **20-50 relationships**: Noticeable slowdown
- **50-100 relationships**: Severe degradation
- **100-200 relationships**: Nearly unusable
- **>200 relationships**: App crashes likely

**Solutions**:
1. Split into multiple relationship fields by category
2. Archive completed relationships regularly
3. Use hierarchical Child relationships instead of flat lists
4. Consider external reference system for large networks

### Issue 2: Reciprocal Updates Not Appearing
**Symptoms**: Related record doesn't show reverse relationship

**Root Cause**: Offline mode delays reciprocal updates until sync

**Diagnosis**:
- Check sync status indicator
- Verify both records have been synced
- Confirm vocabulary pair configuration
- Test with forced sync

**Solutions**:
1. **Immediate**: Force sync and refresh both records
2. **Workaround**: Document relationships externally while offline
3. **Prevention**: Sync before major relationship changes
4. **Training**: Explain delayed reciprocals to users

### Issue 3: Orphaned Records After Deletion
**Symptoms**: Child records exist without parent, shown as "orphaned"

**Understanding the Behavior**:
- Deleting parent with Child relationships creates orphans
- Orphaned records remain in database
- No automatic cascade delete
- Orphans marked but not removed

**Solutions**:
1. **Manual cleanup**: Delete orphans individually
2. **Reassignment**: Link orphans to new parent
3. **Prevention**: Delete children before parent
4. **Policy**: Document deletion procedures

### Issue 4: Cannot Find Records to Link
**Symptoms**: Known records don't appear in selection modal

**Common Causes**:
1. **No HRID**: Records without TemplatedString field won't display properly
2. **Wrong form type**: Checking incorrect related_type
3. **Not synced**: New records not yet synchronized
4. **Search syntax**: Autocomplete requires exact HRID prefix

**Solutions by Cause**:
- **Missing HRID**: Add TemplatedString field to related form
- **Wrong type**: Verify related_type matches target form
- **Sync issue**: Force sync and retry
- **Search issue**: Use exact HRID format (case-sensitive)

### Issue 5: Validation Errors Not Clear
**Symptoms**: Form won't submit but no clear error on relationship field

**Diagnosis Checklist**:
- [ ] Check if field marked as required
- [ ] Verify multiple setting matches validation schema
- [ ] Count relationships against any max validation
- [ ] Test with single vs array validation

**Common Validation Issues**:
```json
{
  "WRONG_example": {
    "comment": "Single relationship with array validation - MISMATCH",
    "multiple": false,
    "validationSchema": [["yup.array"]]
  },
  "CORRECT_single": {
    "comment": "Single relationship - correct validation",
    "multiple": false,
    "validationSchema": [["yup.string"]]
  },
  "CORRECT_multiple": {
    "comment": "Multiple relationships - correct validation",
    "multiple": true,
    "validationSchema": [["yup.array"]]
  }
}
```
4. Review sync payload size
5. Consider field splitting

### Data Integrity
- Document deletion procedures
- Plan orphan cleanup
- Coordinate auto-incrementer ranges
- Test offline workflows
- Establish conflict protocols

### Configuration Problems
- Verify exact viewset IDs
- Check TemplatedString HRIDs
- Confirm vocabulary pairs before use
- Test on all platforms
- Document team procedures

## JSON Examples {comprehensive}

### Example 1: Basic Parent-Child Hierarchy
```json
{
  "child-contexts": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "child-contexts",
      "label": "Contexts",
      "related_type": "Context",
      "relation_type": "Child",
      "multiple": true,
      "allowLinkToExisting": false
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

### Example 2: Required Single Parent
```json
{
  "parent-trench": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "parent-trench",
      "label": "Parent Trench",
      "related_type": "Trench",
      "relation_type": "Child",
      "multiple": false,
      "required": true,
      "allowLinkToExisting": true,
      "helperText": "Select the trench this context belongs to"
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Parent trench required"]
    ],
    "initialValue": null
  }
}
```

### Example 3: Stratigraphic Relationships with Vocabulary
```json
{
  "stratigraphic-relationships": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "stratigraphic-relationships",
      "label": "Stratigraphic Relationships",
      "related_type": "Context",
      "relation_type": "is-related-to",
      "multiple": true,
      "allowLinkToExisting": true,
      "relation_linked_vocabPair": [
        ["cuts", "is cut by"],
        ["fills", "is filled by"],
        ["is above", "is below"],
        ["abuts", "abuts"],
        ["same as", "same as"]
      ],
      "helperText": "Define relationships with other contexts"
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

### Example 4: Find Assemblage Grouping
```json
{
  "related-finds": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "related-finds",
      "label": "Related Finds",
      "related_type": "Find",
      "relation_type": "is-related-to",
      "multiple": true,
      "allowLinkToExisting": true,
      "relation_linked_vocabPair": [
        ["part of set", "includes"],
        ["matches", "matches"],
        ["associated with", "associated with"]
      ]
    },
    "validationSchema": [["yup.array"]],
    "initialValue": [],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Relationship justification"
      }
    }
  }
}
```

### Example 5: Sample Chain of Custody
```json
{
  "sample-relationships": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "sample-relationships",
      "label": "Sample Relationships",
      "related_type": "Sample",
      "relation_type": "is-related-to",
      "multiple": true,
      "relation_linked_vocabPair": [
        ["subsample of", "has subsample"],
        ["split from", "split into"],
        ["control for", "controlled by"],
        ["duplicate of", "duplicate of"]
      ]
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

### Example 6: Site-Trench-Context Hierarchy
```json
{
  "trenches": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "trenches",
      "label": "Trenches within Site",
      "related_type": "Trench",
      "relation_type": "Child",
      "multiple": true,
      "allowLinkToExisting": false,
      "related_type_label": "Trench Record",
      "helperText": "Create new trenches for this site"
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

### Example 7: Feature Cross-References
```json
{
  "related-features": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "related-features",
      "label": "Related Features",
      "related_type": "Feature",
      "relation_type": "is-related-to",
      "multiple": true,
      "allowLinkToExisting": true,
      "relation_linked_vocabPair": [
        ["built on", "supports"],
        ["replaces", "replaced by"],
        ["contemporary with", "contemporary with"],
        ["connected to", "connected to"]
      ]
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

### Example 8: Specialist Analysis Links
```json
{
  "specialist-analyses": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "specialist-analyses",
      "label": "Specialist Analyses",
      "related_type": "Analysis",
      "relation_type": "Child",
      "multiple": true,
      "allowLinkToExisting": false,
      "helperText": "Create analysis records for this context"
    },
    "validationSchema": [["yup.array"]],
    "initialValue": [],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Analysis type and specialist"
      }
    }
  }
}
```

### Example 9: Conditional Parent Requirement
```json
{
  "parent-structure": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "parent-structure",
      "label": "Parent Structure",
      "related_type": "Structure",
      "relation_type": "Child",
      "multiple": false,
      "allowLinkToExisting": true,
      "required": true
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Parent structure required"]
    ],
    "initialValue": null,
    "condition": {
      "operator": "equal",
      "field": "element-type",
      "value": "structural-element"
    }
  }
}
```

### Example 10: Documentation Attachments
```json
{
  "related-documentation": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "related-documentation",
      "label": "Related Documentation",
      "related_type": "Document",
      "relation_type": "is-related-to",
      "multiple": true,
      "relation_linked_vocabPair": [
        ["documented in", "documents"],
        ["referenced in", "references"],
        ["illustrated in", "illustrates"]
      ]
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

### Example 11: Survey Unit Hierarchy
```json
{
  "survey-units": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "survey-units",
      "label": "Survey Units",
      "related_type": "SurveyUnit",
      "relation_type": "Child",
      "multiple": true,
      "allowLinkToExisting": false,
      "helperText": "Create survey units within this area"
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "At least one survey unit required"]
    ],
    "initialValue": []
  }
}
```

### Example 12: Temporal Relationships
```json
{
  "temporal-relationships": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "temporal-relationships",
      "label": "Temporal Relationships",
      "related_type": "Phase",
      "relation_type": "is-related-to",
      "multiple": true,
      "relation_linked_vocabPair": [
        ["earlier than", "later than"],
        ["contemporary with", "contemporary with"],
        ["transitions to", "transitions from"],
        ["overlaps with", "overlaps with"]
      ]
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

### Example 13: Performance-Limited Configuration
```json
{
  "limited-relationships": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "limited-relationships",
      "label": "Related Records (Max 30)",
      "related_type": "Record",
      "relation_type": "is-related-to",
      "multiple": true,
      "helperText": "‚ö†Ô∏è LIMIT 30 relationships for performance"
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.max", 30, "Maximum 30 relationships allowed"]
    ],
    "initialValue": []
  }
}
```

### Example 14: Excavation Team Assignment
```json
{
  "team-members": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "team-members",
      "label": "Team Members",
      "related_type": "Person",
      "relation_type": "is-related-to",
      "multiple": true,
      "allowLinkToExisting": true,
      "relation_linked_vocabPair": [
        ["excavated by", "excavated"],
        ["recorded by", "recorded"],
        ["supervised by", "supervised"]
      ]
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

### Example 15: Conservation Treatment Chain
```json
{
  "conservation-history": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "conservation-history",
      "label": "Conservation History",
      "related_type": "Treatment",
      "relation_type": "is-related-to",
      "multiple": true,
      "relation_linked_vocabPair": [
        ["treated with", "applied to"],
        ["follows", "precedes"],
        ["reverses", "reversed by"]
      ]
    },
    "validationSchema": [["yup.array"]],
    "initialValue": [],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Treatment notes"
      }
    }
  }
}
```

### Example 16: Interpretive Associations
```json
{
  "interpretations": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "interpretations",
      "label": "Interpretive Links",
      "related_type": "Interpretation",
      "relation_type": "is-related-to",
      "multiple": true,
      "relation_linked_vocabPair": [
        ["interpreted as", "interpretation of"],
        ["supports interpretation", "supported by"],
        ["contradicts", "contradicted by"]
      ]
    },
    "validationSchema": [["yup.array"]],
    "initialValue": [],
    "meta": {
      "uncertainty": {
        "include": true,
        "label": "Interpretive confidence"
      }
    }
  }
}
```

### Example 17: Conditional Relationship Field
```json
{
  "specialist-samples": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "specialist-samples",
      "label": "Specialist Analysis Samples",
      "related_type": "Sample",
      "relation_type": "Child",
      "multiple": true,
      "related_type_label": "Analysis Sample",
      "allowLinkToExisting": false
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "At least one sample required"]
    ],
    "condition": {
      "operator": "equal",
      "field": "requires-analysis",
      "value": "yes"
    },
    "initialValue": []
  }
}
```

### Example 18: Cross-Referenced Features
```json
{
  "cross-references": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "cross-references",
      "label": "Cross-Referenced Features",
      "related_type": "Feature",
      "relation_type": "is-related-to",
      "multiple": true,
      "relation_linked_vocabPair": [
        ["references", "referenced by"],
        ["supersedes", "superseded by"],
        ["duplicates", "duplicates"],
        ["contradicts", "contradicted by"],
        ["supports", "supported by"]
      ],
      "helperText": "‚ö†Ô∏è Performance limit: 50 relationships maximum"
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.max", 50, "Maximum 50 relationships for performance"]
    ],
    "initialValue": []
  }
}
```

### Example 19: Equipment Assignment Tracking
```json
{
  "equipment-used": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "equipment-used",
      "label": "Equipment Used",
      "related_type": "Equipment",
      "relation_type": "is-related-to",
      "multiple": true,
      "relation_linked_vocabPair": [
        ["used equipment", "used in operation"],
        ["borrowed", "loaned to"],
        ["damaged", "damaged during"]
      ],
      "allowLinkToExisting": true,
      "advancedHelperText": "## Equipment Protocol\n\n- Log all equipment at start of day\n- Note any damage immediately\n- Update if equipment changed"
    },
    "validationSchema": [["yup.array"]],
    "meta": {
      "annotation": {
        "include": true,
        "label": "Equipment condition notes"
      }
    },
    "initialValue": []
  }
}
```

### Example 20: Publication Citations Network
```json
{
  "related-publications": {
    "component-namespace": "faims-custom",
    "component-name": "RelatedRecordSelector",
    "type-returned": "faims-core::Array",
    "component-parameters": {
      "name": "related-publications",
      "label": "Related Publications",
      "related_type": "Publication",
      "relation_type": "is-related-to",
      "multiple": true,
      "relation_linked_vocabPair": [
        ["cites", "cited by"],
        ["responds to", "response from"],
        ["builds upon", "foundation for"],
        ["critiques", "critiqued by"],
        ["corroborates", "corroborated by"]
      ],
      "helperText": "Build citation network for literature review"
    },
    "validationSchema": [["yup.array"]],
    "initialValue": []
  }
}
```

## Migration Scenarios {comprehensive}

### Scenario 1: Performance Scaling - Splitting Large Relationship Sets
**Context**: A project's relationship field has grown beyond the 50-relationship performance threshold, causing severe UI lag on mobile devices.

**Challenge**: 
- Single field with 100+ relationships causes 2-3 second delays
- Mobile devices experiencing crashes
- Sync operations timing out

**Migration Steps**:
1. Export existing relationships to CSV for backup
2. Create multiple relationship fields with semantic groupings:
   ```json
   {
     "primary-relationships": { 
       "multiple": true, 
       "relation_linked_vocabPair": [["primary", "primary of"]] 
     },
     "secondary-relationships": { 
       "multiple": true, 
       "relation_linked_vocabPair": [["secondary", "secondary of"]] 
     }
   }
   ```
3. Manually redistribute relationships across new fields
4. Add validation to enforce maximum of 50 per field
5. Update form documentation with new field organization

**Solution/Workaround**: Split relationships into semantically meaningful groups (e.g., "direct-relationships", "indirect-relationships") with clear documentation of the separation criteria.

### Scenario 2: Vocabulary Restructuring
**Context**: Project needs to change relationship vocabulary pairs after deployment, but vocabulary is immutable once relationships exist.

**Challenge**:
- Vocabulary pairs cannot be modified after first use
- Existing relationships would be lost if field deleted
- No built-in migration tool for vocabulary changes

**Migration Steps**:
1. Create new relationship field with corrected vocabulary
2. Document mapping between old and new vocabulary terms
3. Export all existing relationships
4. Manually recreate relationships with new field
5. Hide (but don't delete) old field to preserve history

**Solution/Workaround**: Run parallel fields during transition period, then hide old field via conditions once migration complete.

### Scenario 3: Hierarchy Flattening
**Context**: Deep hierarchical relationships (5+ levels) are causing performance issues and user confusion.

**Challenge**:
- Deep hierarchies exponentially increase query complexity
- Mobile devices struggle with nested displays
- Users lose context in deep trees

**Migration Steps**:
1. Map existing hierarchy to flattened structure
2. Replace Child relationships with is-related-to
3. Use vocabulary pairs to maintain semantic relationships:
   ```json
   "relation_linked_vocabPair": [
     ["contains", "contained by"],
     ["parent of", "child of"]
   ]
   ```
4. Update queries and reports for flattened structure
5. Retrain users on new relationship model

**Solution/Workaround**: Maintain hierarchy semantically through vocabulary while using flat is-related-to structure.

### Scenario 4: Orphan Cleanup After Mass Deletions
**Context**: Bulk deletion of parent records has left numerous orphaned child records in the database.

**Challenge**:
- No automatic cascade delete
- Orphaned records clutter search results
- Performance degradation from unused records
- No built-in orphan detection

**Migration Steps**:
1. Export all records to identify orphans
2. Create cleanup script to identify records with null parents
3. Document orphan handling policy
4. Implement regular cleanup routine
5. Add pre-deletion checklist to prevent future orphans

**Solution/Workaround**: Implement monthly orphan cleanup routine with documentation of deletion criteria.

### Scenario 5: Converting Between Child and Linked Relationships
**Context**: Project needs to convert Child relationships to is-related-to for flexibility.

**Challenge**:
- Child relationships have different data structure
- Reciprocal relationships need manual recreation
- Loss of hierarchical context

**Migration Steps**:
1. Export all Child relationships
2. Create new is-related-to field with appropriate vocabulary
3. Import relationships with new structure
4. Update all queries expecting Child type
5. Test bidirectional relationship integrity

**Solution/Workaround**: Maintain hierarchical semantics through careful vocabulary design while using flexible is-related-to structure.

## Best Practices {comprehensive}

### Design Principles
- **Shallow hierarchies**: Maximum 3-4 levels
- **Relationship limits**: Stay under 50
- **Vocabulary planning**: Cannot modify later
- **HRID configuration**: Always include TemplatedString
- **Deletion procedures**: Document orphan handling

### Offline Coordination
- Allocate auto-incrementer ranges
- Document sync procedures
- Plan conflict resolution
- Test offline workflows
- Understand reciprocal delays

### Performance Optimization
- Split complex relationships
- Monitor mobile performance
- Implement cleanup routines
- Consider alternatives for large datasets
- Test on lowest-spec devices

### Relationship Management
- Regular orphan cleanup schedules
- Performance monitoring dashboards
- Vocabulary documentation standards
- Relationship limit enforcement
- User training on best practices

## Field Quirks Index (2025-01-03) {comprehensive}
- Vocabulary pairs immutable after use
- Reciprocals delayed until sync
- Performance cliff at 50 relationships
- Touch targets below WCAG standards
- No circular relationship prevention
- Orphans on parent deletion
- No gesture controls
- Autocomplete by HRID only

## Performance Thresholds Summary {essential}
See [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md) for detailed metrics.

**Relationship-Specific Thresholds:**
| Metric | Value | Impact |
|--------|-------|---------|
| Optimal | <20 | Smooth operation |
| Acceptable | 20-50 | Minor lag |
| Degraded | 50-100 | Noticeable delays |
| Severe | 100-200 | Very slow |
| Unusable | >200 | System failure |

## JSON Patterns Cookbook (2025-01-03) {comprehensive}

### Pattern: Conditional Relationships
```json
{
  "condition": {
    "operator": "is",
    "field": "needs_relationships",
    "value": "yes"
  }
}
```

### Pattern: Validation Enforcement
```json
{
  "validationSchema": [
    ["yup.array"],
    ["yup.min", 1, "Required"],
    ["yup.max", 50, "Performance limit"]
  ]
}
```

## JSON Anti-patterns Quick Index {comprehensive}

### ‚ùå Don't: Exceed Performance Limits
```json
{
  "comment": "WRONG - Will cause severe degradation, no maximum validation",
  "multiple": true
}
```

### ‚ùå Don't: Change Vocabulary After Creation
Note: Vocabulary is immutable - must plan before deployment

### ‚ùå Don't: Mix Validation Types
```json
{
  "comment": "WRONG - Multiple requires array validation",
  "multiple": true,
  "validationSchema": [["yup.string"]]
}
```

## Quick Diagnosis Tables (2025-01-03) {important}

### Relationship Issues Diagnosis
| Symptom | Likely Cause | Quick Fix | Platform | Prevention |
|---------|--------------|-----------|----------|------------|
| Slow UI | >50 relationships | Split field | All | Design limits |
| No reciprocals | Offline mode | Wait for sync | All | Sync first |
| Validation fails | Wrong schema type | Check multiple setting | All | Test config |
| Orphaned records | Parent deleted | Manual cleanup | All | Delete order |
| Can't find record | HRID not configured | Add TemplatedString | All | Form design |
| Modal won't open | Too many records | Reduce relationships | Mobile | Limit to 50 |
| Autocomplete broken | Case mismatch | Use exact case | All | Document format |
| Wrong vocabulary | Config locked | Cannot change | All | Plan carefully |
| Duplicate relationships | No validation | Manual check | All | User training |
| Crash on selection | Memory exhaustion | Restart app | Mobile | Regular cleanup |
| Lost relationships | Sync conflict | Check server | All | Avoid simultaneous |
| Can't delete relationship | UI limitation | Edit JSON | All | Known issue |
| Performance lag | Network latency | Work offline | All | Local-first |
| Touch targets small | 36px height | Use desktop | Mobile | WCAG issue |
| Back button closes | Android behavior | Save first | Android | Platform quirk |

## Field Interaction Matrix (2025-01-03) {important}

### Relationships with Other Fields
| Field Combination | Interaction | Pattern |
|------------------|-------------|---------|
| RelatedRecordSelector + TemplatedString | Essential | HRIDs for display |
| RelatedRecordSelector + AutoIncrementer | Common | Feeds HRIDs |
| RelatedRecordSelector + Conditions | Limited | Existence only |
| Multiple RelatedRecordSelectors | Caution | Performance impact |

## Migration Warnings Index (2025-01-03) {comprehensive}

### Critical Migration Issues
1. **Vocabulary pairs immutable** - Cannot change after creation
2. **Type conversion loses data** - Child‚ÜîLinked migration
3. **Performance degradation** - Plan for <50 relationships
4. **No conflict resolution** - Last-write-wins only
5. **Orphan accumulation** - Soft-delete behavior
6. **No re-import** - CSV export one-way
7. **Touch target issues** - Mobile accessibility

## See Also {comprehensive}

### Other Field Categories
- **[Text Fields](./text-fields-v05.md)**: TemplatedString for meaningful HRIDs
- **[Number Fields](./number-fields-v05.md)**: AutoIncrementer feeding HRIDs
- **[DateTime Fields](./datetime-fields-v05.md)**: Temporal relationship tracking
- **[Select/Choice Fields](./select-choice-fields-v05.md)**: Alternative for simple vocabularies
- **[Media Fields](./media-fields-v05.md)**: Attaching files to relationships
- **[Location Fields](./location-fields-v05.md)**: Spatial relationships
- **[Display Field](./display-field-v05.md)**: Relationship instructions

### Reference Documents
  - [Validation Timing Reference](../reference-docs/validation-timing-reference.md)
  - [Component Namespace Reference](../reference-docs/component-namespace-reference.md)
  - [Data Export Reference](../reference-docs/data-export-reference.md)
  - [Security Considerations Reference](../reference-docs/security-considerations-reference.md)
  - [Performance Thresholds Reference](../reference-docs/performance-thresholds-reference.md)
  - [Meta Properties Reference](../reference-docs/meta-properties-reference.md)
  - [Designer Limitations Reference](../reference-docs/designer-limitations-reference.md)
  - [Formik Integration Reference](../reference-docs/formik-integration-reference.md)
  - [Accessibility Reference](../reference-docs/accessibility-reference.md)

## Error Message Quick Reference {important}

### Relationship-Specific Errors
| Error | Cause | Solution |
|-------|-------|----------|
| "Only one related record allowed" | multiple: false with existing | Remove first |
| "this field is required" | Required validation | Add relationship |
| "Target form not found" | Wrong related_type | Check viewset ID |
| Silent failure | Performance overload | Reduce count |
| No autocomplete results | HRID not configured | Add TemplatedString |

## Metadata {comprehensive}
- **Document Version**: v05 (transformed)
- **Source Document**: relationship.md (Third Draft)
- **Platform Version**: Fieldmark v3 (January 2025)
- **Field Count**: 1 (RelatedRecordSelector)
- **Key Limitations**: 50 relationship limit, immutable vocabulary, orphan behavior
- **Performance Critical**: Yes - degrades rapidly
- **Reference Docs**: 9 linked documents
---

## Related Documentation
<!-- concat:references -->

### Within Field Categories
- **Previous**: [Media Fields](./media-fields-v05.md) | [#media-fields](#media-fields)
- **Index**: [Field Documentation Index](../field-type-index.md) | [#fieldmark-v3-field-type-documentation-index](#fieldmark-v3-field-type-documentation-index)

### Cross-Field Patterns
- **Hierarchical Data**: [Parent-Child Records](../detail-crossfield-docs/patterns.md#hierarchical) | [#common-patterns](#common-patterns)
- **Conditional Logic**: [Dependent Records](../detail-crossfield-docs/conditional-logic.md#relationship-fields) | [#conditional-logic](#conditional-logic)

### Technical References
- **Designer Limitations**: [Relationship Constraints](../reference-docs/designer-limitations-reference.md#relationship-fields) | [#designer-limitations](#designer-limitations)
- **Data Export**: [Relationship Handling](../reference-docs/data-export-reference.md#relationships) | [#data-export](#data-export)

<!-- /concat:references -->
<!-- concat:boundary:end section="relationship-fields" -->


<!-- ============================================ -->
<!-- CROSS-FIELD PATTERNS -->
<!-- ============================================ -->


<!-- concat:pattern:field-selection-best-practices -->
# Fieldmark Design Principles and Best Practices for Field Research

## Introduction: Theory and Practice in Digital Field Recording

The design of digital field recording systems requires careful consideration of how data entry mechanisms shape both the quality of collected data and the efficiency of fieldwork. This comprehensive guide provides both theoretical foundations and practical implementation strategies for Fieldmark notebook design, drawing upon a decade of deployment experience across archaeological, ecological, and geoscientific research contexts.

We address two fundamental tensions in field data collection: the need for structured, high-quality data that supports computational analysis and long-term reuse, and the practical constraints of kinetic fieldwork where recording mechanisms must not impede observation and interpretation. We further consider how design decisions impact data FAIRness (Findability, Accessibility, Interoperability, and Reusability) without imposing undue burden on fieldworkers.

The selection of appropriate field types represents more than technical implementation ‚Äì it embodies methodological decisions about data structure, analytical possibilities, and research outcomes. Poor field choices cascade through the entire research lifecycle, whilst thoughtful selection enhances both immediate usability and long-term research value.

## Theoretical Foundations

### Transparent Interaction in Field Contexts

The concept of "transparent interaction" (Weiser, 1991) suggests that the most profound technologies are those that disappear, weaving themselves into the fabric of everyday life until they are indistinguishable from it. In field recording, this means the technology should become an extension of the researcher's observational practice, not an impediment to it. Every design choice should reduce the cognitive and temporal distance between observation and record completion.

In kinetic fieldwork ‚Äì where researchers move continuously through landscapes whilst making observations ‚Äì the recording system must 'fade into the background' (Pascoe et al., 1998), allowing focus to remain on the archaeological or environmental phenomena under study. This theoretical foundation underpins our practical principles and implementation strategies.

### The Kinetic Fieldwork Context

Field recording occurs under conditions that would be considered hostile for most data entry tasks:

**Environmental and Physical Constraints:**
- Visual challenges: Direct sunlight making screens unreadable, dust and rain obscuring displays
- Physical impediments: Muddy or wet hands, thick gloves in cold conditions, carrying equipment
- Attention demands: Maintaining awareness of surroundings for safety and observation
- Time pressure: Limited site access, weather windows, or daylight hours
- Cognitive load: Complex interpretive decisions whilst managing recording

These constraints necessitate interface designs that prioritise robustness over sophistication. A simple radio button that works reliably with muddy fingers proves more valuable than an elegant multi-touch gesture that fails in wet conditions.

**The Temporality of Field Observation:**

Field observation exhibits distinct temporal patterns that recording systems must accommodate:
1. **Burst recording**: Intense periods of rapid data entry alternating with movement or excavation
2. **Progressive refinement**: Initial rapid capture followed by detailed documentation
3. **Retrospective correction**: Reinterpretation based on subsequent discoveries
4. **Collaborative elaboration**: Multiple team members contributing observations

These patterns argue for recording systems that support both rapid initial capture and subsequent enhancement, rather than enforcing comprehensive documentation at first encounter.

## Core Design Principles

### Principle 1: Minimise Recording Friction

This principle manifests in several practical imperatives:
- **Automate everything the system can know**: If information exists within the system (user identity, timestamp, location, parent record context), never require manual re-entry
- **Design for environmental extremes**: Assume bright sunlight, rain, cold fingers, wet screens, gloved hands, and exhausted fieldworkers at hour eight
- **Optimise for common cases**: Make frequent tasks exceptionally fast, even if rare tasks require slightly more effort
- **Respect device constraints**: On mobile devices with limited screen space, avoid UI patterns that demand extensive scrolling or precise touch targets

### Principle 2: Prefer Structure Over Unstructured Data

Controlled vocabularies ‚Äì implemented through choice fields ‚Äì should be deployed wherever feasible in preference to free-text entry. This preference stems not from technological determinism but from empirical observation: unstructured text collected in the field rarely achieves the analytical utility promised by its apparent flexibility.

**The False Dichotomy of Flexibility:**

The apparent trade-off between controlled vocabularies and descriptive freedom represents a false dichotomy. Fieldmark's annotation and uncertainty mechanisms provide sophisticated means to capture nuance, qualification, and contextual detail whilst maintaining structural integrity. A ceramic sherd can be classified as "Fine Ware" whilst simultaneously annotated with observations about unusual characteristics, preservation conditions, or interpretive uncertainty.

**Benefits of Structured Capture:**
- Immediate validation: Preventing data entry errors at the point of collection
- Cross-project comparability: Enabling meta-analysis across datasets
- Computational readiness: Supporting statistical analysis without extensive cleaning
- Multilingual accessibility: Allowing interface translation whilst maintaining data integrity
- Query efficiency: Enabling rapid filtering and aggregation

### Principle 3: Design for Data Lifecycle, Not Just Collection

Field recording systems must consider the entire data lifecycle from collection through analysis to long-term preservation and reuse:
- **Capture provenance automatically**: Who collected data, when, where, and under what project
- **Maintain referential integrity**: Ensure relationships between entities remain navigable
- **Enable progressive enhancement**: Allow initial rapid capture with subsequent detailed documentation
- **Support versioning and correction**: Acknowledge that field interpretations evolve

## FAIR Data Principles in Field Recording

### Findability Through Systematic Identification

The FAIR principles (Wilkinson et al., 2016) emphasise that data should be Findable, Accessible, Interoperable, and Reusable. In field recording, findability begins with systematic identification schemes that persist across the data lifecycle.

**Implementation Strategy:**
- Deploy TemplatedStringField for human-readable identifiers combining semantic components
- Implement hierarchical identification (project ‚Üí site ‚Üí context ‚Üí sample)
- Consider persistent identifier schemes (DOI, IGSN) for samples and datasets
- Maintain identifier stability even as interpretations change

### Accessibility Through Structured Export

Accessibility requires that data can be retrieved in formats suitable for diverse analytical tools:
- **Tabular export**: CSV for statistical analysis, preserving relationships through foreign keys
- **Spatial export**: GeoJSON for GIS integration, maintaining coordinate system metadata
- **Hierarchical export**: JSON for complex nested relationships (when available)
- **Semantic export**: RDF or JSON-LD for knowledge graph integration (future capability)

### Interoperability Through Controlled Vocabularies

Interoperability emerges from the systematic use of shared vocabularies and ontologies:
- Adopt disciplinary standards where they exist (Getty AAT, PeriodO, Darwin Core)
- Document local vocabularies with clear definitions and mapping to standards
- Implement hierarchical vocabularies that allow both specific and general classification
- Maintain vocabulary versioning to track semantic evolution

### Reusability Through Comprehensive Metadata

Reusability depends upon rich contextual information:
- **Collection context**: Project goals, methodologies, sampling strategies
- **Technical metadata**: Device types, software versions, coordinate systems
- **Quality indicators**: Confidence levels, validation status, known limitations
- **Rights and attribution**: Licenses, embargoes, citation requirements

## Practical Implementation Principles

### Principle 4: Automate System-Knowable Information

Any information the system can determine should never require manual entry. This principle reduces errors, accelerates recording, and ensures consistency across datasets.

**System Variables Available:**
- `{{_CREATED_BY}}` ‚Äì Current user (eliminates "Recorded by" fields)
- `{{_CREATED_TIME}}` ‚Äì Timestamp of record creation
- Current GPS location via Take GPS Point
- Sequential identifiers through Auto-incrementing fields
- Parent record context through inheritance

**Implementation Patterns:**
Replace manual entry fields with automated capture:
- ‚ùå Text field for "Recorder name" ‚Üí ‚úì System variable in HRID
- ‚ùå DateTime field for "Entry time" ‚Üí ‚úì {{_CREATED_TIME}} in template
- ‚ùå Manual context copying ‚Üí ‚úì Parent-child relationships with inheritance

### Principle 5: Design for Progressive Disclosure

Complex recording scenarios benefit from conditional logic that reveals detail progressively based on initial assessments. This approach maintains form simplicity whilst enabling comprehensive documentation when necessary.

**Effective Patterns:**
1. **Binary Gateway**: Checkbox controlling detailed field visibility
2. **Type-Specific Recording**: Radio button selection revealing relevant field sets
3. **Confidence Cascades**: Uncertainty triggering additional documentation requirements
4. **Other Specification**: Controlled vocabulary with conditional free text for exceptions

### Principle 6: Optimise for Device Constraints

Field selection must acknowledge the realities of mobile data collection ‚Äì small screens, touch interfaces, variable connectivity, and environmental challenges.

**Mobile-Optimised Selections:**
- Radio buttons over dropdowns for ‚â§7 options (larger touch targets)
- Checkbox for binary decisions (clear visual state)
- DateTime Now for timestamp capture (single tap)
- Take Photo over File Upload (integrated camera workflow)

**Desktop-Optimised Selections:**
- Multi-line text for extended narrative
- Hierarchical dropdowns for complex taxonomies
- Map drawing for precise spatial data
- File upload for diverse media types

### Principle 7: Maintain Human-Readable Identifiers

Whilst technically optional, human-readable identifiers (HRIDs) prove essential for practical data management. Without HRIDs, users confront opaque system identifiers (e.g., "rec-5f8a9b3c") that impede navigation, complicate analysis, and frustrate collaboration.

**HRID Design Patterns:**
- Archaeological: `{{site}}-{{trench}}-{{type}}-{{number}}`
- Ecological: `{{transect}}-{{point}}-{{date}}`
- Geological: `{{project}}-{{location}}-{{sample}}`

## Performance Considerations

### Cognitive Performance Factors

Before considering technical performance, we must acknowledge cognitive performance ‚Äì the speed and accuracy with which fieldworkers can complete recording tasks:
- **Recognition over recall**: Select from lists rather than remember codes
- **Progressive disclosure**: Show complex options only when needed
- **Consistent patterns**: Use the same interaction patterns throughout
- **Clear feedback**: Immediate validation with actionable error messages

### Technical Performance Constraints

Field devices impose constraints that influence design decisions:

**Battery Consumption:**
- GPS fields consume significant power (10‚Äì15% per hour of continuous use)
- Camera operations drain battery during processing
- Screen brightness for outdoor visibility increases consumption
- Recommendation: Design workflows that allow GPS/camera activation only when needed

**Processing Limitations:**
- Complex conditional logic may cause visible lag on older devices
- Large vocabularies (>100 items) slow dropdown rendering
- Multiple photo captures require processing time between shots
- Recommendation: Implement progressive loading for large datasets

**Network Constraints:**
- Assume intermittent or absent connectivity
- Design for offline-first operation with opportunistic synchronisation
- Implement differential sync to minimise data transfer
- Cache all essential resources locally

### Documented Performance Thresholds

**Relationship Field Limits:**
- <50 relationships: Optimal performance
- 50‚Äì100 relationships: Noticeable lag
- 100‚Äì200 relationships: Significant delays
- >200 relationships: Effectively unusable

**Form Complexity:**
- Keep forms under 30 fields for mobile usability
- Limit sections to 10 fields for cognitive load
- Use conditional logic to reduce visible field count
- Consider splitting complex forms into multiple linked forms

## Field Type Selection Decision Framework

### Textual Data Capture

We present a hierarchical decision process for text field selection:

1. **Can the value be generated automatically?**
   - YES ‚Üí Use Templated String field
   - NO ‚Üí Continue to question 2

2. **Does a controlled vocabulary exist or could one be developed?**
   - YES ‚Üí Use Select/RadioGroup/MultiSelect as appropriate
   - NO ‚Üí Continue to question 3

3. **Is the text predictably brief (<100 characters)?**
   - YES ‚Üí Use Single-line text
   - NO ‚Üí Use Multi-line text

4. **Does the field require specific validation?**
   - Email format ‚Üí Email field
   - Physical address ‚Üí Address field
   - Barcode scanning ‚Üí QR/Barcode scanner (mobile only)

### Numeric Data Capture

Selection depends upon precision requirements and constraints:

1. **Are there known valid ranges?**
   - YES ‚Üí Controlled Number field with min/max
   - NO ‚Üí Continue to question 2

2. **Is this a sequential identifier?**
   - YES ‚Üí Auto-incrementing field
   - NO ‚Üí Basic Number field

3. **Consider additional factors:**
   - Decimal precision requirements
   - Default values to accelerate entry
   - Sticky behaviour for environmental constants
   - Unit specification in field labels

### Temporal Data Capture

Temporal granularity determines field selection:
- **Date only** ‚Üí Date Picker (excavation date, sample date)
- **Date and time** ‚Üí DateTime Picker (precise events)
- **Current moment** ‚Üí DateTime Now (observation timestamp)
- **Month/year only** ‚Üí Month Picker (seasonal data)

### Choice Field Selection

The number of options and selection constraints guide choice:

**Single Selection:**
- 2 options ‚Üí Checkbox (if binary) or RadioGroup (if strings needed)
- 3‚Äì7 options ‚Üí RadioGroup (all visible)
- 8‚Äì20 options ‚Üí Select dropdown
- >20 options OR hierarchical ‚Üí AdvancedSelect

**Multiple Selection:**
- Always use MultiSelect
- Enable expandedChecklist for <10 options
- Configure exclusiveOptions for mutually incompatible choices

### Spatial Data Capture

Spatial requirements determine appropriate fields:
- **Single point** ‚Üí Take GPS Point
- **Boundaries/areas** ‚Üí Map Field (requires internet)
- **Both needed** ‚Üí Combine both field types
- **Manual coordinates** ‚Üí Text field with validation

## Discipline-Specific Design Patterns

### Archaeological Recording Patterns

Archaeological recording exhibits specific characteristics that inform design decisions:

**Stratigraphic Relationships:**
- Temporal sequences (earlier than, later than, contemporary with)
- Physical relationships (cuts, cut by, fills, filled by)
- Spatial relationships (above, below, abuts, bonded to)
- Implementation: RelatedRecordSelector with semantic qualification

**Contextual Inheritance:**
- Finds inherit context properties (period, phase, grid square)
- Samples inherit environmental conditions
- Photos inherit spatial coordinates
- Implementation: Automatic property cascade in parent-child relationships

**Interpretive Uncertainty:**
- Provisional identifications pending specialist analysis
- Alternative interpretations of ambiguous features
- Confidence levels for dating and classification
- Implementation: Annotation fields and uncertainty qualifiers

### Ecological Survey Patterns

Ecological recording presents different requirements:

**Transect-Based Observation:**
- Sequential observation points along predetermined routes
- Repeated measures at fixed intervals
- Distance-based or time-based sampling
- Implementation: Auto-incrementing with location capture

**Abundance Estimation:**
- Percentage cover for vegetation
- Count estimates for mobile species
- Categorical abundance (DAFOR scale)
- Implementation: Controlled number fields with standard ranges

**Environmental Conditions:**
- Weather conditions affecting observations
- Phenological state of observed species
- Habitat characteristics
- Implementation: Sticky fields for conditions that remain constant

### Geological Sampling Patterns

Geological fieldwork requires specific accommodations:

**Sample Hierarchies:**
- Outcrop ‚Üí Sample ‚Üí Subsample ‚Üí Analysis
- Maintaining provenance through processing
- Tracking splits and derivatives
- Implementation: Deep parent-child relationships with inheritance

**Orientation Data:**
- Strike and dip measurements
- Plunge and trend for linear features
- Multiple measurements per feature
- Implementation: Grouped number fields with validation

**Field Measurements:**
- Grain size, sorting, rounding
- Colour against standard charts
- Hardness, reaction to acid
- Implementation: Controlled vocabularies with standard scales

## Common Implementation Patterns

### The Measurement Pattern

Combine multiple fields for comprehensive measurement documentation:
1. Measurement type (RadioGroup/Select)
2. Numeric value (Controlled Number with range)
3. Units (incorporated in label or separate Select)
4. Uncertainty/precision (annotation or dedicated field)

### The Identification Pattern

Support confident and provisional identifications:
1. Quick identification (Select from common options)
2. Confidence level (RadioGroup: Certain/Probable/Possible)
3. Requires verification (Checkbox, conditional on confidence)
4. Detailed notes (Multi-line text, conditional on uncertainty)

### The Observation Pattern

Structure complex observations efficiently:
1. Observation type (RadioGroup for workflow branching)
2. Type-specific fields (conditional field groups)
3. Standard metadata (automatic via templates)
4. Media documentation (Take Photo with annotation)

## Advanced Capabilities and Their Implications

### Three-Tier Metadata Architecture

Fieldmark implements metadata at three levels, each serving distinct purposes:
1. **Record Metadata**: Who, when, where for every record (automatic capture)
2. **Field Metadata**: Annotation and uncertainty for individual observations
3. **Relationship Metadata**: Qualification of connections between entities

This architecture acknowledges that uncertainty and interpretation operate at multiple scales. A stratigraphic relationship might be certain whilst the dating of both contexts remains provisional.

### Semantic Relationship Qualification

Beyond simple parent-child relationships, Fieldmark enables semantic qualification of relationships:
- **Temporal**: "earlier than", "contemporary with", "redeposited from"
- **Physical**: "cuts", "bonds with", "same as"
- **Interpretive**: "possibly related to", "probably derived from"

This sophistication allows the recording system to capture interpretive reasoning, not just observational data.

### Automatic Versioning and Conflict Resolution

The append-only datastore provides complete version history without user intervention:
- Every change is preserved with timestamp and author
- Conflicting edits are resolved through merge strategies
- Previous interpretations remain accessible
- No data is ever truly deleted

This approach acknowledges that field interpretation is iterative and collaborative, with understanding emerging through discussion and revision.

## Vocabulary Development and Management

### Initial Development Process

1. **Literature Review**: Compile disciplinary standard terms
2. **Stakeholder Consultation**: Include local terminology
3. **Hierarchical Organisation**: Structure related terms appropriately
4. **Comprehensiveness vs Usability**: Balance completeness with efficiency

### Iterative Refinement Cycle

1. **Deploy Comprehensive Initial Vocabulary**
2. **Monitor Usage** (after 100+ records)
3. **Identify Rarely-Used Terms** (<5% selection rate)
4. **Relocate to "Other"** with annotation capability
5. **Document Changes** for data integration

### Vocabulary Versioning Strategy

- Maintain vocabulary change logs
- Preserve mappings between versions
- Plan for post-collection harmonisation
- Consider vocabulary expansion vs refinement

## Quality Assurance Through Field Design

### Validation Strategy

Implement validation at appropriate levels:
- **Field level**: Format, range, pattern matching
- **Section level**: Completeness checks
- **Form level**: Cross-field consistency (limited)
- **Workflow level**: Parent-child relationships

### Error Prevention Patterns

- Use controlled inputs over free text
- Provide clear helper text and examples
- Set appropriate default values
- Enable sticky fields for constants
- Mark only essential fields as required

### Data Integrity Measures

- Configure HRIDs for every form
- Establish clear parent-child hierarchies
- Document vocabulary semantics
- Plan for orphan management
- Design for export requirements

## Platform-Specific Adaptations

### Mobile-First Fields

When mobile devices predominate:
- Prefer touch-optimised inputs
- Minimise text entry requirements
- Leverage device sensors (GPS, camera)
- Design for offline resilience
- Account for screen size constraints

### Desktop-Enhanced Fields

When desktop entry is available:
- Enable complex text composition
- Support precise spatial drawing
- Facilitate bulk operations
- Leverage keyboard efficiency
- Utilise screen real estate

### Platform Parity Strategies

For mixed-device deployments:
- Identify platform-exclusive features
- Provide alternative workflows
- Document platform requirements
- Train users on platform differences
- Plan for data integration

## Recommendations for System Design

### For Notebook Designers

1. **Start with relationships**: Define entity relationships before designing forms
2. **Prioritise human-readable IDs**: Every entity needs meaningful identification
3. **Layer complexity**: Enable simple rapid capture with optional detail
4. **Test in conditions**: Evaluate designs outdoors, with gloves, in rain
5. **Document decisions**: Record why specific patterns were chosen

### For System Developers

1. **Optimise for common paths**: Make frequent operations exceptionally fast
2. **Fail gracefully**: Provide clear feedback when operations cannot complete
3. **Cache aggressively**: Assume network unreliability
4. **Respect battery**: Minimise GPS and camera activation
5. **Support correction**: Make it easy to fix mistakes

### For Project Managers

1. **Invest in vocabulary development**: Time spent on controlled vocabularies pays dividends
2. **Plan for data lifecycle**: Consider analysis and archiving from the start
3. **Train thoroughly**: Ensure teams understand both how and why
4. **Monitor usage**: Track which fields are used and which are skipped
5. **Iterate based on evidence**: Refine designs based on actual usage patterns

## Conclusion: Synthesis of Theory and Practice

Effective digital field recording emerges from the synthesis of theoretical understanding and practical experience. The principles articulated here ‚Äì minimising friction, preferring structure, designing for lifecycle ‚Äì provide the conceptual framework, whilst the specific patterns and recommendations translate these principles into actionable guidance.

The sophistication of Fieldmark's capabilities ‚Äì particularly its relationship management, automatic versioning, granular metadata, and intelligent synchronisation ‚Äì positions it as an exemplar of research-driven software development. These capabilities did not emerge from abstract software engineering but from sustained engagement with the realities of field research.

By understanding both the theoretical foundations and practical implications of design decisions, we can create digital recording systems that genuinely serve field research. The goal is not to digitise paper forms but to reimagine how digital tools can enhance our ability to observe, record, interpret, and share our understanding of the world.

The key to success lies not in dogmatic application of these principles, but in thoughtful adaptation to specific project contexts. Each design decision should consider the nature of the phenomena under study, the conditions of collection, the capabilities of available devices, and the ultimate analytical goals. When these factors align, digital field recording can simultaneously improve data quality and reduce fieldworker burden ‚Äì achieving the long-sought goal of making technology truly serve, rather than constrain, field research.

Through careful attention to these principles and patterns, we enable the creation of robust, usable, and analytically powerful field recording systems. The iterative refinement of field selections, informed by actual usage patterns and emerging research questions, ensures that digital recording systems evolve alongside research programmes.

---

*This guide reflects current Fieldmark capabilities and deployment experience through 2024‚Äì2025. As the platform evolves and deployment experience accumulates, these recommendations will require periodic revision. We encourage notebook designers to document their own patterns and contribute to the collective understanding of effective field selection strategies.*

<!-- concat:pattern:quick-start -->
# Fieldmark Quick Start Guide for Researchers

This guide helps researchers design effective digital data collection notebooks using Fieldmark's Designer web application. We focus on practical patterns and field-tested approaches to streamline your transition from paper to digital recording.

## Quick Reference: Selecting the Right Field Type

| What You Want to Record | Field Type to Use | Example | Key Considerations |
|------------------------|-------------------|---------|-------------------|
| **Text & Identifiers** ||||
| Short names or labels | Single-line text | "North wall", "Primary deposit" | Best for brief descriptors under 100 characters |
| Detailed descriptions | Multi-line text | Context descriptions, habitat observations | Accommodates paragraphs and extended notes |
| Email contacts | Email field | "pi@university.edu" | Validates email format automatically |
| Physical addresses | Address field | Museum locations, site addresses | Provides structured address components |
| Specimen barcodes | QR/Barcode scanner | "EXC2024-001" | Mobile devices only |
| Record IDs | Templated String | "SITE1-2024-045" | Combines multiple fields automatically |
| **Numbers & Measurements** ||||
| Simple counts | Number field | Sherd count: 47 | Basic numeric entry |
| Constrained measurements | Controlled number | pH (0‚Äì14): 7.2 | Enforces minimum/maximum values |
| Sequential identifiers | Auto-incrementing | Context: 001, 002, 003... | Generates unique sequential numbers |
| **Dates & Times** ||||
| Collection dates | Date picker | 15/03/2024 | Date without time component |
| Precise timestamps | DateTime picker | 15/03/2024 14:30 | Includes both date and time |
| Quick timestamps | DateTime Now | One-tap current time | Captures current moment instantly |
| Approximate dates | Month picker | March 2024 | When day precision unnecessary |
| **Choices & Categories** ||||
| Binary decisions | Checkbox | "Sample collected?" ‚úì | Simple yes/no |
| Single choice (few options) | Radio buttons | Preservation: Excellent/Good/Fair/Poor | Shows all options simultaneously |
| Single choice (many options) | Dropdown | Species from extensive list | Conserves screen space |
| Multiple selections | Multi-select | Materials present: Ceramic, Glass, Metal | Allows several choices |
| Hierarchical categories | Hierarchical dropdown | Kingdom ‚Üí Phylum ‚Üí Species | Nested taxonomies |
| **Location & Spatial** ||||
| Point coordinates | Take GPS point | Lat: -33.8688, Long: 151.2093 | Single coordinate capture |
| Boundaries and features | Map drawing | Polygons, lines, points | Visual feature creation on base maps |
| **Media & Files** ||||
| Field photographs | Take photo | Site images, specimen photos | Camera or gallery selection |
| Document attachments | File upload | PDFs, spreadsheets, reports | Accepts any file type |
| **Relationships** ||||
| Record connections | Related records | Links between contexts, samples to sites | Creates data relationships |
| **Instructions** ||||
| Field guidance | Rich text | "Remember to photograph before excavating" | Display-only formatted text |

## Essential Patterns for Field Research

### Creating Parent‚ÄìChild Hierarchies

Most field research involves hierarchical data structures. Fieldmark enables you to establish these relationships naturally through parent‚Äìchild connections.

**Archaeological Pattern:**
- Site ‚Üí Trenches ‚Üí Contexts ‚Üí Features ‚Üí Finds
- Each find belongs to a feature, each feature to a context

**Ecological Pattern:**
- Survey ‚Üí Transects ‚Üí Observation Points ‚Üí Specimens
- Specimens link directly to their collection point

**Geological Pattern:**
- Project ‚Üí Localities ‚Üí Outcrops ‚Üí Samples ‚Üí Analyses
- Maintains complete chain of custody

When designing hierarchies, consider that deeper structures require more navigation. We recommend limiting depth to three or four levels for optimal field usability.

### Human-Readable IDs

Whilst technically optional, we strongly recommend configuring a human-readable identifier (HRID) for every form using the Templated String field type. Without an HRID, the system defaults to cryptic record IDs (e.g., "rec-5f8a9b3c"), significantly complicating data management and export interpretation. The Templated String field combines multiple field values into meaningful identifiers that make your data immediately comprehensible.

**Effective ID Patterns:**
- Archaeological: Site-Trench-Context ‚Üí "MP24-T5-C023"
- Ecological: Transect-Point-Date ‚Üí "T1-P5-20240315"
- Geological: Project-Outcrop-Sample ‚Üí "GEO2024-OUT3-S045"

The Templated String field automatically updates as component values change, ensuring consistency across your dataset. Configure this as your form's primary identifier to maintain meaningful record lists and exports.

## Common Fieldwork Scenarios

### Scenario 1: Recording Stratigraphic Relationships
Create sophisticated relationship networks between contexts using the Related Records field. Configure vocabulary pairs like "cuts/is cut by" or "fills/is filled by" to capture bidirectional relationships. The system maintains both sides of the relationship automatically, ensuring data consistency.

### Scenario 2: Sample Collection with Photography
Design a two-level hierarchy with sampling locations as parents and individual samples as children. Include Take Photo fields at both levels ‚Äì the parent captures site context whilst children document individual specimens. Enable the device download toggle in media-heavy notebooks to manage storage efficiently across team devices.

### Scenario 3: Ecological Transect Surveys
Structure your notebook with transects as parent records containing start and end GPS points. Create observation points as child records, incorporating:
- Hierarchical dropdowns for species identification
- Controlled number fields for percentage cover (0‚Äì100)
- Multi-select fields for observed behaviours
- Sticky fields for observer names and conditions that remain constant

### Scenario 4: Rapid Assessment Protocols
Optimise for speed using DateTime Now fields for instant timestamps and Radio buttons for quick categorical assessments. Configure auto-incrementing fields for sequential point numbers. Enable sticky behaviour on team member and environmental condition fields to maintain values across multiple records, significantly accelerating data entry.

## Mobile vs Desktop: Platform Considerations

### Mobile-Specific Features
Several capabilities are exclusive to iOS and Android applications:
- **QR/Barcode scanning** requires device camera access
- **GPS accuracy** generally superior on mobile devices
- **Offline functionality** more robust in dedicated apps
- **Touch optimisation** for field conditions

### Desktop Advantages
The web interface excels for:
- **Complex data entry** with keyboard efficiency
- **Relationship management** with larger screen real estate
- **Data review and editing** with comprehensive overview
- **Notebook design** using the Designer interface

### Choosing Your Platform
Consider tablets as an optimal middle ground, combining portability with sufficient screen space for complex forms. Design your notebooks acknowledging that most field data collection occurs on mobile devices whilst review and analysis happen on desktop systems.

## Conditional Logic Patterns

Fieldmark's conditional logic enables dynamic forms that adapt to your data, showing relevant fields based on previous responses.

### Pattern 1: Progressive Detail
Create a checkbox asking "Record detailed measurements?" When selected, reveal comprehensive measurement fields. This approach keeps forms uncluttered whilst allowing detailed recording when necessary.

### Pattern 2: Specification Fields
Include "Other" in dropdown menus, triggering a text field for specification when selected. This pattern accommodates unexpected values whilst maintaining controlled vocabularies.

### Pattern 3: Type-Dependent Recording
Different feature types require different information. A "Feature type" radio button can reveal:
- Burial-specific fields for human remains protocols
- Sampling fields for hearth features
- Dimensional fields for postholes
This ensures collectors see only relevant fields for their current context.

## Best Practices for Effective Notebooks

### Design Principles
1. **Follow workflow sequences** ‚Äì Order fields matching natural recording patterns
2. **Group related information** ‚Äì Use sections to organise logical field clusters
3. **Minimise requirements** ‚Äì Mark only truly essential fields as required
4. **Provide clear guidance** ‚Äì Write helpful field descriptions assuming minimal training
5. **Test thoroughly** ‚Äì Validate notebooks on target devices before deployment

### Performance Optimisation
1. **Strategic field selection** ‚Äì Radio buttons render faster than dropdowns for small option sets
2. **Sticky field configuration** ‚Äì Maintain rarely-changing values across records
3. **Media management** ‚Äì Separate photo-intensive forms from data forms where feasible
4. **Field positioning** ‚Äì Place frequently-used fields at form tops
5. **Relationship design** ‚Äì Consider performance implications for extensively linked data

### Data Quality Strategies
1. **Consistent naming** ‚Äì Establish and document naming conventions
2. **Unit specification** ‚Äì Include units in field labels: "Depth (cm)"
3. **Validation rules** ‚Äì Configure appropriate constraints for numeric fields
4. **Export planning** ‚Äì Design with your analysis workflow in mind
5. **Documentation** ‚Äì Maintain a data dictionary alongside your notebook

## Troubleshooting Common Issues

### GPS Acquisition Problems
If GPS struggles to acquire position:
- Move to open sky away from buildings and tree cover
- Allow 30‚Äì60 seconds for satellite acquisition
- Verify device location services are enabled
- Consider using Map Field for manual position selection

### Photo Synchronisation Challenges
For notebooks with extensive photography:
- Configure image compression settings appropriately
- Enable device-specific download toggles
- Schedule synchronisation for WiFi availability
- Consider separate photo documentation forms

### Vocabulary Limitations
When controlled vocabularies prove restrictive:
- Add "Other" options with specification fields
- Consider multi-select for non-exclusive categories
- Document new terms for vocabulary updates
- Use hierarchical dropdowns for complex taxonomies

### Data Entry Errors
To minimise recording mistakes:
- Verify all required fields display clear indicators
- Check validation messages are helpful, not cryptic
- Test numeric constraints match expected ranges
- Ensure date formats align with user expectations
- Configure appropriate default values

### Synchronisation Issues
When data won't sync:
- Confirm network connectivity
- Check available device storage
- Verify user authentication
- Review any validation errors
- Consider data volume and connection speed

## Where to Get More Help

- **Field Type Reference**: Comprehensive documentation for all field types and configurations
- **Designer Documentation**: Detailed guidance on using the notebook Designer interface
- **Template Library**: Example notebooks for various research disciplines
- **Community Resources**: Forums for sharing patterns and troubleshooting with other researchers
- **Technical Support**: Contact details for system-specific assistance

Remember that successful digital field recording emerges from iterative refinement. Start with simple notebooks, gather user feedback, and progressively enhance your designs based on real-world experience.

---

*This guide reflects current Fieldmark capabilities. Features and interfaces may evolve with system updates.*

<!-- concat:pattern:summary-table -->
# Fieldmark Field Type Summary Reference Table

This comprehensive reference provides detailed specifications for all Fieldmark field types, supporting informed selection for digital data collection notebook design. We present technical capabilities, validation options, and platform-specific considerations for each field type within the Designer interface.

## Text and Identifier Fields

| Field Type | Purpose & Description | Typical Examples | Technical Specifications | Validation Capabilities | Platform Considerations |
|------------|----------------------|------------------|------------------------|------------------------|------------------------|
| **Single-line Text** | Brief textual entries where neither controlled vocabularies nor auto-generation are appropriate | "North wall", "Sandy matrix", "Excavator notes" | Character limit: ~255 practical maximum<br/>Input types: text, email, url<br/>Returns: String | Pattern matching via regex<br/>Length constraints<br/>Required field option | Universal compatibility<br/>Predictive text on mobile |
| **Multi-line Text** | Extended descriptive content requiring paragraph formatting | Context descriptions, interpretation notes, detailed observations | No practical character limit<br/>Adjustable row height<br/>Returns: String | Length validation<br/>Required field option<br/>No pattern matching | Touch keyboard challenges on mobile<br/>Consider voice-to-text |
| **Email** | Validated email address collection | "projectlead@university.edu", "lab@institution.org" | Standard email validation<br/>Returns: String | RFC 5322 compliant validation<br/>Required field option | Keyboard switches to email mode on mobile |
| **Address** | Structured physical address components | Site locations, institutional addresses, property details | Multiple sub-fields (street, city, state, postcode)<br/>Returns: Structured object | Component-level validation<br/>Postcode format checking | Auto-complete varies by platform |
| **Templated String** | Auto-generated identifiers combining multiple field values | "SITE1-2024-CTX045", "{{project}}-{{date}}-{{counter}}" | Mustache.js templating<br/>Supports conditionals<br/>Returns: String<br/>Read-only display | Not user-editable<br/>Updates dynamically | Essential for human-readable IDs<br/>No parent field access |
| **QR/Barcode Scanner** | Camera-based code capture for pre-printed labels | Specimen barcodes, equipment tags, location markers | Supports multiple formats (QR, Code128, etc.)<br/>Returns: String | Format validation possible<br/>Pattern matching | **Mobile applications only**<br/>Not available on web |

## Numeric Fields

| Field Type | Purpose & Description | Typical Examples | Technical Specifications | Validation Capabilities | Platform Considerations |
|------------|----------------------|------------------|------------------------|------------------------|------------------------|
| **Number Field** | Basic numeric entry without constraints | Artefact counts, simple measurements | Integer or decimal<br/>JavaScript number type<br/>Returns: Number | Type checking only<br/>No range validation | Period (.) required for decimals<br/>No locale formatting |
| **Controlled Number** | Numeric values with enforced boundaries | pH (0‚Äì14), percentage (0‚Äì100), depth (0‚Äì500cm) | Min/max enforcement<br/>Step increments<br/>Default values<br/>Returns: Number | Range validation<br/>Precision control<br/>Required field option | Supports sticky behaviour<br/>Spinner controls optional |
| **Auto-incrementing** | Sequential identifier generation | Context numbers (001, 002...), Sample IDs | Configurable padding<br/>Starting value<br/>Returns: String | Uniqueness guaranteed<br/>No user override | Cannot reset mid-project<br/>Team coordination critical |

## Date and Time Fields

| Field Type | Purpose & Description | Typical Examples | Technical Specifications | Validation Capabilities | Platform Considerations |
|------------|----------------------|------------------|------------------------|------------------------|------------------------|
| **Date Picker** | Calendar date selection without time | Excavation date, sample collection date | ISO 8601 format<br/>Returns: Date string | Min/max date ranges<br/>Required field option | Native date pickers on mobile<br/>Calendar widget on desktop |
| **DateTime Picker** | Combined date and time selection | Precise event timing, scheduled observations | ISO 8601 with time<br/>Returns: DateTime string | Date and time ranges<br/>Required field option | Platform-specific interfaces |
| **DateTime Now** | One-tap current timestamp capture | Record creation time, observation moment | Automatic capture<br/>User-triggered<br/>Returns: DateTime string | Always valid<br/>Can be required | Device clock dependency<br/>Timezone considerations |
| **Month Picker** | Year and month selection only | Seasonal data, approximate dates | YYYY-MM format<br/>Returns: String | Year range limits<br/>Required field option | Simplified interface<br/>No day selection |

## Selection Fields

| Field Type | Purpose & Description | Typical Examples | Technical Specifications | Validation Capabilities | Platform Considerations |
|------------|----------------------|------------------|------------------------|------------------------|------------------------|
| **Checkbox** | Binary true/false decisions | "Sample collected?", "Photography complete?" | Returns: Boolean<br/>Default: false | Required completion<br/>Can control logic | Large touch target on mobile |
| **Radio Buttons** | Single selection from 2‚Äì7 visible options | Preservation state, weather conditions | All options visible<br/>Returns: String value | Required selection<br/>Option validation | Excellent mobile usability<br/>Space consuming |
| **Dropdown (Select)** | Single selection from many options | Species list (50+ items), material types | Conserves screen space<br/>Returns: String value | Required selection<br/>Dependent on vocabulary | Scrolling challenges on mobile |
| **Multi-select** | Multiple simultaneous selections | Construction materials, observed behaviours | Checkbox list<br/>Returns: Array of strings | Min/max selections<br/>Required field option | Touch selection challenging<br/>Consider chip display |
| **Hierarchical Dropdown** | Nested categorical selection | Taxonomies, period ‚Üí phase ‚Üí subphase | Tree navigation<br/>Returns: Full path or leaf | Depth validation<br/>Required at any level | Complex navigation on mobile<br/>Consider search function |

## Spatial Fields

| Field Type | Purpose & Description | Typical Examples | Technical Specifications | Validation Capabilities | Platform Considerations |
|------------|----------------------|------------------|------------------------|------------------------|------------------------|
| **Take GPS Point** | Single coordinate capture | Find spots, sample locations, photo positions | Returns: GeoJSON point<br/>Includes metadata (accuracy, altitude) | Accuracy thresholds<br/>Required field option | Mobile GPS superior<br/>Browser geolocation limited |
| **Map Drawing** | Visual feature creation on base maps | Site boundaries, excavation areas, transects | Points, lines, polygons<br/>Returns: GeoJSON<br/>Multiple features | Geometry validation<br/>Area/length constraints | **Requires internet for base maps**<br/>Touch precision varies |

## Media Fields

| Field Type | Purpose & Description | Typical Examples | Technical Specifications | Validation Capabilities | Platform Considerations |
|------------|----------------------|------------------|------------------------|------------------------|------------------------|
| **Take Photo** | Camera capture or gallery selection | Context photos, artefact images, working shots | JPEG/PNG<br/>EXIF preserved<br/>Returns: File reference | File size limits<br/>Required field option | Compression settings<br/>Storage considerations |
| **File Upload** | Arbitrary file attachment | PDFs, spreadsheets, audio, video | Any file type<br/>No size limits (practical)<br/>Returns: File reference | Type restrictions possible<br/>Required field option | Upload time considerations<br/>Bandwidth dependent |

## Relationship Fields

| Field Type | Purpose & Description | Typical Examples | Technical Specifications | Validation Capabilities | Platform Considerations |
|------------|----------------------|------------------|------------------------|------------------------|------------------------|
| **Related Records** | Inter-record connections | Stratigraphic relationships, sample ‚Üí context links | Parent-child or peer<br/>Vocabulary pairs<br/>Returns: Relationship array | Required relationships<br/>Cardinality limits | Performance degrades >50 relationships<br/>Mobile interface limited |

## Display Fields

| Field Type | Purpose & Description | Typical Examples | Technical Specifications | Validation Capabilities | Platform Considerations |
|------------|----------------------|------------------|------------------------|------------------------|------------------------|
| **Rich Text** | Formatted instructional content | Warnings, procedures, contextual help | Markdown support<br/>Display only<br/>No data storage | Not applicable | Responsive rendering<br/>Image embedding supported |

## Critical Implementation Considerations

### Human-Readable Identifiers (HRIDs)
Whilst technically optional, we strongly recommend implementing HRIDs using Templated String fields for every form. Without HRIDs, the system defaults to opaque UUIDs (e.g., "rec-5f8a9b3c"), substantially complicating data management, export interpretation, and team communication. Configure the `hridField` property in your viewset to specify which Templated String field serves as the identifier.

### Conditional Logic Architecture
Fields capable of controlling logic (marked in specifications) can trigger visibility conditions through standardised operators (equal, not-equal, greater-than, less-than). Complex conditions utilise AND/OR combinations. Note that controller fields require the `logic_select` property or inclusion in `conditional_sources` for optimal performance.

### Platform-Specific Limitations
Critical platform disparities require careful consideration:
- QR/Barcode scanning functions exclusively on mobile applications
- Map fields require internet connectivity for initial tile loading
- GPS accuracy varies significantly between mobile devices and browsers
- Touch interfaces present challenges for precise selection and text entry

### Performance Boundaries
Documented performance thresholds inform design decisions:
- Relationship fields: Noticeable degradation beyond 50 relationships, unusable beyond 200
- Long option lists: Consider hierarchical organisation beyond 20 items
- Media synchronisation: Device-specific download toggles essential for photo-intensive notebooks
- Complex conditional logic: Multiple controller fields may impact form responsiveness

### Validation Limitations
Current validation architecture exhibits specific constraints:
- No cross-field validation (cannot compare Field A to Field B)
- No custom validation functions for project-specific rules
- No mathematical operations between fields
- No prevention of logical contradictions in relationships
- Validation occurs client-side with limited server verification

### Export Considerations
Each entity type exports as a separate CSV file with relationships preserved through identifier columns. The export format maintains relationship semantics (e.g., "cuts/CTX-042;fills/CTX-043") but requires manual reconstruction for hierarchical analysis. Design vocabularies and identifiers with post-processing requirements in mind.

---

*This reference table reflects Fieldmark capabilities as documented in 2024‚Äì2025. Platform updates may introduce new features or modify existing behaviour. Consult current documentation for production deployments.*

<!-- concat:pattern:validation -->
# Validation System - Comprehensive Third Draft Documentation
## Fieldmark/FAIMS3 Technical Reference

### Document Classification
- **Component Type**: Core System Architecture
- **Audience Tags**: {designer} {developer} {claude-code}
- **Depth Levels**: {essential} {important} {comprehensive}
- **Version**: 1.0.0
- **Last Technical Verification**: August 2025
- **Key Discovery**: Hidden field validation may not actually block submission due to filterErrors

---

## 1. Executive Summary {essential} {designer}

### Current State
The Fieldmark validation system provides basic data quality controls through required fields and value constraints. Validation executes synchronously on every field change, with schemas rebuilt on every render. The system lacks "soft validation" (warnings that can be overridden), which is the most requested feature from field teams.

### Critical Limitations
1. **No soft validation** - All validation is "hard" (blocking)
2. **14 of 19 field types don't display error messages** - Only show red highlighting
3. **No conditional validation** - Cannot make fields conditionally required
4. **No cross-field validation** - Cannot validate relationships between fields
5. **Performance issues** - All fields validate on every change, even hidden ones

### Key Insights from Investigation
- **Hidden required fields may not actually block submission** - filterErrors removes them from formProps.errors
- **Schema rebuilding is inefficient but functional** - Happens on every render, not just mount
- **Error display fixes are simple** - 2-3 hours to fix all 14 broken fields
- **filterErrors is very recent** - Added January 2025, only 1-2 months old

---

## 2. How Validation Actually Works {comprehensive} {developer}

### Architecture Overview

```mermaid
graph TD
    A[User Input] --> B[Formik onChange]
    B --> C[Schema Rebuilt<br/>Every Render]
    C --> D[validateSync<br/>ALL Fields]
    D --> E[All Errors Generated]
    E --> F[filterErrors<br/>Remove Hidden]
    F --> G[form.errors<br/>Visible Only]
    G --> H{Error Display?}
    H -->|5 Fields| I[Shows Error Text]
    H -->|14 Fields| J[Red Highlight Only]
    G --> K[publishButtonBehaviour]
    K --> L[Enable/Disable Save]
```

### Core Components and Timing

#### 1. Schema Building (Every Render!)
```typescript
// Location: /app/src/gui/components/record/form.tsx:1585-1588
// Rebuilds on EVERY render, not just mount
render() {
  const validationSchema = getValidationSchemaForViewset(
    this.props.ui_specification,
    viewsetName
  );
}
```
**Performance Impact**: Schema rebuilds unnecessarily on every state change, section navigation, or re-render.

#### 2. Validation Execution (Synchronous, All Fields)
```typescript
// Location: form.tsx:1623
validationSchema.validateSync(values, {abortEarly: false});
```
- Validates ALL fields including hidden ones
- No debouncing or throttling
- Blocks UI thread
- Runs on: mount, every change, blur, section navigation

#### 3. Error Filtering (Recent Addition)
```typescript
// Added January 2025 - only 1-2 months old!
filterErrors({errors, values, viewsetName}) {
  const visibleFields = currentlyVisibleFields({...});
  // Returns ONLY errors for visible fields
  return filteredErrors;
}
```
**Key Discovery**: This SHOULD prevent hidden required fields from blocking submission, but the feature is very new and may have bugs.

### Performance Characteristics

| Fields | Validation Time | UI Impact | Recommendation |
|--------|----------------|-----------|----------------|
| 10 | ~5-10ms | Imperceptible | No issues |
| 50 | ~25-50ms | Slight lag | Consider optimization |
| 100 | ~50-100ms | Noticeable lag | Split form or add debouncing |
| 200+ | ~200ms+ | Severe lag | Requires architectural changes |

**Hidden fields impact**: ALL fields validate even when hidden, then errors filtered after - doubles the work!

---

## 3. Critical Warnings and Anti-Patterns {essential} {designer} {claude-code}

### ‚ö†Ô∏è Warning 1: Hidden Required Fields

**THE ISSUE**: Required fields hidden by conditions still validate, though filterErrors should remove their errors.

**STATUS**: Unclear - filterErrors (added Jan 2025) should fix this, but users report it still blocks submission.

**NEVER DO THIS** (until bug confirmed fixed):
```json
{
  "other-details": {
    "component-parameters": {
      "required": true  // DON'T combine with conditions!
    },
    "condition": {
      "operator": "equal",
      "field": "category",
      "value": "other"
    }
  }
}
```

**WORKAROUND**: Use duplicate fields pattern:
```json
{
  "email_when_not_required": {
    "component-parameters": {
      "label": "Email (Optional)",
      "required": false
    },
    "condition": {
      "operator": "not-equal",
      "field": "contact_method",
      "value": "email"
    }
  },
  "email_when_required": {
    "component-parameters": {
      "label": "Email (Required)",
      "required": true
    },
    "condition": {
      "operator": "equal",
      "field": "contact_method",
      "value": "email"
    }
  }
}
```

### ‚ö†Ô∏è Warning 2: Most Fields Don't Show Error Messages

**14 of 19 field types** validate but display NO error text:

| Broken Fields (No Error Text) | Working Fields (Show Errors) |
|-------------------------------|------------------------------|
| RadioGroup | TextField |
| Select | NumberField |
| MultiSelect | DateTimeNow |
| AdvancedSelect | Checkbox |
| TakePhoto | InputFieldBase |
| TakePoint | |
| RelatedRecordSelector | |
| BasicAutoIncrementer | |
| TemplatedStringField | |
| Address | |
| FileUploader | |
| QRCodeFormField | |
| MapFormField | |
| ActionButton | |

**Impact**: Users see red highlighting but no explanation of what's wrong.

**Fix Effort**: 2-3 hours total (15 minutes per field to add FormHelperText).

### ‚ö†Ô∏è Warning 3: Type Mismatches Cause Confusion

| Field | Declared Type | Actual Behavior | Common Issue |
|-------|---------------|-----------------|--------------|
| BasicAutoIncrementer | String | Padded strings ("0001") | "0150" < "0099" is TRUE |
| NumberField | Number | Empty ‚Üí null (not 0) | Null vs zero confusion |
| ControlledNumber | Integer | Accepts decimals | Type not enforced |
| Checkbox | Boolean | Validation expects string | Error message type mismatch |
| MultiSelect | Array | Empty array vs null | Inconsistent handling |

---

## 4. Validation Rules Reference {important} {designer}

### Through Designer Interface

#### Required Fields (All Field Types)
- **Designer**: Check "Required" checkbox
- **Effect**: Field must have value before submission
- **JSON Generated**:
```json
"validationSchema": [
  ["yup.string"],  // or appropriate type
  ["yup.required", "This field is required"]
]
```

#### Number Ranges (ControlledNumber Only)
- **Designer**: Set min/max values
- **Effect**: Number must be within range
- **JSON Generated**:
```json
"validationSchema": [
  ["yup.number"],
  ["yup.min", 0, "Must be positive"],
  ["yup.max", 100, "Maximum 100"]
]
```

### Through JSON Editing (Advanced)

#### String Validation
```json
"validationSchema": [
  ["yup.string"],
  ["yup.required", "Required message"],
  ["yup.min", 10, "Minimum 10 characters"],
  ["yup.max", 100, "Maximum 100 characters"],
  ["yup.matches", "^[A-Z]", "Must start with capital"],
  ["yup.email", "Must be valid email"]
]
```

#### Array Validation (Relationships, Photos)
```json
"validationSchema": [
  ["yup.array"],
  ["yup.min", 1, "At least one required"],
  ["yup.max", 5, "Maximum 5 allowed"],
  ["yup.required", "This field is required"]
]
```

#### Object Validation (GPS, Complex Fields)
```json
"validationSchema": [
  ["yup.object"],
  ["yup.required", "Location required"],
  ["yup.nullable"]  // Allows null values
]
```

### What's NOT Possible

‚ùå **Conditional validation**: `yup.when()` not supported
‚ùå **Cross-field validation**: Cannot reference other fields
‚ùå **Custom validators**: `yup.test()` not available
‚ùå **Async validation**: No server-side checks
‚ùå **Soft validation**: No warnings, only errors
‚ùå **Dynamic messages**: Cannot change based on value

---

## 5. Field-Specific Validation Behavior {comprehensive} {developer}

### Fields with Working Validation Display

#### TextField Family (TextField, EmailField, MultilineTextField)
```typescript
// Location: /app/src/gui/fields/FAIMSTextField.tsx
// Uses fieldToTextField from formik-mui
error={Boolean(hasError)}
helperText={hasError ? String(props.form.errors[props.field.name]) : ''}
```
- ‚úÖ Shows error messages below field
- ‚úÖ Red border when invalid
- ‚úÖ Touch state properly managed
- ‚úÖ Blur event sets touched

#### NumberField / ControlledNumber
```typescript
// Location: /app/src/gui/fields/NumberField.tsx:65
onBlur={() => form.setFieldTouched(field.name, true)}
```
- ‚úÖ Custom error for invalid numbers
- ‚úÖ Range validation messages
- ‚úÖ Handles null vs zero properly
- ‚ö†Ô∏è Empty string becomes null, not 0

#### Checkbox
```typescript
// Location: /app/src/gui/fields/checkbox.tsx:81-87
<FormHelperText>
  {error ? (form.errors[field.name] as string) : ''}
</FormHelperText>
```
- ‚úÖ Reference implementation for error display
- ‚úÖ Boolean validation works
- ‚ö†Ô∏è Error expects string type

### Fields with Broken Validation Display

#### RadioGroup
```typescript
// Location: /app/src/gui/fields/radio.tsx
// HAS: error={Boolean(form.errors?.[field.name])}
// MISSING: FormHelperText component
```
**Fix Required**:
```typescript
import { FormHelperText } from '@mui/material';
// After line 167
{form.errors?.[field.name] && form.touched?.[field.name] && (
  <FormHelperText error>
    {String(form.errors[field.name])}
  </FormHelperText>
)}
```

#### Select / MultiSelect
- ‚ùå No error prop at all
- ‚ùå No FormHelperText
- ‚ùå No touched state handling
- ‚ùå Users see nothing when validation fails

### Shared Component Solution

```typescript
// Proposed: /app/src/gui/components/FieldError.tsx
export const FieldError = ({ form, field }) => (
  form.errors?.[field.name] && form.touched?.[field.name] ? (
    <FormHelperText error>
      {String(form.errors[field.name])}
    </FormHelperText>
  ) : null
);

// Usage in any field:
<FieldError form={form} field={field} />
```

---

## 6. Validation Timing and State Management {important} {developer}

### Validation Execution Points

| Trigger | Function Called | When | Performance Impact |
|---------|----------------|------|-------------------|
| Form Mount | validateOnMount | Initial render | High - all fields |
| Field Change | validateOnChange | Every keystroke | High - no debouncing |
| Field Blur | validateOnBlur | Focus lost | Low - single field |
| Section Change | validateForm() | Navigation | Medium - all fields |
| Save Attempt | validateForm() | Submit click | High - all fields |

### Touch State Management

**Working Fields** (proper blur handling):
```typescript
onBlur={() => form.setFieldTouched(field.name, true)}
```

**Broken Fields** (no touch management):
- RadioGroup - No blur concept for radio buttons
- Select - Missing onBlur handler
- MultiSelect - No blur implementation
- TakePhoto - No blur equivalent

**Impact**: Errors show immediately instead of after interaction.

### Section Validation State

```typescript
// Location: recordStepper.tsx:106-116
const hasErrors = (sectionId: string) => {
  return (
    visitedSteps.has(sectionId) &&
    ui_specification.views[sectionId]?.fields.some(
      field => formErrors && formErrors[field]
    )
  );
};
```

- Section can be "visited" but still have errors
- Red "!" badge shows for sections with errors
- Only shows for visited sections
- Hidden field errors excluded (via filterErrors)

---

## 7. Save Button Behavior (publishButtonBehaviour) {important} {designer}

### Configuration Options

| Mode | Behavior | When to Use | Issues |
|------|----------|-------------|--------|
| `"always"` | Save always enabled | Quick data entry | No validation enforcement |
| `"visited"` | Enabled after all sections viewed | Ensures complete review | Doesn't check validity |
| `"noErrors"` | Enabled only when valid | Data quality enforcement | Hidden required fields may block |

### Implementation Details

```typescript
// Location: form.tsx:1668-1677
const hasErrors = Object.keys(formProps.errors).length > 0;
const showPublishButton =
  publishButtonBehaviour === 'always' ||
  (publishButtonBehaviour === 'visited' && allSectionsVisited) ||
  (publishButtonBehaviour === 'noErrors' && !hasErrors);
```

**Key Insight**: Uses filtered errors (formProps.errors), so hidden fields SHOULD NOT block saving.

---

## 8. Performance Optimization Strategies {comprehensive} {developer}

### Current Performance Issues

1. **Schema rebuilt on EVERY render** (not just mount)
2. **ALL fields validated** including hidden ones
3. **No debouncing** on validation
4. **Synchronous validation** blocks UI thread
5. **Errors calculated then filtered** (double work)

### Recommended Optimizations

#### Quick Win: Validate Only Visible Fields
```typescript
// In validate function
const visibleFields = currentlyVisibleFields({...});
const visibleValues = Object.keys(values)
  .filter(key => visibleFields.includes(key))
  .reduce((obj, key) => ({ ...obj, [key]: values[key] }), {});
validationSchema.validateSync(visibleValues, {abortEarly: false});
```

#### Add Debouncing
```typescript
import { debounce } from 'lodash';
const debouncedValidate = debounce(validate, 300);
```

#### Cache Schemas by Visibility Pattern
```typescript
const schemaCache = new Map();
function getCachedSchema(visibleFields) {
  const key = visibleFields.sort().join(',');
  if (!schemaCache.has(key)) {
    schemaCache.set(key, buildSchema(visibleFields));
  }
  return schemaCache.get(key);
}
```

#### Async Validation for Large Forms
```typescript
validate={async (values) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      const errors = validateSync(values);
      resolve(errors);
    }, 0);
  });
}}
```

---

## 9. Troubleshooting Guide {essential} {designer}

### Common Issues and Solutions

#### "Form won't save but no errors visible"

**Diagnosis Steps**:
1. Open browser console
2. Type: `console.log(formProps.errors)`
3. Check for errors on hidden fields
4. Look for RadioGroup/Select fields (no error display)

**Solutions**:
- Remove required from conditional fields
- Check all RadioGroup/Select fields manually
- Temporarily set publishButtonBehaviour to "always"

#### "Validation is slow/laggy"

**Diagnosis**:
```javascript
// Add to console:
const start = performance.now();
formProps.validateForm();
console.log(`Validation took ${performance.now() - start}ms`);
```

**Solutions**:
- Reduce fields per section (<50)
- Avoid complex regex patterns
- Split into multiple forms
- Remove unnecessary validation rules

#### "Numbers comparing incorrectly"

**Common Issues**:
- BasicAutoIncrementer: "0150" < "0099" (string comparison)
- Empty NumberField: null not 0
- ControlledNumber: Accepts decimals despite Integer type

**Solutions**:
- Use numeric IDs without padding
- Handle null explicitly in conditions
- Use Number validation not Integer

### Browser Console Debugging

```javascript
// Check all validation errors
console.log(formProps.errors);

// Check touched fields
console.log(formProps.touched);

// Check all field values
console.log(formProps.values);

// Test specific field visibility
const field = document.querySelector('[name="field-name"]');
console.log(field ? 'Visible' : 'Hidden');

// Force validation
formProps.validateForm().then(errors => console.log(errors));

// Check which fields are causing issues
Object.entries(formProps.errors).forEach(([field, error]) => {
  console.log(`${field}: ${error}`);
});
```

---

## 10. Future Requirements and Roadmap {comprehensive} {designer}

### Priority 1: Soft Validation (Most Requested)

**User Need**: Warnings that can be acknowledged and overridden.

**Proposed Implementation**:
```json
{
  "validationSchema": [
    ["yup.string"],
    ["yup.warning", "matches", "^[A-Z]", "Should start with capital letter"],
    ["yup.error", "required", "This field is required"]
  ]
}
```

**Requirements**:
- Field-level soft/hard configuration
- Visual distinction (yellow vs red)
- Override reason capture
- Notebook-wide default setting

### Priority 2: Fix Error Display (Quick Win)

**Effort**: 2-3 hours total

**Approach**:
1. Create shared FieldError component
2. Add to all 14 broken fields
3. Ensure touch state handling

### Priority 3: Conditional Validation

**Use Cases**:
- "If field X = value, then field Y required"
- "Required when visible" option
- Cross-field validation within form

**Proposed Syntax**:
```json
"validationSchema": [
  ["yup.string"],
  ["yup.when", "contact_method", {
    "is": "email",
    "then": ["yup.required", "Email required when email contact selected"]
  }]
]
```

### Priority 4: Server-Side Post-Sync Validation

**Requirements**:
- Automatic execution after sync
- Data quality review interface
- Bidirectional sync for field follow-up
- Designer configuration for rules
- Cross-record validation support

**Implementation Needs**:
- Backend validation engine
- Quality dashboard UI
- Rule builder in Designer
- Field app integration

### Priority 5: GPS Accuracy Validation

**Requirements**:
- Dual thresholds (hard/soft)
- Field-level configuration
- Range: 10m to sub-cm
- Override with annotation

**Proposed Configuration**:
```json
{
  "gps_accuracy": {
    "hard_threshold": 5,  // Blocks if accuracy > 5m
    "soft_threshold": 2,  // Warns if accuracy > 2m
    "unit": "meters"
  }
}
```

### Priority 6: Cross-Field Validation

**Common Patterns**:
- Date ranges (end after start)
- Numeric relationships
- Logical constraints
- Parent-child dependencies

### Priority 7: Performance Optimizations

1. Debounced validation (300ms)
2. Validate only visible fields
3. Schema caching
4. Async validation option
5. Partial validation on field change

### Priority 8: Breaking Changes Management

**Designer Warnings**:
- Detect validation changes that break existing data
- Migration tool for validation rules
- "Pre-validation" flag for old data
- Git integration for audit trail

### Priority 9: Navigation and Recovery

**Features**:
- Jump-to-error navigation
- Validation issues panel
- Section blocking (hard mode)
- Section warnings (soft mode)

---

## 11. Implementation Priorities {essential} {developer}

### Immediate Fixes (This Week)

1. **Add FormHelperText to all fields** (2-3 hours)
   - Create shared component
   - Apply to 14 broken fields
   - Test error display

2. **Document hidden field behavior** (1 hour)
   - Confirm if filterErrors prevents blocking
   - Update Designer warnings
   - Create clear guidelines

3. **Add performance logging** (1 hour)
   - Measure actual validation times
   - Identify bottlenecks
   - Set performance thresholds

### Short Term (This Month)

1. **Implement debouncing** (4 hours)
   - Add 300ms delay to onChange
   - Prevent validation storms
   - Improve responsiveness

2. **Validate only visible fields** (4 hours)
   - Modify validation pipeline
   - Test with complex conditions
   - Verify performance gains

3. **Create validation test suite** (8 hours)
   - Test all field types
   - Cover edge cases
   - Performance benchmarks

### Medium Term (This Quarter)

1. **Soft validation system** (40 hours)
   - Extend Yup schema format
   - Add warning UI components
   - Override reason capture
   - Designer integration

2. **Conditional validation** (20 hours)
   - Implement yup.when() support
   - Dynamic schema building
   - Cross-field dependencies

3. **Designer validation builder** (40 hours)
   - Visual rule creation
   - Validation preview
   - Test mode

### Long Term (This Year)

1. **Server-side validation** (80+ hours)
   - Backend engine
   - Quality dashboard
   - Sync integration
   - Rule configuration

2. **Performance overhaul** (40 hours)
   - Async validation
   - Worker threads
   - Incremental validation
   - Smart caching

---

## 12. Best Practices and Guidelines {essential} {designer}

### For Notebook Designers

#### DO:
‚úÖ Keep validation simple - use conditions for complex logic
‚úÖ Test thoroughly in deployed notebooks (not Designer preview)
‚úÖ Provide clear, actionable error messages
‚úÖ Document validation rules in helperText
‚úÖ Consider mobile users with limited connectivity
‚úÖ Use "always" publishButtonBehaviour during development

#### DON'T:
‚ùå Use required on conditional fields (until bug fixed)
‚ùå Rely on validation alone for data quality
‚ùå Create deeply nested validation logic
‚ùå Assume error messages display (14 fields don't!)
‚ùå Use different types in conditions vs validation
‚ùå Trust Designer preview for validation testing

#### REMEMBER:
- Validation runs on EVERY change (performance matters)
- Hidden fields still validate (may cause issues)
- Most fields don't show error text (only red color)
- Soft validation coming but not yet available
- Cross-field validation not currently possible
- Test with real data in real conditions

### For Developers

#### Code Patterns:
```typescript
// Always include FormHelperText for errors
<FormHelperText error={hasError}>
  {hasError ? String(form.errors[field.name]) : ''}
</FormHelperText>

// Always handle touch state
onBlur={() => form.setFieldTouched(field.name, true)}

// Check for null vs undefined vs empty
const value = field.value ?? '';  // Handles null/undefined
const isEmpty = value === '' || value === null;

// Type-safe validation
if (typeof value === 'number' && !isNaN(value)) {
  // Numeric validation
}
```

#### Performance Patterns:
```typescript
// Debounce expensive operations
const debouncedValidate = useMemo(
  () => debounce(validate, 300),
  [validate]
);

// Memoize computed values
const visibleFields = useMemo(
  () => currentlyVisibleFields({...}),
  [conditions, values]
);

// Early return for unchanged values
if (prevValues === values) return prevErrors;
```

### For Field Teams

#### Data Quality Tips:
- Save frequently (every 5-10 minutes)
- Review red indicators before saving
- Check hidden sections for issues
- Document override reasons
- Verify GPS accuracy manually
- Test forms before fieldwork

#### Troubleshooting in Field:
1. Can't save? Check RadioGroups and Selects
2. Slow form? Reduce fields per section
3. Missing errors? Check browser console
4. GPS issues? Check accuracy threshold
5. Sync problems? Save as draft first

---

## 13. Technical Reference {comprehensive} {claude-code}

### Validation Pipeline

```typescript
// Complete validation flow with file locations

// 1. Schema Building
// Location: /app/src/gui/components/validation.ts:58-77
export function getValidationSchemaForViewset(
  ui_specification: ProjectUIModel,
  viewset_name: string
) {
  const fields = getFieldsForViewSet(ui_specification, viewset_name);
  const validationSchema = Object();
  fieldNames.forEach(fieldName => {
    validationSchema[fieldName] = expand_validation_schema(
      ui_specification,
      fieldName,
      fields[fieldName]['validationSchema']
    );
  });
  return transformAll([['yup.object'], ['yup.shape', validationSchema]]);
}

// 2. Validation Execution
// Location: /app/src/gui/components/record/form.tsx:1618-1657
validate={(values) => {
  try {
    validationSchema.validateSync(values, {abortEarly: false});
    return {};
  } catch (err) {
    const errors = err.inner.reduce((acc, error) => {
      if (error.path) acc[error.path] = error.message;
      return acc;
    }, {});
    return filterErrors({errors, values, viewsetName});
  }
}}

// 3. Error Filtering
// Location: /app/src/gui/components/record/form.tsx:1547-1575
filterErrors({errors, values, viewsetName}) {
  const visibleFields = currentlyVisibleFields({
    uiSpec: ui_specification,
    values: values,
    viewsetId: viewsetName
  });
  
  return Object.keys(errors)
    .filter(field => visibleFields.includes(field))
    .reduce((filtered, field) => {
      filtered[field] = errors[field];
      return filtered;
    }, {});
}

// 4. Save Button Logic
// Location: /app/src/gui/components/record/form.tsx:1668-1677
const hasErrors = Object.keys(formProps.errors).length > 0;
const showPublishButton =
  publishButtonBehaviour === 'always' ||
  (publishButtonBehaviour === 'visited' && allSectionsVisited) ||
  (publishButtonBehaviour === 'noErrors' && !hasErrors);
```

### File Structure

```
/app/src/gui/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ validation.ts           # Schema building
‚îÇ   ‚îú‚îÄ‚îÄ record/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ form.tsx            # Main validation logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ recordStepper.tsx   # Section validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ view.tsx            # Section rendering
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ branchingLogic.tsx  # Conditional visibility
‚îÇ   ‚îî‚îÄ‚îÄ ui/
‚îÇ       ‚îî‚îÄ‚îÄ PermissionAlerts.tsx # Platform-specific messages
‚îú‚îÄ‚îÄ fields/                      # Field components
‚îÇ   ‚îú‚îÄ‚îÄ InputFieldBase.tsx      ‚úÖ Working validation
‚îÇ   ‚îú‚îÄ‚îÄ NumberField.tsx         ‚úÖ Working validation
‚îÇ   ‚îú‚îÄ‚îÄ FAIMSTextField.tsx      ‚úÖ Working validation
‚îÇ   ‚îú‚îÄ‚îÄ DateTimeNow.tsx         ‚úÖ Working validation
‚îÇ   ‚îú‚îÄ‚îÄ checkbox.tsx            ‚úÖ Working validation
‚îÇ   ‚îú‚îÄ‚îÄ radio.tsx               ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ select.tsx              ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ multiselect.tsx         ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ selectadvanced.tsx      ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ RelatedRecordSelector.tsx ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ TakePhoto.tsx           ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ TakePoint.tsx           ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ BasicAutoIncrementer.tsx ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ TemplatedStringField.tsx ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ Address.tsx             ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ FileUploader.tsx        ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ QRCodeFormField.tsx     ‚ùå No error display
‚îÇ   ‚îú‚îÄ‚îÄ MapFormField.tsx        ‚ùå No error display
‚îÇ   ‚îî‚îÄ‚îÄ ActionButton.tsx        ‚ùå No validation
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ formUtilities.ts        # Form helpers
```

### Yup Schema Format (via yup-ast)

```typescript
// Package: @demvsystems/yup-ast v1.2.2
// Transforms arrays to Yup schemas

// Array format:
[
  ["yup.string"],                           // yup.string()
  ["yup.required", "Message"],              // .required("Message")
  ["yup.min", 5, "Min 5"],                 // .min(5, "Min 5")
  ["yup.matches", /regex/, "Match pattern"] // .matches(/regex/, "Match pattern")
]

// Limitations:
// - No yup.when() support (conditional validation)
// - No yup.test() support (custom validators)
// - No async validation
// - No lazy evaluation
```

### Constants and Configuration

```typescript
// No validation-specific environment variables
// No validation-specific feature flags
// No performance tuning parameters

// Only related constants:
MAX_CONSEQUTIVE_SAVE_ERRORS = 5;  // Draft system
LOCK_HOLD_TIMEOUT = 5000;          // Form lock timeout
LOCK_WAIT_TIMEOUT = 120000;        // 2 minutes

// Platform detection for field behavior:
if (Capacitor.getPlatform() === 'web') {
  // Web-specific behavior
} else {
  // Mobile behavior
}
```

---

## 14. Migration and Compatibility {important} {developer}

### From Older Notebooks

#### Validation Schema Changes
- Pre-2024: Used custom validation format
- 2024+: Migrated to yup-ast arrays
- Migration: Automatic on notebook import

#### Breaking Changes to Avoid
1. **Never change field types** after data collection
2. **Never add required** to existing fields
3. **Never tighten validation** without data review
4. **Never change field IDs** (breaks everything)

### Data Import Considerations

#### Round-Trip Compatibility
- Export preserves all validation states
- Import skips validation by default
- Re-validation optional on import
- Invalid data flagged but accepted

#### Version Control Strategy
```bash
# Validation included in notebook JSON
git add notebook.json
git commit -m "Added validation to site-name field"
git tag v1.2.0-validation-update
```

### Platform Differences

| Platform | Validation Behavior | Special Considerations |
|----------|-------------------|----------------------|
| Web | Standard | Some fields disabled (QRCode) |
| iOS | Standard | GPS accuracy validation important |
| Android | Standard | Performance issues with many fields |
| Offline | Standard | No server-side validation |

---

## 15. Appendix: Complete Validation Examples {comprehensive} {claude-code}

### Example 1: Archaeological Site Recording

```json
{
  "site-id": {
    "component-name": "BasicAutoIncrementer",
    "component-parameters": {
      "label": "Site ID",
      "required": true
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Site ID is required"],
      ["yup.matches", "^SITE-\\d{4}$", "Format: SITE-0001"]
    ]
  },
  "site-type": {
    "component-name": "RadioGroup",
    "component-parameters": {
      "label": "Site Type",
      "required": true,
      "options": [
        {"value": "habitation", "label": "Habitation"},
        {"value": "burial", "label": "Burial"},
        {"value": "industrial", "label": "Industrial"},
        {"value": "other", "label": "Other"}
      ]
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Site type must be selected"]
    ]
  },
  "other-type-description": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Describe Other Type",
      "required": false  // NOT required despite condition
    },
    "condition": {
      "operator": "equal",
      "field": "site-type",
      "value": "other"
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.min", 20, "Please provide at least 20 characters"]
    ]
  },
  "gps-location": {
    "component-name": "TakePoint",
    "component-parameters": {
      "label": "GPS Location",
      "required": true
    },
    "validationSchema": [
      ["yup.object"],
      ["yup.required", "GPS location is mandatory"]
    ]
  },
  "site-photos": {
    "component-name": "TakePhoto",
    "component-parameters": {
      "label": "Site Photos"
    },
    "validationSchema": [
      ["yup.array"],
      ["yup.min", 1, "At least one photo required"],
      ["yup.max", 10, "Maximum 10 photos"]
    ]
  }
}
```

### Example 2: Duplicate Field Pattern for Conditional Required

```json
{
  "recording-level": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Recording Level",
      "options": [
        {"value": "basic", "label": "Basic"},
        {"value": "detailed", "label": "Detailed"}
      ]
    }
  },
  "description-basic": {
    "component-name": "MultilineTextField",
    "component-parameters": {
      "label": "Brief Description",
      "required": false,
      "rows": 3
    },
    "condition": {
      "operator": "equal",
      "field": "recording-level",
      "value": "basic"
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.max", 200, "Maximum 200 characters for basic recording"]
    ]
  },
  "description-detailed": {
    "component-name": "MultilineTextField",
    "component-parameters": {
      "label": "Detailed Description",
      "required": true,
      "rows": 10,
      "helperText": "Provide comprehensive description (minimum 500 characters)"
    },
    "condition": {
      "operator": "equal",
      "field": "recording-level",
      "value": "detailed"
    },
    "validationSchema": [
      ["yup.string"],
      ["yup.required", "Detailed description is required"],
      ["yup.min", 500, "Minimum 500 characters for detailed recording"]
    ]
  }
}
```

### Example 3: Complex Number Validation

```json
{
  "measurement-value": {
    "component-name": "ControlledNumber",
    "component-parameters": {
      "label": "Measurement (cm)",
      "min": 0,
      "max": 1000,
      "precision": 2
    },
    "validationSchema": [
      ["yup.number"],
      ["yup.required", "Measurement is required"],
      ["yup.min", 0.01, "Must be greater than 0"],
      ["yup.max", 1000, "Maximum 1000 cm"],
      ["yup.test", "precision", "Maximum 2 decimal places", 
        "(value) => !value || value.toString().split('.')[1]?.length <= 2"]
    ]
  }
}
```

---

## See Also

- **[Conditional Logic System](./ConditionalLogic.md)** - How conditions interact with validation
- **[Field Type Reference](./FieldTypes.md)** - Complete validation capabilities per field
- **[Performance Optimization Guide](./Performance.md)** - Improving form responsiveness
- **[Designer User Guide](./Designer.md)** - Setting up validation through GUI
- **[JSON Schema Reference](./JSONSchema.md)** - Complete JSON validation syntax
- **[Bug Reports and Feature Requests](./BugReports.md)** - Known issues and roadmap

---

*Documentation Version: 1.0.0*  
*Last Technical Verification: August 2025*  
*Next Review: September 2025*

*Critical Note: This documentation reflects the validation system as of August 2025, including the recent filterErrors addition (January 2025) which may still have undiscovered bugs. The hidden required fields issue may or may not be resolved by filterErrors - testing required.*

<!-- concat:pattern:conditional-logic -->
# Conditional Logic System - Third Draft Documentation
## Fieldmark/FAIMS3 Notebook Designer Reference

### Document Classification
- **Component Type**: System Behavior
- **Audience Tags**: {designer} {developer} {claude-code}
- **Depth Levels**: {essential} {important} {comprehensive}
- **Version**: 1.0.0
- **Last Technical Verification**: August 2025

---

## 1. Quick Start {essential} {designer}

### What Are Conditions?
Conditions control when fields and sections appear in your notebook, similar to skip patterns in survey tools like Survey Monkey or Qualtrics. They create dynamic forms that adapt based on user input, streamlining data entry especially on mobile devices.

### Basic Example: "Other" Field Pattern
```json
{
  "category": {
    "component-name": "Select",
    "component-parameters": {
      "label": "Category",
      "ElementProps": {
        "options": [
          {"value": "site", "label": "Archaeological Site"},
          {"value": "artifact", "label": "Artifact"},
          {"value": "other", "label": "Other"}
        ]
      }
    }
  },
  "category_other": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Please specify other",
      "required": true
    },
    "condition": {
      "operator": "equal",
      "field": "category",
      "value": "other"
    }
  }
}
```

### Testing Workflow {essential} {designer}
Conditions must be tested in deployed notebooks (not Designer preview):
1. Open Designer in one browser tab
2. Open deployed notebook in another tab  
3. Make changes in Designer and save
4. Refresh notebook tab (changes apply in seconds)
5. Test conditions with real data entry

**Note**: Designer preview does NOT evaluate conditions. Always test in deployed notebook.

---

## 2. Critical Warnings {essential} {designer} {claude-code}

### ‚ö†Ô∏è Type Matching Required
Number fields require number values in conditions - string numbers will NOT match:
- ‚úÖ **CORRECT**: `{"operator": "equal", "field": "count", "value": 5}`
- ‚ùå **WRONG**: `{"operator": "equal", "field": "count", "value": "5"}`

This is the #1 source of "why isn't my condition working?" issues.

### ‚ö†Ô∏è Hidden Required Fields Still Validate
Required fields that are hidden by conditions STILL block form submission:
- **Solution 1**: Never hide required fields
- **Solution 2**: Make fields non-required if they can be hidden
- **Solution 3**: Use duplicate fields pattern (one required, one optional)

### ‚ö†Ô∏è No Cross-Form References
Conditions can only reference fields within the same form (viewset):
- Parent forms cannot reference child form fields
- Child forms cannot reference parent form fields
- No mechanism exists for cross-form field access

### ‚ö†Ô∏è BasicAutoIncrementer String Comparison
Auto-incrementers return padded strings ("0001", "0002"), not numbers.
String comparison means "0150" < "0099" is TRUE (alphabetical order).
- **Solution**: Design compound HRIDs that sort properly regardless

### ‚ö†Ô∏è No Field ID Migration
When field IDs change, conditions referencing them fail silently:
- No error messages
- Condition returns false
- Manual update required

---

## 3. How Conditions Work {important} {developer}

### Condition Lifecycle
1. **Compilation**: Conditions compiled to JavaScript functions on form load
2. **Caching**: Stored as `conditionFn` property on fields/sections
3. **Evaluation**: Only when "controller fields" change
4. **Application**: Hide/show fields before render (no flicker)

### Controller Fields
Any field referenced in a condition automatically becomes a "controller field":
- Detection is automatic - no configuration needed
- Only changes to controller fields trigger re-evaluation
- Optimizes performance by avoiding unnecessary checks

### Values Object
All fields are initialized in the values object on form load:
- Fields start with their `initialValue` (or `""` if not specified)
- Fields are never removed from values, only updated
- Hidden field values persist and remain accessible

---

## 4. Configuration and JSON Structure {important} {claude-code}

### Basic Condition Structure
```json
{
  "field-name": {
    "component-name": "TextField",
    "component-parameters": {...},
    "condition": {
      "operator": "equal",
      "field": "trigger-field",
      "value": "expected-value"
    }
  }
}
```

### Section-Level Conditions
Entire sections can be conditional. When hidden:
- Section removed from navigation breadcrumb
- Progress indicators update (e.g., "2/2" becomes "2/3" when section appears)
- No placeholder or gap in navigation

```json
{
  "OptionalSection": {
    "label": "Additional Details",
    "fields": ["field1", "field2", "field3"],
    "condition": {
      "operator": "equal",
      "field": "collect-details",
      "value": "yes"
    }
  }
}
```

### Property Names
- **Modern**: `condition` (recommended)
- **Legacy**: `is_logic` (deprecated but supported)

---

## 5. Operators Reference {important} {claude-code}

### Comparison Operators

| Operator | Description | Type Handling | Example Value |
|----------|-------------|---------------|---------------|
| `equal` | Exact match | Strict (===) | `"yes"`, `5`, `true` |
| `not-equal` | Not equal | Strict (!==) | `"no"`, `10`, `false` |
| `greater` | Greater than | Coercion | `10` |
| `greater-equal` | Greater or equal | Coercion | `0` |
| `less` | Less than | Coercion | `100` |
| `less-equal` | Less or equal | Coercion | `999` |
| `regex` | Pattern match | String | `"\\d+"`, `"^[A-Z]"` |

### Array Operators
For fields returning arrays (multi-select, checkboxes):

| Operator | Description | Example Value |
|----------|-------------|---------------|
| `contains` | Array includes value | `"option1"` |
| `does-not-contain` | Array excludes value | `"option2"` |
| `contains-one-of` | Has at least one | `["A", "B", "C"]` |
| `does-not-contain-any-of` | Has none of these | `["X", "Y"]` |
| `contains-all-of` | Has all values | `["A", "B"]` |
| `does-not-contain-all-of` | Missing at least one | `["A", "B", "C"]` |
| `contains-regex` | Any element matches | `"test.*"` |
| `does-not-contain-regex` | No element matches | `"^temp"` |

### Logical Operators

| Operator | Description | Short-Circuit | Performance Tip |
|----------|-------------|---------------|-----------------|
| `and` | All conditions true | Yes (first false) | Put likely-false first |
| `or` | Any condition true | Yes (first true) | Put likely-true first |

---

## 6. Complex Logic Patterns {important} {claude-code}

### AND Logic Example
Show field only if multiple conditions are met:
```json
{
  "condition": {
    "operator": "and",
    "conditions": [
      {"operator": "equal", "field": "sample-collected", "value": "yes"},
      {"operator": "greater", "field": "sample-count", "value": 0}
    ]
  }
}
```

### OR Logic Example
Show field if any condition is met:
```json
{
  "condition": {
    "operator": "or",
    "conditions": [
      {"operator": "equal", "field": "contact-method", "value": "email"},
      {"operator": "equal", "field": "contact-method", "value": "online"}
    ]
  }
}
```

### Nested Complex Logic
Combine AND and OR for sophisticated patterns:
```json
{
  "condition": {
    "operator": "or",
    "conditions": [
      {
        "operator": "and",
        "conditions": [
          {"operator": "equal", "field": "survey-type", "value": "detailed"},
          {"operator": "greater", "field": "team-size", "value": 2}
        ]
      },
      {"operator": "equal", "field": "override-details", "value": true}
    ]
  }
}
```
This reads as: `(survey-type='detailed' AND team-size>2) OR override-details=true`

---

## 7. Field Type Interactions {important} {developer}

### Standard Field Types

| Field Type | Value Type | Condition Value | Notes |
|------------|------------|-----------------|-------|
| TextField | string | `"text"` | Exact string match |
| NumberField | number | `42` | Use numbers, not strings |
| NumberInput | number | `3.14` | Decimal support |
| Checkbox | boolean | `true` or `false` | Not "true" string |
| RadioGroup | string | `"option1"` | Returns value, not label |
| Select (single) | string | `"selected"` | Returns value property |
| Select (multiple) | array | Use array operators | Empty = `[]` |
| DatePicker | string | `"2024-01-01"` | ISO format, string comparison works |
| DateTimeField | string | `"2024-01-01T10:30"` | Local time, no timezone |
| BasicAutoIncrementer | string | `"0001"` | Padded string, alphabetical sort |

### Complex Fields - Cannot Use Directly
These fields return complex objects that cannot be used in conditions:

| Field Type | Returns | Workaround |
|------------|---------|------------|
| TakePhoto | Blob array | Use TemplatedStringField pattern |
| TakePoint | GeoJSON object | Extract to hidden field |
| MapFormField | GeoJSON object | Manual indicator field |
| RelationshipField | Relationship objects | Hidden status field |
| AnnotationAttachment | Attachment array | Manual checkbox |

---

## 8. Complex Field Workarounds {important} {designer} {claude-code}

### The Hidden Template Pattern
For complex fields that can't be used directly in conditions, create a hidden TemplatedStringField that automatically tracks their status:

```json
{
  "site-photos": {
    "component-name": "TakePhoto",
    "component-parameters": {
      "label": "Site Photographs"
    }
  },
  "_has_photos": {
    "component-name": "TemplatedStringField",
    "component-parameters": {
      "template": "{{#site-photos}}yes{{/site-photos}}{{^site-photos}}no{{/site-photos}}",
      "hidden": true
    }
  },
  "photo-description": {
    "component-name": "MultilineTextField",
    "component-parameters": {
      "label": "Describe the photographs",
      "helperText": "Include details about what each photo shows",
      "required": true
    },
    "condition": {
      "operator": "equal",
      "field": "_has_photos",
      "value": "yes"
    }
  }
}
```

### Pattern Conventions
- **Naming**: Prefix with underscore (`_has_photos`, `_has_location`)
- **Values**: Use simple `yes/no` or `true/false`
- **Visibility**: Always set `hidden: true`
- **Updates**: Automatic when source field changes

### Common Templates

```javascript
// Boolean existence check (most common for conditions)
"{{#fieldname}}yes{{/fieldname}}{{^fieldname}}no{{/fieldname}}"

// Alternative boolean format
"{{#fieldname}}true{{/fieldname}}{{^fieldname}}false{{/fieldname}}"

// Default value pattern
"{{fieldname}}{{^fieldname}}none{{/fieldname}}"
```

### Mustache Template Limitations for Conditions
- Cannot access array `.length` property
- Limited nested property access
- Cannot perform calculations
- Boolean existence checks most reliable

**Note**: For complete Mustache template capabilities including string concatenation, date formatting, and advanced patterns, see the TemplatedStringField documentation. This section focuses only on patterns useful for conditional logic.

---

## 9. Value Handling and Type Coercion {comprehensive} {developer}

### Field State Scenarios

| Scenario | In values? | equal to `null` | equal to `""` | not-equal to `""` |
|----------|------------|-----------------|---------------|-------------------|
| Never touched | Yes (initialized) | false | true (usually) | false |
| User typed then cleared | Yes | false | true | false |
| Has null value | Yes | true | false | true |
| Has empty string | Yes | false | true | false |
| Field doesn't exist in form | No | false | false | true |

### Type Coercion Rules
- **equal/not-equal**: Strict comparison (`===`, `!==`)
  - `"5"` will NOT equal `5`
  - `true` will NOT equal `"true"`
- **Comparison operators**: JavaScript coercion applies
  - `"20" > 10` returns `true` (string coerced to number)
  - `"10" < 5` returns `false`

### Hidden Field Value Behavior
- Values persist when hidden
- Included in form submission
- Can be referenced by other conditions
- Validation still enforced (including required)

---

## 10. Performance Optimization {important} {developer}

### Performance Boundaries

| Complexity | Safe Limit | Notes |
|------------|------------|-------|
| Simple conditions (equal) | 100-200 per form | Minimal impact |
| Complex nested conditions | 20-30 per form | Noticeable at higher counts |
| Controller fields | ~50 | Each triggers re-evaluation |
| Nesting depth | ~10 levels | Tested to 20+ but degrades |
| AND/OR array size | 10-20 conditions | Similar to nesting |

### Optimization Strategies

#### 1. Condition Ordering (50-90% improvement)
Leverage short-circuiting by ordering conditions strategically:

```json
// OPTIMIZED - Likely true first in OR
{
  "operator": "or",
  "conditions": [
    {"operator": "equal", "field": "common-field", "value": true},
    {"operator": "regex", "field": "description", "value": "complex.*pattern"}
  ]
}

// OPTIMIZED - Likely false first in AND
{
  "operator": "and",
  "conditions": [
    {"operator": "equal", "field": "rare-condition", "value": true},
    {"operator": "greater", "field": "count", "value": 100}
  ]
}
```

#### 2. Minimize Controller Fields
Each controller field triggers re-evaluation. Group related conditions under single triggers where possible.

#### 3. Avoid Regex When Possible
Regex operations are more expensive than simple comparisons.

### Warning Signs of Performance Issues
- Lag when typing in controller fields
- Delayed field show/hide animations
- Form freezing during navigation
- Browser "script running slowly" warnings

---

## 11. Common Patterns {important} {designer}

### Pattern: Other ‚Üí Specify
```json
{
  "category": {
    "component-name": "RadioGroup",
    "component-parameters": {
      "label": "Site Type",
      "options": [
        {"value": "historic", "label": "Historic"},
        {"value": "prehistoric", "label": "Prehistoric"},
        {"value": "other", "label": "Other"}
      ]
    }
  },
  "category_other_specify": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Please specify other site type",
      "required": true,
      "helperText": "Provide a brief description"
    },
    "condition": {
      "operator": "equal",
      "field": "category",
      "value": "other"
    }
  }
}
```

### Pattern: Progressive Disclosure
```json
{
  "basic_survey": {
    "component-name": "RadioGroup",
    "component-parameters": {
      "label": "Conduct detailed survey?",
      "options": [
        {"value": "yes", "label": "Yes - Full Survey"},
        {"value": "no", "label": "No - Basic Only"}
      ]
    }
  },
  "DetailedSection": {
    "label": "Detailed Survey Information",
    "condition": {
      "operator": "equal",
      "field": "basic_survey",
      "value": "yes"
    },
    "fields": [
      "measurement-method",
      "measurement-precision",
      "environmental-conditions",
      "team-members"
    ]
  }
}
```

### Pattern: Conditional Required Fields (Workaround)
Since conditional validation isn't supported, use duplicate fields:
```json
{
  "contact_method": {
    "component-name": "RadioGroup",
    "component-parameters": {
      "label": "Preferred Contact Method",
      "options": [
        {"value": "email", "label": "Email"},
        {"value": "phone", "label": "Phone"},
        {"value": "none", "label": "No Contact"}
      ]
    }
  },
  "email_optional": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Email Address",
      "type": "email",
      "required": false
    },
    "condition": {
      "operator": "not-equal",
      "field": "contact_method",
      "value": "email"
    }
  },
  "email_required": {
    "component-name": "TextField",
    "component-parameters": {
      "label": "Email Address",
      "type": "email",
      "required": true,
      "helperText": "Required for email contact"
    },
    "condition": {
      "operator": "equal",
      "field": "contact_method",
      "value": "email"
    }
  }
}
```

### Pattern: Manual vs Automated Indicators

#### Use Manual Indicators When:
- Human confirmation required
- Audit trail needed
- Complex judgment involved
- No technical derivation possible

#### Use Automated Templates When:
- Value computable from other fields
- Consistency crucial
- Reducing cognitive load
- System tracking fields

---

## 12. Troubleshooting Guide {important} {designer}

### Debugging Checklist
When a condition isn't working, check in order:

1. **Type Mismatch** (Most Common)
   - Number field with string value?
   - Boolean field with string "true"?
   - Check exact types in browser console

2. **Field ID Spelling**
   - Exact match required
   - Case-sensitive
   - No typos in field reference

3. **Deployment Status**
   - Conditions don't work in Designer preview
   - Must test in deployed notebook
   - Changes require save and refresh

4. **Field Initialization**
   - Check if field exists in values object
   - May need initialValue set
   - Hidden fields still need initialization

5. **Operator Choice**
   - Using `equal` when you need `contains`?
   - Array field needs array operators
   - Regex format correct?

### Debug Techniques

#### Enable Debug Logging
```javascript
// In browser console
localStorage.setItem('debug', 'faims:*');
// Refresh page to see detailed logs
```

#### Monitor Condition Performance
```javascript
// Add to console before testing
const originalFn = window.compileExpression;
window.compileExpression = function(expr) {
  console.time('condition-compile');
  const result = originalFn(expr);
  console.timeEnd('condition-compile');
  return result;
}
```

#### Inspect Values Object
```javascript
// In browser console while form is open
console.log(window.Formik.values);
// Or for specific field
console.log(window.Formik.values['field-name']);
```

### Common Issues and Solutions

| Problem | Likely Cause | Solution |
|---------|--------------|----------|
| Field never appears | Type mismatch in condition | Verify number vs string types |
| Field always visible | Condition syntax error | Check operator spelling |
| Required hidden field blocks save | Validation on hidden fields | Make non-required or keep visible |
| Condition works intermittently | Race condition or missing field | Ensure field initialized first |
| Performance degradation | Too many complex conditions | Simplify logic or reduce count |
| Changes don't take effect | Not refreshing deployed notebook | Save in Designer, refresh notebook |

### Error Messages

| Error | Meaning | Fix |
|-------|---------|-----|
| "Unknown operator X" | Invalid operator name | Check spelling (e.g., `equal` not `equals`) |
| Form won't load | Malformed condition JSON | Validate JSON syntax |
| Silent failure | Field reference doesn't exist | Verify field ID exists in form |

---

## 13. Validation Rules and Display Behavior {comprehensive} {developer}

### Validation Interaction with Conditions

| Validation Rule | When Hidden | When Visible | Notes |
|-----------------|-------------|--------------|-------|
| required: true | Still enforced | Enforced | Hidden required fields block submission |
| min/max | Still enforced | Enforced | Numeric bounds always checked |
| pattern | Still enforced | Enforced | Regex patterns always validated |
| Custom validation | Still runs | Runs | All validation runs regardless |

### Display Behavior

| Aspect | Behavior | Notes |
|--------|----------|-------|
| Initial render | Hidden if condition false | No flicker - evaluated before display |
| Show animation | Immediate | No transition effects |
| Hide animation | Immediate | Values preserved |
| Layout shift | Minimal | Space collapses when hidden |
| Tab order | Skips hidden fields | Keyboard navigation adjusts |
| Section navigation | Hidden sections removed | Progress indicators update dynamically |
| Breadcrumbs | Hidden sections omitted | Navigation updates in real-time |

### Error Message Display
- Hidden fields with validation errors don't show messages
- Errors appear when field becomes visible
- Form submission shows all errors (including hidden)

---

## 14. Migration and Compatibility {comprehensive} {developer}

### Field ID Changes
**Warning**: No automatic migration for renamed fields
- Conditions fail silently (return false)
- No error messages or warnings
- Manual update required in all conditions
- Search and replace recommended

### Legacy Format Support

#### Old is_logic Format
Still supported but deprecated:
```json
{
  "field-name": {
    "is_logic": {
      "trigger-field": ["value1", "value2"]
    }
  }
}
```

#### Modern Equivalent
```json
{
  "field-name": {
    "condition": {
      "operator": "or",
      "conditions": [
        {"operator": "equal", "field": "trigger-field", "value": "value1"},
        {"operator": "equal", "field": "trigger-field", "value": "value2"}
      ]
    }
  }
}
```

### Version Compatibility
- Conditions work identically across platforms
- No mobile-specific behavior
- Offline mode fully supported
- All browsers supporting ES6

---

## 15. Known Limitations and Roadmap {important} {designer} {developer}

### Current Limitations

#### Cannot Do (Technical Limitations)
- **Cross-form references** - No access to parent/child form fields
- **Array length checks** - Cannot count items in arrays
- **Nested property access** - Limited support for object.property
- **Conditional validation** - Cannot make fields required only when visible
- **Complex calculations** - No sum, average, or arithmetic operations
- **Complex field conditions** - TakePhoto, TakePoint, RelationshipField need workarounds

#### Cannot Do (Implementation Gaps)
- **Designer preview evaluation** - Must deploy to test conditions
- **Field ID migration** - Renamed fields break conditions silently
- **Debug visibility** - No visual indicators of condition evaluation
- **Circular dependency detection** - System allows but doesn't warn

### Roadmap Features (Planned Improvements)

#### High Priority
- **Designer preview with conditions** - Test without deployment
- **Conditional validation** - Required only when visible
- **Additional operators** (User requested):
  - `between` - Range checks (e.g., `5 < x < 10`)
  - `count` - Array length (e.g., number of photos)
  - `sum` - Total of numeric fields
  - `average` - Mean of numeric fields
  - `product` - Multiplication of field values
  - Basic arithmetic (`+`, `-`, `*`, `/`)

#### Future Considerations
- **Calculated fields** - Auto-compute values from other fields
- **Cross-form references** - Access parent/child form fields
- **Migration tools** - Update conditions when field IDs change
- **Visual debugging** - Show condition evaluation in Designer
- **Performance monitoring** - Built-in condition profiling
- **Dependency visualization** - Graph of field relationships

### Workarounds for Current Limitations

| Limitation | Current Workaround |
|------------|-------------------|
| No Designer preview | Two-tab testing workflow |
| No conditional validation | Duplicate fields (required/optional) |
| No array counts | Manual indicator fields |
| Complex field conditions | TemplatedStringField pattern |
| No calculations | Server-side processing or manual entry |

---

## 16. Design Patterns and Best Practices {important} {designer}

### Effective Condition Design

#### 1. Use Required Fields as Triggers
Required fields guarantee user interaction, making them ideal condition controllers:
```json
{
  "survey-type": {
    "component-name": "RadioGroup",
    "component-parameters": {
      "required": true,
      "label": "Survey Type"
    }
  },
  "grid-details": {
    "condition": {
      "operator": "equal",
      "field": "survey-type",
      "value": "grid"
    }
  }
}
```

#### 2. Group Related Conditions
Minimize cognitive load by grouping related conditional fields:
```json
{
  "PhotoSection": {
    "label": "Photographic Documentation",
    "condition": {
      "operator": "equal",
      "field": "include-photos",
      "value": "yes"
    },
    "fields": [
      "photo-capture",
      "photo-description",
      "photographer-name",
      "photo-conditions"
    ]
  }
}
```

#### 3. Clear Visual Hierarchy
Use section headers or display fields to explain conditional content:
```json
{
  "detailed-header": {
    "component-name": "RichText",
    "component-parameters": {
      "content": "<h3>Additional Details Required</h3><p>Please complete all fields below</p>"
    },
    "condition": {
      "operator": "equal",
      "field": "needs-details",
      "value": true
    }
  }
}
```

### When to Use Conditions

**Good Use Cases:**
- Skip patterns for irrelevant fields
- Progressive disclosure of complexity
- Role-based field visibility
- Dynamic form adaptation
- Mobile screen optimization

**Avoid Conditions When:**
- All users need the field
- Complexity exceeds benefit
- Cross-form logic required
- Performance is critical

---

## 16. Platform Behavior Matrix {comprehensive} {developer}

### Platform Comparison

| Feature | Web | iOS | Android | Notes |
|---------|-----|-----|---------|-------|
| Condition evaluation | ‚úÖ Identical | ‚úÖ Identical | ‚úÖ Identical | Client-side JavaScript |
| Performance | Fastest | Good | Good | Desktop typically faster |
| Offline support | ‚úÖ Full | ‚úÖ Full | ‚úÖ Full | No server dependency |
| Debug tools | Best | Limited | Limited | Browser DevTools advantage |
| Touch events | Mouse | Native | Native | No impact on conditions |

### Browser Compatibility

| Browser | Support | Notes |
|---------|---------|-------|
| Chrome 90+ | ‚úÖ Full | Recommended for Designer |
| Firefox 88+ | ‚úÖ Full | Full support |
| Safari 14+ | ‚úÖ Full | macOS and iOS |
| Edge 90+ | ‚úÖ Full | Chromium-based |

---

## 17. Implementation Notes {comprehensive} {developer}

### Technical Architecture

#### Compilation Process
```javascript
// Simplified compilation flow
compileUiSpecConditionals(spec) {
  for (field in spec.fields) {
    if (field.condition) {
      field.conditionFn = compileExpression(field.condition);
      addToControllerFields(extractFieldRefs(field.condition));
    }
  }
}
```

#### Evaluation Cycle
1. Controller field changes
2. Formik triggers update
3. branchingLogic.tsx checks conditions
4. getFieldsMatchingCondition filters fields
5. React re-renders with filtered fields

#### Memory Model
- All conditions compiled once on load
- Functions cached in memory
- Values object holds all field states
- Hidden values persist in Formik state

### File Locations (Internal Reference)
- Core logic: `/app/src/conditionals.ts`
- Compilation: `/app/src/uiSpecification.ts`
- Runtime evaluation: `/app/src/gui/components/record/branchingLogic.tsx`
- Legacy support: `/app/src/uiSpecification.ts:compileIsLogic()`

---

## 18. Decision Trees {claude-code}

### Condition Necessity Decision
```
Is this field always needed?
‚îú‚îÄ Yes ‚Üí No condition required
‚îî‚îÄ No ‚Üí Does visibility depend on user input?
    ‚îú‚îÄ No ‚Üí Consider permission/role system
    ‚îî‚îÄ Yes ‚Üí Implement condition
        ‚îú‚îÄ Single trigger ‚Üí Simple condition
        ‚îú‚îÄ Multiple triggers ‚Üí OR logic
        ‚îî‚îÄ Multiple requirements ‚Üí AND logic
```

### Operator Selection Guide
```
What comparison do you need?
‚îú‚îÄ Exact match ‚Üí equal / not-equal
‚îú‚îÄ Numeric comparison ‚Üí greater / less operators
‚îú‚îÄ Text pattern ‚Üí regex
‚îú‚îÄ Multiple options ‚Üí contains operators
‚îú‚îÄ Complex logic ‚Üí Nested AND/OR
‚îî‚îÄ Field existence ‚Üí Check against null/empty
```

### Complex Field Handling
```
Is the field type complex (Photo/Location/Relationship)?
‚îú‚îÄ No ‚Üí Use direct condition
‚îî‚îÄ Yes ‚Üí Can the state be derived?
    ‚îú‚îÄ No ‚Üí Use manual indicator field
    ‚îî‚îÄ Yes ‚Üí Use TemplatedStringField pattern
        ‚îú‚îÄ Boolean check ‚Üí {{#field}}yes{{/field}}
        ‚îî‚îÄ Value extraction ‚Üí Limited support
```

---

## 19. Anti-Patterns to Avoid {important} {designer}

### ‚ùå Hidden Required Fields
```json
// AVOID - Blocks form submission when hidden
{
  "critical-field": {
    "component-parameters": {"required": true},
    "condition": {"operator": "equal", "field": "optional", "value": "yes"}
  }
}
```

### ‚ùå Cross-Form Dependencies
```json
// WON'T WORK - Cannot reference parent form
{
  "child-field": {
    "condition": {"operator": "equal", "field": "parent.field", "value": "yes"}
  }
}
```

### ‚ùå Type Mismatches
```json
// BROKEN - Number field won't match string
{
  "condition": {
    "operator": "equal",
    "field": "number-field",
    "value": "5"  // Should be 5 (number)
  }
}
```

### ‚ùå Over-Complex Nesting
Avoid deeply nested conditions that are hard to debug and maintain.

---

## 20. Relationship to Other Systems {important} {designer}

### Related Field Types

#### TemplatedStringField
Essential for condition workarounds with complex fields:
- Creates derived values for conditions
- Enables boolean checks on arrays
- Provides computed fields

#### BasicAutoIncrementer
Special consideration needed:
- Returns padded strings
- Alphabetical sorting issues
- Best used in compound IDs

#### Select vs MultiSelect
Different operators required:
- Select: Use standard operators
- MultiSelect: Use array operators

### Integration with Other Features

| Feature | Interaction with Conditions |
|---------|----------------------------|
| Validation | Runs regardless of visibility |
| Draft Saving | Hidden values preserved |
| Export | All values included |
| Relationships | Cannot be used in conditions |
| Annotations | Cannot be used in conditions |

---

## Appendix A: Complete JSON Examples {comprehensive} {claude-code}

### Example 1: Heritage Site Survey with Progressive Disclosure
```json
{
  "fields": {
    "site-type": {
      "component-name": "RadioGroup",
      "component-parameters": {
        "label": "Heritage Site Type",
        "required": true,
        "options": [
          {"value": "aboriginal", "label": "Aboriginal Site"},
          {"value": "historical", "label": "Historical Site"},
          {"value": "maritime", "label": "Maritime Heritage"},
          {"value": "other", "label": "Other"}
        ]
      }
    },
    "site-type-other": {
      "component-name": "TextField",
      "component-parameters": {
        "label": "Specify Other Site Type",
        "required": true
      },
      "condition": {
        "operator": "equal",
        "field": "site-type",
        "value": "other"
      }
    },
    "aboriginal-details": {
      "component-name": "Select",
      "component-parameters": {
        "label": "Aboriginal Site Category",
        "ElementProps": {
          "options": [
            {"value": "midden", "label": "Shell Midden"},
            {"value": "art", "label": "Rock Art"},
            {"value": "tool", "label": "Tool Making Site"},
            {"value": "ceremonial", "label": "Ceremonial Site"}
          ]
        }
      },
      "condition": {
        "operator": "equal",
        "field": "site-type",
        "value": "aboriginal"
      }
    },
    "requires-protection": {
      "component-name": "Checkbox",
      "component-parameters": {
        "label": "Site requires immediate protection"
      }
    },
    "protection-details": {
      "component-name": "MultilineTextField",
      "component-parameters": {
        "label": "Protection Measures Required",
        "required": true,
        "rows": 4
      },
      "condition": {
        "operator": "equal",
        "field": "requires-protection",
        "value": true
      }
    }
  }
}
```

### Example 2: Complex Multi-Condition Form
```json
{
  "fields": {
    "survey-method": {
      "component-name": "Select",
      "component-parameters": {
        "label": "Survey Method",
        "ElementProps": {
          "options": [
            {"value": "pedestrian", "label": "Pedestrian Survey"},
            {"value": "vehicular", "label": "Vehicular Survey"},
            {"value": "aerial", "label": "Aerial Survey"},
            {"value": "marine", "label": "Marine Survey"}
          ]
        }
      }
    },
    "team-size": {
      "component-name": "NumberInput",
      "component-parameters": {
        "label": "Team Size"
      }
    },
    "detailed-recording": {
      "component-name": "RadioGroup",
      "component-parameters": {
        "label": "Detailed Recording Required?",
        "options": [
          {"value": "yes", "label": "Yes"},
          {"value": "no", "label": "No"}
        ]
      },
      "condition": {
        "operator": "or",
        "conditions": [
          {
            "operator": "and",
            "conditions": [
              {"operator": "equal", "field": "survey-method", "value": "pedestrian"},
              {"operator": "greater", "field": "team-size", "value": 2}
            ]
          },
          {"operator": "equal", "field": "survey-method", "value": "aerial"}
        ]
      }
    }
  }
}
```

### Example 3: Photo Documentation with Automated Detection
```json
{
  "fields": {
    "site-photos": {
      "component-name": "TakePhoto",
      "component-parameters": {
        "label": "Site Photographs",
        "helperText": "Capture overall site images"
      }
    },
    "_has_photos": {
      "component-name": "TemplatedStringField",
      "component-parameters": {
        "template": "{{#site-photos}}yes{{/site-photos}}{{^site-photos}}no{{/site-photos}}",
        "hidden": true
      }
    },
    "photo-metadata": {
      "component-name": "Select",
      "component-parameters": {
        "label": "Photography Conditions",
        "ElementProps": {
          "options": [
            {"value": "sunny", "label": "Sunny"},
            {"value": "overcast", "label": "Overcast"},
            {"value": "rain", "label": "Rain"},
            {"value": "artificial", "label": "Artificial Light"}
          ]
        }
      },
      "condition": {
        "operator": "equal",
        "field": "_has_photos",
        "value": "yes"
      }
    },
    "photo-description": {
      "component-name": "MultilineTextField",
      "component-parameters": {
        "label": "Describe Photographs",
        "required": true,
        "rows": 3
      },
      "condition": {
        "operator": "equal",
        "field": "_has_photos",
        "value": "yes"
      }
    }
  }
}
```

### Example 4: Dynamic Section Navigation
This example shows how conditional sections affect navigation and progress indicators:
```json
{
  "sections": {
    "Main": {
      "label": "Main",
      "fields": ["artifact-length", "artifact-width", "artifact-height", "add-additional"]
    },
    "ArtefactMeasurements": {
      "label": "Artefact Measurements",
      "fields": ["weight", "material", "condition"]
    },
    "ExtraArtefactMeasurements": {
      "label": "Extra Artefact Measurements",
      "fields": ["volume", "density", "magnetic-susceptibility"],
      "condition": {
        "operator": "equal",
        "field": "add-additional",
        "value": true
      }
    }
  },
  "fields": {
    "artifact-length": {
      "component-name": "NumberInput",
      "component-parameters": {
        "label": "Artefact Length (mm)",
        "helperText": "Length of the artefact in mm"
      }
    },
    "add-additional": {
      "component-name": "Checkbox",
      "component-parameters": {
        "label": "Add Additional Artefact Measurements?",
        "helperText": "Check to add additional dimensions"
      }
    }
  }
}
```
**Navigation behavior:**
- When unchecked: Progress shows "2/2", two sections visible
- When checked: Progress shows "2/3", "Extra Artefact Measurements" appears
- Navigation breadcrumbs update dynamically
- No page reload required

---

## Appendix B: Quick Reference Card {essential} {designer}

### Most Common Patterns
```json
// Show if equals
{"operator": "equal", "field": "trigger", "value": "yes"}

// Show if NOT equals
{"operator": "not-equal", "field": "trigger", "value": "no"}

// Show if greater than
{"operator": "greater", "field": "count", "value": 10}

// Show if any of multiple values (OR)
{
  "operator": "or",
  "conditions": [
    {"operator": "equal", "field": "type", "value": "A"},
    {"operator": "equal", "field": "type", "value": "B"}
  ]
}

// Show if multiple conditions met (AND)
{
  "operator": "and",
  "conditions": [
    {"operator": "equal", "field": "required", "value": true},
    {"operator": "greater", "field": "count", "value": 0}
  ]
}

// Check if multi-select contains value
{"operator": "contains", "field": "multi-select", "value": "option1"}

// Pattern match with regex
{"operator": "regex", "field": "code", "value": "^[A-Z]{3}\\d{3}$"}
```

### Testing Checklist
- [ ] Open notebook in separate tab (not Designer preview)
- [ ] Check field types match condition values
- [ ] Verify field IDs spelled correctly
- [ ] Test all condition paths
- [ ] Check required field behavior

---

**Document Status**: Complete Third Draft - Production Ready  
**Technical Verification**: Full code analysis completed  
**Production Testing**: Patterns verified in deployed notebooks  
**Cross-References**: Field type documentation, TemplatedStringField, BasicAutoIncrementer  
**Known Issues**: Designer preview, conditional validation, cross-form references  
**Roadmap Items**: Preview conditions, calculated fields, additional operators  
**Next Review**: After Designer preview conditions implemented

---

*End of Conditional Logic System Documentation - Ready for Project Knowledge*

<!-- concat:pattern:navigation -->
# Form Navigation and Data Flow - Third Draft Documentation
## Fieldmark/FAIMS3 Technical Reference

### Document Classification
- **Component Type**: Core System Behavior
- **Audience Tags**: {designer} {developer} {claude-code} {user}
- **Depth Levels**: {essential} {important} {comprehensive}
- **Version**: 1.0.0
- **Last Technical Verification**: August 2025
- **Key Discovery**: Navigation is completely decoupled from validation and sync

---

## 1. Executive Summary {essential} {designer}

### System Overview
Fieldmark's navigation system provides flexible form traversal through either vertical (scrolling) or horizontal (breadcrumb) patterns. Navigation operates independently of validation state and sync operations, allowing users to move freely between sections while data auto-saves to a draft database every 10 seconds. The system currently uses a two-database architecture (draft + production), with production data stored append-only for full history tracking. The draft stage will be eliminated to prevent data loss from forgotten drafts.

### Critical Architecture Decisions
1. **No Navigation Blocking**: Users can navigate freely regardless of validation errors
2. **Automatic Persistence**: Draft saves every 10 seconds (future: no 'drafts', immediate saves to 'production', rely on record history to revert errors)  
3. **Decoupled Sync**: Background synchronization never blocks navigation
4. **Simple State Management**: Navigation state lives in React components, not Redux
5. **Parent-Child Context**: Maintained through React Router location state

### Key Limitations
- No deep linking to specific sections
- No keyboard navigation shortcuts
- No multi-form progress aggregation
- No navigation guards or permission checks (handled at API level)
- Progress percentage doesn't persist across sessions
- Draft data doesn't sync until "Finish and..." clicked (being addressed)

---

## 2. Navigation Patterns {essential} {user}

### Primary Navigation Modes

#### Vertical Organization (Scrolling)
Best for linear data collection workflows:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Section 1: Basic Info   ‚îÇ
‚îÇ [Fields...]             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Section 2: Details      ‚îÇ
‚îÇ [Fields...]             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Section 3: Notes        ‚îÇ
‚îÇ [Fields...]             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
- All sections visible on single page
- Natural scrolling between sections
- Immediate visibility of all data
- Best for forms with <5 sections

#### Horizontal Organization (Breadcrumbs)
Best for complex multi-step workflows:
```
Home > Site > Details > [Current Section]

[Previous] Section 2 of 5 [Next]
```
- One section visible at a time
- Breadcrumb navigation between sections
- Minimal scrolling per section
- Best for forms with many sections or conditional logic

### Navigation State Tracking {important} {developer}

```javascript
// Component state (not Redux)
state = {
  activeStep: 2,              // Current section index
  view_cached: "details",     // Current section ID
  visitedSteps: Set(["basic", "details"]) // Visited sections
}
```

**Important**: Navigation position is NOT persisted - users return to first section on reload.

---

## 3. Data Flow Architecture {comprehensive} {developer}

### Save and Persistence Flow

```mermaid
graph TD
    A[User Input] --> B[Field onChange]
    B --> C[Formik State Update]
    C --> D{10 Second Timer}
    D -->|Timer Elapsed| E[Auto-save to Draft DB]
    D -->|User Navigates| F[Force Save to Draft DB]
    E --> G[PouchDB Draft Database]
    F --> G
    
    K[User Clicks<br/>'Finish and Close/New'] --> L[Move to Production DB]
    L --> M[PouchDB Production Database]
    M --> N[Delete from Draft DB]
    N --> O[Create New Revision]
    O --> P[Append-Only History]
    
    M --> H{Network Available?}
    H -->|Yes| I[Sync to CouchDB]
    H -->|No| J[Queue for Later Sync]
```

**Current System**: Two separate PouchDB instances
- **Draft Database**: Temporary storage, auto-saves every 10 seconds
- **Production Database**: Append-only record history after user clicks "Finish and..."

**Future System**: Single production database only
- Eliminate draft database entirely
- All changes save directly to production as new revisions
- "Finish and..." buttons become pure navigation
- Rely on record history viewer to review/revert changes

### Draft Storage Structure (To Be Eliminated) {important} {developer}

**Current: Separate Draft Database**
```json
{
  "_id": "drf-uuid-v4-here",  // Draft ID prefix
  "created": "2024-03-15T10:30:00Z",
  "updated": "2024-03-15T10:40:00Z",
  "fields": {
    "site-name": "Test Site",
    "description": "Archaeological survey"
  },
  "annotations": {},
  "attachments": {},
  "project_id": "project-123",
  "existing": null,  // Or {record_id, revision_id} for edits
  "type": "Survey",
  "field_types": {},
  "record_id": "rec-uuid"
}
```

**Issues with Draft System**:
- Stored in separate PouchDB instance from production
- Doesn't sync until user clicks "Finish and..."
- Often forgotten, leading to data loss
- Creates confusion about data state

### Future: Eliminating the Draft Stage {important} {designer}

**Current Problems with Draft System**:
- Users forget to click "Finish and..." leaving data in draft limbo
- Drafts don't sync until moved to production
- Confusion between draft and published states
- Data loss when drafts are abandoned

**Planned Changes** (High Priority):
- Remove draft database entirely
- Every change saves directly to production database
- Production database already append-only (keeps full history)
- "Finish and Close/New" buttons become navigation only
- Record history browser for viewing/reverting changes
- No more "draft" vs "published" distinction

---

## 4. Parent-Child Navigation {essential} {designer}

### Recommended Workflow

```mermaid
graph LR
    A[Create Parent] --> B[Save Parent]
    B --> C[Create Child 1]
    C --> D[Save & New Child]
    D --> E[Create Child 2]
    E --> F[Save & Return]
    F --> G[Complete Parent]
```

### Parent-Child Data Transfer {important} {developer}

#### Location State Structure
```javascript
{
  parent_record_id: "parent-123",
  parent_link: "/project/123/record/parent-123",
  field_id: "children-relationship",
  child_record_id: "child-456"
}
```

#### Sticky Fields Configuration {important} {designer}
Fields that should carry data between child records:
```json
{
  "excavation-unit": {
    "component-name": "TextField",
    "component-parameters": {
      "sticky": true,  // Preserves value for next child
      "name": "unit",
      "label": "Excavation Unit"
    }
  }
}
```

### Navigation Options After Save

**Current System** (with draft database):

| Button | Current Behavior | Future Behavior (no drafts) |
|--------|------------------|----------------------------|
| Finish and Close | Publishes to production + Returns to project | Just returns to project |
| Finish and New | Publishes to production + Creates new record | Just creates new record |
| Cancel | Discards draft + Returns | Returns (changes already saved) |
| Auto-save | Saves to draft DB only | Saves to production |

**For Child Records**:

| Action | Behavior | Use Case | Implementation |
|--------|----------|----------|----------------|
| Save & New Child | Publishes current child + Creates new with parent context | Multiple specimens | `navigateAfterSaveChild()` |
| Save & Return | Publishes child + Returns to parent form | Finished with children | Uses `parent_link` from state |
| Save & Continue | Saves to draft + Stays in form | More edits needed | Default behavior |

---

## 5. Progress Tracking {essential} {user}

### Progress Calculation {important} {developer}

```javascript
// Only counts visible, required fields
const progress = requiredFields
  .filter(field => isFieldVisible(field))
  .filter(field => hasValue(field))
  .length / totalVisibleRequired;
```

### Progress Display Patterns

#### Mobile Stepper
```
[<] Step 2 of 5 [>]
```
- Shows current position
- Total section count
- Previous/Next navigation

#### Desktop Stepper
```
[‚úì] Basic Info -- [!] Details -- [ ] Photos -- [ ] Review
```
- ‚úì = Visited, no errors
- ! = Visited, has errors  
- ‚ñ° = Not visited

### Progress Scope {important} {designer}

**Current Implementation**:
- Progress per individual record only
- Recalculates on every render
- Adjusts dynamically for conditional fields
- Does NOT persist across sessions

**Future Considerations**:
- Parent + children aggregate progress
- Multi-form notebook progress
- Persistent progress tracking

---

## 6. Validation and Navigation {essential} {designer}

### Non-Blocking Validation Pattern

```mermaid
graph TD
    A[User in Section 1] --> B[Has Validation Errors]
    B --> C{User Navigates}
    C -->|Allowed| D[Move to Section 2]
    D --> E[Section 1 Shows Error Badge]
    
    F[User Attempts Submit] --> G{Check All Errors}
    G -->|Has Errors| H[Jump to First Error]
    H --> I[Highlight All Errors]
    G -->|No Errors| J[Submit Record]
```

### Error Navigation Behavior {important} {developer}

```javascript
// Current: Non-blocking navigation
onChangeStepper(step) {
  // No validation check - always allows navigation
  this.setState({
    activeStep: step,
    view_cached: views[step]
  });
  this.updateVisitedSteps(views[step]);
}

// Future: Jump to error on submit
handleSubmit() {
  const errors = validateForm();
  if (errors.length > 0) {
    jumpToField(errors[0].fieldId);  // First error
    highlightAllErrors(errors);       // All errors visible
  }
}
```

### Visual Error Indicators

| Platform | Section with Errors | Required Fields | Completed Section |
|----------|-------------------|-----------------|-------------------|
| Desktop Tabs | Red dot with count | Asterisk (*) | Checkmark (‚úì) |
| Desktop Inline | Red text below header | Asterisk (*) | Green border |
| Mobile | Red badge on step | Red asterisk | Green checkmark |

---

## 7. Synchronization Behavior {important} {developer}

### Sync Independence Principle

Synchronization operates completely independently of navigation:

```javascript
// Navigation continues regardless of sync state
const canNavigate = true;  // Always true
const isSyncing = useSelector(state => state.project.isSyncing);
// isSyncing state available but never blocks navigation
```

### Background Sync Process

1. **Continuous Operation**: Sync runs whenever network available
2. **Queue Management**: Changes queued if offline
3. **No Navigation Impact**: Users work uninterrupted
4. **Visual Indicators**: Optional sync status display
5. **Conflict Resolution**: Handled separately in Control Centre

### Sync Status Communication {comprehensive} {developer}

```javascript
// Redux state available but not enforced
state.project.isSyncing     // true during active sync
state.project.lastSyncTime  // timestamp of last successful sync
state.project.syncQueue     // pending changes count
state.project.syncErrors    // any sync failures
```

---

## 8. Breadcrumb Navigation {important} {developer}

### Implementation Details

```typescript
// Breadcrumb truncation on mobile
const abbreviateTitle = (title: string) => {
  if (title.length > 10 && !not_xs) {
    return title.substring(0, 7) + '...';
  }
  return title;
};

// Responsive breadcrumb limits
<MuiBreadcrumbs
  maxItems={not_xs ? 4 : 2}        // Desktop: 4, Mobile: 2
  itemsAfterCollapse={not_xs ? 2 : 1}
  itemsBeforeCollapse={not_xs ? 0 : 1}
>
```

### Breadcrumb Behavior Rules

1. **Simple Navigation Only**: No state display or validation indicators
2. **Auto-save on Click**: Changes save to draft before navigation
3. **No Deep Linking**: Cannot link to specific sections via URL
4. **Responsive Display**: Collapses on mobile to save space

---

## 9. Edge Cases and Error Handling {comprehensive} {developer}

### Orphaned Child Records

**Scenario**: Parent record deleted while children exist

**Current Behavior**:
- Children remain in database (orphaned)
- Still accessible if ID known
- No automatic cleanup
- Manual intervention required

**Recommended Practice**: Always delete children before parent

### Missing Parent Context

**Scenario**: Creating child without parent

**Behavior**:
```javascript
// Without parent context
location.state = null;  // No parent_link or parent_record_id

// Record created but unlinked
{
  "relationship": null,  // No parent connection
  // Rest of child data...
}
```

**Recovery**: Must manually link via relationship field edit

### Navigation to Non-Existent Records

**Current Behavior**:
- No 404 handling
- Database error bubbles up
- White screen possible

**Planned Improvement**:
```javascript
// Future error boundary
if (!recordExists) {
  return <RecordNotFound />;
}
```

### Concurrent Edit Conflicts

**Scenario**: Same record edited on multiple devices

**Resolution**:
1. Both edits save locally
2. Sync creates conflict
3. Control Centre shows conflict
4. User chooses winning version
5. Navigation unaffected throughout

---

## 10. Performance Considerations {comprehensive} {developer}

### Navigation Performance Issues

| Issue | Impact | Mitigation |
|-------|--------|------------|
| Progress recalculates every render | CPU usage | Memoize calculation |
| All sections render initially | Memory spike | Implement lazy loading |
| Validation on every change | UI lag | Debounce validation |
| Large breadcrumb arrays | Render delay | Virtualize breadcrumbs |

### Optimization Patterns

```javascript
// Memoized progress calculation
const progress = useMemo(
  () => calculateProgress(fields, values),
  [fields, values]
);

// Debounced navigation
const debouncedNavigate = useMemo(
  () => debounce(handleNavigate, 300),
  []
);
```

---

## 11. Navigation Patterns Library {important} {designer}

### Pattern 1: Linear Survey Collection

```json
{
  "sections": ["site", "context", "finds", "photos", "notes"],
  "navigation": "inline",
  "validation": "soft",
  "progress": "per-section"
}
```
**Use When**: Sequential data collection, minimal backtracking

### Pattern 2: Hierarchical Recording

```json
{
  "parent": "excavation-unit",
  "children": ["contexts", "samples", "finds"],
  "navigation": "tabs",
  "sticky_fields": ["unit_id", "date"],
  "auto_save": true
}
```
**Use When**: One-to-many relationships, repeated child creation

### Pattern 3: Conditional Workflow

```json
{
  "sections": {
    "basic": {"always": true},
    "archaeological": {"condition": "type == 'archaeological'"},
    "ecological": {"condition": "type == 'ecological'"}
  },
  "navigation": "breadcrumb",
  "skip_hidden": true
}
```
**Use When**: Dynamic forms, role-based sections

---

## 12. Best Practices {essential} {designer}

### DO:
‚úÖ Create parent records before children  
‚úÖ Use sticky fields for repeated child data  
‚úÖ Configure validation as warnings when possible  
‚úÖ Test navigation on both mobile and desktop  
‚úÖ Keep section names short for mobile display  
‚úÖ Design for offline-first operation  
‚úÖ Remember to click "Finish and..." to move data to production (until draft system removed)

### DON'T:
‚ùå Rely on navigation blocking for validation  
‚ùå Create orphaned child records intentionally  
‚ùå Assume navigation state persists  
‚ùå Put critical actions in breadcrumbs  
‚ùå Exceed 5-7 sections without good reason  
‚ùå Forget drafts don't sync until published (current system)  

---

## 13. Migration Guide: Eliminating Draft Database {important} {developer}

### Current Two-Database System

```javascript
// Current: Separate draft and production databases
User enters data ‚Üí Draft DB (auto-save) ‚Üí Click "Finish" ‚Üí Production DB (append-only) ‚Üí Draft deleted
```

**Two PouchDB Instances**:
1. **Draft Database**: Temporary, not synced, auto-saves every 10 seconds
2. **Production Database**: Append-only history, syncs to CouchDB

### Future Single-Database System

```javascript
// Future: Direct to production, no draft stage
User enters data ‚Üí Production DB (immediate save as revision) ‚Üí History preserved
```

**Single PouchDB Instance**:
- All changes create new revisions immediately
- Full history available for review/revert
- Syncs continuously to CouchDB
- No draft/published distinction

### What Changes for Users

| Current Behavior | Future Behavior |
|-----------------|-----------------|
| Data in draft until "Finish and..." clicked | Data in production immediately |
| Drafts may be forgotten/lost | All changes preserved automatically |
| "Finish and Close" publishes + navigates | "Finish and Close" only navigates |
| Can't see draft data from other devices | All data visible after sync |
| Draft/Published status indicators | Single status: all data is "live" |

### Migration Requirements

1. **UI Changes**:
   - Remove draft badges/indicators
   - Change "Finish and..." button labels
   - Add revision history viewer
   - Add revert controls

2. **Backend Changes**:
   - Remove draft database instance
   - Update save logic to write to production
   - Ensure revision API supports browsing
   - Create revert mechanism

3. **User Communication**:
   - "Your data saves automatically"
   - "No more draft/publish steps"
   - "Use history to review changes"
   - Training on revision browser

---

## See Also

- [Notebook Structure Documentation](./notebook-structure.md) - Form, section, and field organization
- [Validation System](./validation.md) - Validation rules and error handling  
- [Conditional Logic Guide](./conditional-logic.md) - Dynamic form behavior
- [RelationshipField Documentation](./relationship-field.md) - Parent-child configuration
- [Synchronization Architecture](./sync.md) - Detailed sync behavior
- [Control Centre Guide](./control-centre.md) - Export and conflict resolution

---

**Document Version**: 1.0.0  
**Last Updated**: August 2025  
**Technical Verification**: Complete via 60+ Q&A with Claude Code  
**Production Status**: Ready for use

*Critical Note: This documentation reflects navigation as of August 2025. The system currently uses a two-database approach (draft + production), with production already using append-only storage. The draft database is planned for removal, after which all changes will save directly to the production database, eliminating draft-related data loss issues while maintaining the full revision history already available in production.*

<!-- concat:pattern:notebook-structure -->
# Notebook Structure: Forms, Sections, and Fields - Third Draft Documentation

## Overview

Fieldmark notebooks employ a three-tier hierarchical architecture organizing data collection into Forms (viewsets), Sections (views), and Fields. This structure scales from simple single-form checklists to sophisticated multi-entity recording systems with dozens of interconnected forms supporting complex parent-child relationships. The architecture operates without virtualization, rendering all fields simultaneously, which creates performance boundaries at approximately 50-100 fields per section. Critical architectural decisions‚Äîsuch as field ID uniqueness being global across the entire notebook‚Äîcascade through the system and cannot be modified after data collection begins without risk of data loss.

The system's distributed nature introduces unique behaviors: child records orphaned by soft-deleted parents remain accessible, circular parent-child relationships are possible without prevention, and malformed conditional logic can crash entire forms. Understanding these architectural realities alongside the flexible configuration options enables notebook designers to create robust data collection instruments whilst avoiding documented performance cliffs and structural pitfalls.

## Common Use Cases

### Archaeological Recording Hierarchies
‚Ä¢ **Context ‚Üí Feature ‚Üí Sample**: Excavation units containing features with associated samples
‚Ä¢ **Site ‚Üí Trench ‚Üí Context ‚Üí Find**: Multi-level spatial organisation with artefact recording  
‚Ä¢ **Survey ‚Üí Transect ‚Üí Observation ‚Üí Photo**: Systematic survey with structured observations
‚Ä¢ **Building ‚Üí Room ‚Üí Element ‚Üí Condition**: Architectural recording with condition assessments
‚Ä¢ **Area ‚Üí Structure ‚Üí Deposit ‚Üí Artefact Group ‚Üí Artefact**: Deep hierarchical excavation recording

### Heritage Management Workflows
‚Ä¢ **Property ‚Üí Building ‚Üí Element ‚Üí Issue ‚Üí Intervention**: Asset management with remediation tracking
‚Ä¢ **Site ‚Üí Monument ‚Üí Component ‚Üí Material ‚Üí Treatment**: Conservation planning hierarchies
‚Ä¢ **Landscape ‚Üí Character Area ‚Üí Feature ‚Üí Attribute**: Landscape characterisation studies
‚Ä¢ **Collection ‚Üí Box ‚Üí Object ‚Üí Component ‚Üí Analysis**: Museum cataloguing with conservation

### Ecological Survey Patterns  
‚Ä¢ **Site ‚Üí Plot ‚Üí Quadrat ‚Üí Species ‚Üí Individual**: Vegetation surveys with specimen tracking
‚Ä¢ **Transect ‚Üí Point ‚Üí Observation ‚Üí Measurement ‚Üí Photo**: Wildlife monitoring protocols
‚Ä¢ **Station ‚Üí Visit ‚Üí Sample ‚Üí Subsample ‚Üí Analysis**: Water quality monitoring
‚Ä¢ **Grid ‚Üí Cell ‚Üí Trap ‚Üí Capture ‚Üí Biometric**: Mark-recapture studies

### Geological Documentation
‚Ä¢ **Formation ‚Üí Member ‚Üí Bed ‚Üí Sample ‚Üí Analysis**: Stratigraphic recording
‚Ä¢ **Site ‚Üí Outcrop ‚Üí Unit ‚Üí Structure ‚Üí Measurement**: Structural geology mapping
‚Ä¢ **Core ‚Üí Section ‚Üí Interval ‚Üí Sample**: Drilling documentation

## Core Configuration

### Required Root Properties
```json
{
  "ui-specification": {
    "visible_types": ["form-1", "form-2"],  // REQUIRED: Controls navigation menu
    "viewsets": {                           // REQUIRED: Form definitions
      "form-1": { /* config */ }
    },
    "fviews": {                             // REQUIRED: Section definitions  
      "section-1": { /* config */ }
    },
    "fields": {                             // REQUIRED: Field specifications
      "field-1": { /* config */ }
    }
  }
}
```
**Critical**: Forms omitted from `visible_types` remain accessible via relationships but hidden from navigation menu. Empty or undefined `visible_types` shows all forms.

### Form (Viewset) Configuration

#### Required Properties
| Property | Type | Description | Default if Missing |
|----------|------|-------------|-------------------|
| `label` | string | Display name in navigation | Form ID used |
| `views` | array | Section IDs in display order | Empty array (blank form) |
| `publishButtonBehaviour` | string | Save button logic | `"always"` |

**Note**: Contrary to some documentation, missing `publishButtonBehaviour` does NOT cause failure‚Äîdefaults to `"always"`.

#### Optional Properties  
| Property | Type | Default | Description | Constraints |
|----------|------|---------|-------------|-------------|
| `hridField` | string | Falls back to "hrid" prefix | Field providing human-readable ID | Must reference existing field |
| `layout` | string | `"inline"` | Section presentation mode | `"inline"` or `"tabs"` only |
| `summary_fields` | array | `[]` | Fields shown in record lists | Gracefully handles missing fields |

**Removed Properties**: Documentation may reference `parent_link` or `is_root`‚Äîthese properties do not exist. Parent-child relationships are configured at field level using RelationshipField.

### Section (View) Configuration

#### Required Properties
| Property | Type | Description | Constraints |
|----------|------|-------------|-------------|
| `label` | string | Section heading displayed | Any string |
| `fields` | array | Field IDs in display order | Must reference existing fields; IDs globally unique |

**Critical**: Section IDs must be globally unique across ALL forms, not just within their form. Designer auto-generates IDs as `viewSetId-slugified-label`.

#### Optional Properties
| Property | Type | Default | Description | Behavior |
|----------|------|---------|-------------|----------|
| `condition` | object | null | Visibility condition | Malformed conditions crash form |
| `description` | string | null | Help text (not widely supported) | May not display |

### Field ID Requirements
**Critical Architecture Decision**: Field IDs must be globally unique across the ENTIRE notebook, not per section or form. The system maintains a single global namespace for all fields. Duplicate field IDs cause configuration overwrites without warning.

## Validation Rules

### Form-Level Validation

| Validation Type | Trigger | Behavior | Error Display | Recovery |
|-----------------|---------|----------|---------------|----------|
| Required fields | Save attempt | Blocks submission | Red badge on section, field error | Fill required fields |
| Field validation | Field blur | Non-blocking | Below field, section indicator | Correct field value |
| Schema compliance | JSON import | May fail silently | Console warnings only | Check browser console |
| Missing sections | Form render | Ignored | Console warning | Section omitted from display |
| Missing fields | Section render | Ignored | Console warning: "undefined field" | Field omitted from display |
| Malformed conditions | Form load | **CRASHES FORM** | White screen | Fix JSON, reimport |

### Section-Level Validation Aggregation

| Platform | Error Display | Visited Tracking | Required Indicator | Completion Status |
|----------|---------------|------------------|-------------------|-------------------|
| Desktop (inline) | Red text below section header | N/A | Asterisk in header | N/A |
| Desktop (tabs) | Red dot with count on tab | Checkmark when visited | Asterisk on tab | All tabs show status |
| iOS | Red badge on step | Green when visited | Red asterisk | Step counter (3/5) |
| Android | Red indicator | Tick mark | Bold asterisk | Fraction (3/5) |

### Configuration Validation Examples

```json
{
  "viewset-validation": {
    "views": ["section-1", "nonexistent-section"],  // Silently ignores missing
    "hridField": "missing-field",                    // Falls back to "hrid" prefix
    "publishButtonBehaviour": null                   // Defaults to "always"
  },
  "section-validation": {
    "fields": ["field-1", "undefined-field"],        // Logs warning, continues
    "condition": {
      "field": "nonexistent",                        // May crash at runtime
      "operator": "invalid"                          // WILL crash form
    }
  }
}
```

## Display Behaviour

### Desktop Rendering

#### Inline Layout Mode (Default)
- All sections render vertically without virtualization
- Performance degrades beyond 50-100 fields per section
- Smooth scroll anchors to section starts
- Section headers NOT sticky (browser limitation)
- Fields render in exact array order
- No lazy loading‚Äîentire form in DOM

#### Tabs Layout Mode
- Horizontal stepper with full section names
- Previous/Next buttons flank stepper
- Current section scales 1.2x for emphasis
- All sections still rendered (no lazy loading)
- Keyboard: Tab/Shift-Tab navigates sections
- Visited sections show checkmark indicator
- Error sections show red badge with count

### Mobile Rendering

#### iOS Behaviour
- Tabs compact to numbered stepper (1/5 format)
- Swipe gestures conflict with system gestures
- Momentum scrolling in inline mode
- Form header remains fixed
- Software keyboard pushes content up
- No viewport optimization for large forms

#### Android Behaviour  
- Material Design stepper in tabs mode
- Hardware back button behavior inconsistent
- FAB for save action (when implemented)
- Predictive back gesture may show previous section
- Pull-to-refresh not implemented
- Same performance limits as iOS

### Responsive Breakpoints
```javascript
// From useScreenSize.tsx
xs: < 576px     // Phone portrait
sm: 576-768px    // Phone landscape/small tablet
md: 768-992px    // Tablet
lg: 992-1200px   // Desktop
xl: > 1200px     // Large desktop
```

### Performance Characteristics
- **50-100 fields/section**: Noticeable input lag begins
- **100+ fields/section**: Significant degradation
- **200+ fields/section**: Near unusable
- **20-30 conditional fields**: Evaluation lag noticeable
- **No virtualization**: All fields always in DOM
- **No pagination**: Complete form always rendered

## Interaction Patterns

### Navigation Flows

#### Linear Progression (Tabs Mode)
1. User enters form at first section
2. Completes fields in current section  
3. Clicks "Next" or section tab
4. Validation occurs if `publishButtonBehaviour: "noErrors"`
5. Section marked as visited in `visitedSteps` Set
6. Hidden conditional sections do NOT count as visited
7. Save enabled based on publishButtonBehaviour logic

#### Non-Linear Access (Inline Mode)
1. All sections immediately visible (performance impact)
2. User scrolls to any section (no tracking)
3. Can fill sections in any order
4. No visited tracking in inline mode
5. Save button follows publishButtonBehaviour rules

#### Parent-Child Navigation
1. Parent form provides RelationshipField with `relation_type: "Child"`
2. "Add New [Type]" button navigates to child form
3. Parent context preserved in location state (not configuration)
4. Child automatically linked to parent
5. "Save & Return" navigates back to parent
6. "Save & Add Another" creates sibling
7. Parent can have multiple different child types via multiple RelationshipFields

### State Persistence
- Form state preserved during child creation
- Unsaved changes trigger browser beforeunload warning
- No auto-save implementation (documentation incorrect)
- Offline changes stored in PouchDB
- Navigation history maintained in browser

### publishButtonBehaviour Logic
```javascript
// Actual implementation
"always"    // Save always enabled (default)
"visited"   // Enabled when all visible sections visited
"noErrors"  // Enabled when no validation errors exist
```
**Note**: Conditional hidden sections don't block "visited" requirement.

## Conditional Logic Support

### Section-Level Conditions

```json
{
  "archaeological-section": {
    "label": "Archaeological Details",
    "fields": ["period", "phase", "finds"],
    "condition": {
      "operator": "equal",
      "field": "site-type",        // Must exist in same form
      "value": "archaeological"
    }
  }
}
```

### Complex Multi-Condition Logic

```json
{
  "specialist-section": {
    "label": "Specialist Recording",
    "fields": ["analysis-type", "specialist-notes"],
    "condition": {
      "operator": "and",
      "conditions": [
        {"operator": "equal", "field": "requires-specialist", "value": true},
        {"operator": "not-equal", "field": "status", "value": "preliminary"},
        {"operator": "or", "conditions": [
          {"operator": "equal", "field": "material", "value": "ceramic"},
          {"operator": "equal", "field": "material", "value": "lithic"}
        ]}
      ]
    }
  }
}
```

### Conditional Logic Limitations
- **Cannot reference other forms**: Only fields in same form accessible
- **Cannot reference parent fields**: No `$parent.field` syntax
- **Cannot check array properties**: No `.length` or indexed access
- **Malformed conditions crash form**: No error recovery
- **Performance degradation**: 20-30 conditional fields cause lag

### Performance Optimization
- Conditions compile to JavaScript functions once
- Re-evaluation ONLY when controller fields change
- Controller fields identified by presence in conditions
- Initial load evaluates all conditions
- Smart optimization skips non-controller field changes

## Data Storage and Export

### Database Structure (PouchDB/CouchDB)

```json
{
  "_id": "ctx_001_abc123",
  "type": "context",              // Form type from viewset ID
  "created": "2024-03-15T10:30:00Z",
  "created_by": "user@example.com",
  "updated": "2024-03-15T14:20:00Z",
  "updated_by": "user@example.com",
  "deleted": false,               // Soft delete flag
  "data": {
    "context-id": "CTX-001",
    "description": "Occupation layer",
    "finds": [                    // Child relationships
      {
        "record_id": "fnd_001_def456",
        "relation_type_vocabPair": ["is child of", "is parent of"]
      }
    ]
  }
}
```

### Parent-Child Data Structure
- **Parent ‚Üí Child**: One-to-many via RelationshipField
- **Child ‚Üí Parent**: Reference stored in child's relationship field
- **Orphaned children**: Remain when parent soft-deleted
- **Multiple child types**: Single parent can have different child forms
- **Circular relationships**: Possible, not prevented
- **No cascade delete**: Children must be manually managed

### CSV Export Format

#### File Structure
- Each form type exports as separate CSV file
- Filename: `formtype_export_timestamp.csv`
- Relationships flattened to string format

#### Relationship Encoding
```csv
_id,identifier,description,stratigraphic_relationships,finds
ctx001,CTX-001,Occupation layer,"cuts/ctx002;fills/ctx003","is parent of/fnd001;is parent of/fnd002"
```

#### Export Characteristics
- **Format**: `{vocabulary}/{record_id}` semicolon-delimited
- **Hierarchy lost**: Parent-child structure flattened
- **No re-import**: Relationships cannot be restored from CSV
- **Metadata preserved**: Timestamps and user info included
- **Empty fields**: Exported as empty strings, not null

### JSON Export Structure
```json
{
  "notebook_version": "1.0.0",
  "export_date": "2024-03-15T16:00:00Z",
  "records": {
    "context": [ /* array of context records */ ],
    "find": [ /* array of find records */ ]
  },
  "relationships": {
    "hierarchical": [ /* parent-child mappings */ ],
    "linked": [ /* peer relationships */ ]
  }
}
```

## Common Patterns

### Example 1: Simple Two-Level Hierarchy (Site ‚Üí Feature)
```json
{
  "ui-specification": {
    "visible_types": ["site-form", "feature-form"],
    "viewsets": {
      "site-form": {
        "label": "Site Record",
        "views": ["site-basic", "site-location"],
        "hridField": "site-id",
        "publishButtonBehaviour": "always",
        "layout": "inline"
      },
      "feature-form": {
        "label": "Feature Record", 
        "views": ["feature-details", "feature-measurements"],
        "hridField": "feature-number",
        "publishButtonBehaviour": "noErrors",
        "layout": "tabs"
      }
    },
    "fviews": {
      "site-basic": {
        "label": "Basic Information",
        "fields": ["site-id", "site-name", "recorder", "date"]
      },
      "site-location": {
        "label": "Location Details",
        "fields": ["grid-ref", "map-widget", "access-notes"]
      },
      "feature-details": {
        "label": "Feature Information",
        "fields": ["feature-number", "feature-type", "description", "parent-site"]
      },
      "feature-measurements": {
        "label": "Dimensions",
        "fields": ["length", "width", "depth", "volume"],
        "condition": {
          "operator": "not-equal",
          "field": "feature-type",
          "value": "surface-scatter"
        }
      }
    },
    "fields": {
      "parent-site": {
        "component-namespace": "faims-custom",
        "component-name": "RelatedRecordSelector",
        "type-returned": "faims-core::Relationship",
        "component-parameters": {
          "label": "Parent Site",
          "name": "parent-site",
          "related_type": "site-form",
          "relation_type": "Child",
          "multiple": false,
          "allowLinkToExisting": true
        }
      }
      // ... other field definitions
    }
  }
}
```
**Behavior**: Features link to sites via RelationshipField. Measurements section hidden for surface scatters. Forms outside `visible_types` still accessible via relationships.

### Example 2: Complex Multi-Branch Hierarchy
```json
{
  "ui-specification": {
    "visible_types": ["trench", "context", "find", "sample", "photo"],
    "viewsets": {
      "trench": {
        "label": "Trench",
        "views": ["trench-info", "trench-team"],
        "hridField": "trench-code",
        "publishButtonBehaviour": "visited",
        "layout": "tabs"
      },
      "context": {
        "label": "Context", 
        "views": ["context-basic", "context-matrix", "context-interpretation"],
        "hridField": "context-number",
        "publishButtonBehaviour": "noErrors",
        "layout": "tabs"
      },
      "find": {
        "label": "Find",
        "views": ["find-basic", "find-details"],
        "hridField": "find-number",
        "publishButtonBehaviour": "always"
      },
      "sample": {
        "label": "Sample",
        "views": ["sample-info", "sample-processing"],
        "hridField": "sample-number", 
        "publishButtonBehaviour": "always"
      },
      "photo": {
        "label": "Photograph",
        "views": ["photo-metadata", "photo-subjects"],
        "hridField": "photo-id",
        "publishButtonBehaviour": "always"
      }
    },
    "fviews": {
      "context-basic": {
        "label": "Basic Context Info",
        "fields": ["context-number", "context-type", "parent-trench", "description"]
      },
      "context-matrix": {
        "label": "Stratigraphic Matrix",
        "fields": ["stratigraphic-relationships", "physical-relationships"]
      },
      "context-interpretation": {
        "label": "Interpretation",
        "fields": ["interpretation", "period", "phase", "context-finds", "context-samples"],
        "condition": {
          "operator": "not-equal",
          "field": "context-type",
          "value": "unstratified"
        }
      }
      // ... additional view definitions
    },
    "fields": {
      "parent-trench": {
        "component-name": "RelatedRecordSelector",
        "component-parameters": {
          "label": "Parent Trench",
          "related_type": "trench",
          "relation_type": "Child",
          "multiple": false
        }
      },
      "context-finds": {
        "component-name": "RelatedRecordSelector",
        "component-parameters": {
          "label": "Finds from this Context",
          "related_type": "find",
          "relation_type": "Child",
          "multiple": true,
          "allowLinkToExisting": false
        }
      },
      "context-samples": {
        "component-name": "RelatedRecordSelector",
        "component-parameters": {
          "label": "Samples from this Context",
          "related_type": "sample",
          "relation_type": "Child",
          "multiple": true
        }
      },
      "stratigraphic-relationships": {
        "component-name": "RelatedRecordSelector",
        "component-parameters": {
          "label": "Stratigraphic Relationships",
          "related_type": "context",
          "relation_type": "is-related-to",
          "relation_linked_vocabPair": [
            ["cuts", "is cut by"],
            ["fills", "is filled by"],
            ["above", "below"]
          ]
        }
      }
      // ... additional field definitions
    }
  }
}
```
**Behavior**: Single parent (Context) has multiple child types (Find, Sample). Circular relationships possible between contexts. Interpretation section conditional on stratified contexts.

### Example 3: Performance-Optimized Structure
```json
{
  "ui-specification": {
    "visible_types": ["survey-point", "observations", "photos"],
    "viewsets": {
      "survey-point": {
        "label": "Survey Point",
        "views": ["point-location", "point-environment"],
        "layout": "inline",  // Better for mobile with few fields
        "publishButtonBehaviour": "always"
      },
      "observations": {
        "label": "Species Observations",
        "views": ["species-1", "species-2", "species-3", "species-4"],
        "layout": "tabs",  // Split large form across tabs
        "publishButtonBehaviour": "visited"
      },
      "photos": {
        "label": "Photo Record",
        "views": ["photo-capture"],  // Separate form for media
        "publishButtonBehaviour": "always"
      }
    },
    "fviews": {
      "species-1": {
        "label": "Common Species (1-25)",
        "fields": [/* 25 fields max for performance */]
      },
      "species-2": {
        "label": "Common Species (26-50)",
        "fields": [/* 25 fields max */],
        "condition": {
          "operator": "equal",
          "field": "record-all-species",
          "value": true
        }
      },
      "species-3": {
        "label": "Rare Species",
        "fields": [/* 20 fields */],
        "condition": {
          "operator": "equal",
          "field": "rare-species-present",
          "value": true
        }
      }
    }
  }
}
```
**Behavior**: Limits fields per section to maintain performance. Conditional sections reduce initial load. Media separated to dedicated form.

### Example 4: Conditional Section Cascade
```json
{
  "fviews": {
    "screening": {
      "label": "Initial Screening",
      "fields": ["material-type", "requires-detailed", "requires-specialist"]
    },
    "detailed-recording": {
      "label": "Detailed Recording",
      "fields": ["measurements", "surface-treatment", "manufacture"],
      "condition": {
        "operator": "equal",
        "field": "requires-detailed",
        "value": true
      }
    },
    "ceramic-analysis": {
      "label": "Ceramic Specialist Recording",
      "fields": ["fabric", "form", "decoration"],
      "condition": {
        "operator": "and",
        "conditions": [
          {"operator": "equal", "field": "material-type", "value": "ceramic"},
          {"operator": "equal", "field": "requires-specialist", "value": true}
        ]
      }
    },
    "lithic-analysis": {
      "label": "Lithic Specialist Recording", 
      "fields": ["raw-material", "technology", "use-wear"],
      "condition": {
        "operator": "and",
        "conditions": [
          {"operator": "equal", "field": "material-type", "value": "lithic"},
          {"operator": "equal", "field": "requires-specialist", "value": true}
        ]
      }
    }
  }
}
```
**Behavior**: Progressive disclosure based on screening decisions. Only evaluates conditions when controller fields change. Maximum 3-4 conditional sections recommended before performance impact.

## Troubleshooting Guide

### Common Issues and Solutions

| Issue | Symptoms | Diagnosis | Solution |
|-------|----------|-----------|----------|
| Form won't load | White screen, no content | Check console for condition compilation errors | Fix malformed conditions in JSON |
| Sections missing | Expected sections not visible | Condition evaluating false or section ID wrong | Verify controller field values and section IDs |
| Save button disabled | Cannot save despite filling fields | publishButtonBehaviour requirement not met | Check setting: "always", "visited", or "noErrors" |
| Fields not appearing | Blank sections | Field IDs don't exist or duplicated globally | Ensure globally unique field IDs |
| Slow form response | Lag when typing | Too many fields (>100) or conditionals (>30) | Split into multiple sections/forms |
| Lost form state | Data disappears on navigation | Browser storage disabled | Enable cookies/localStorage |
| Orphaned records | Children without parents | Parent deleted (soft delete) | Manually manage orphaned records |
| Duplicate IDs | HRID conflicts | Auto-increment not coordinated | Use device-specific prefixes |
| Export missing relationships | CSV lacks connections | Relationships flattened | Parse relationship strings manually |
| Import fails silently | JSON accepted but broken | Invalid field references | Check console for warnings |

### Debug Checklist

#### Configuration Validation
- [ ] All field IDs globally unique across entire notebook
- [ ] All section IDs globally unique across all forms  
- [ ] All referenced field IDs actually exist in fields object
- [ ] All referenced section IDs exist in fviews object
- [ ] No circular section references
- [ ] Conditions reference existing fields only

#### Performance Optimization
- [ ] < 50 fields per section (100 absolute max)
- [ ] < 20 conditional fields per form (30 absolute max)
- [ ] < 10 sections per form for tabs mode
- [ ] Media fields in separate forms where possible
- [ ] Complex calculations avoided in conditions

#### Data Integrity
- [ ] HRID fields configured for all forms
- [ ] HRID includes device/user prefix for uniqueness
- [ ] Parent-child relationships properly configured
- [ ] Soft-delete implications understood
- [ ] Export format meets analysis needs

#### Platform Testing
- [ ] Tested on target mobile devices
- [ ] Touch targets adequate size (44px minimum)
- [ ] Offline functionality verified
- [ ] Sync behavior understood

### Error Messages and Meanings

| Error Message | Location | Cause | Resolution |
|---------------|----------|-------|------------|
| "UI Spec had an undefined field with name: [field_name]" | Console | Field ID doesn't exist | Remove from section or create field |
| "Section ID already exists" | Designer | Duplicate section ID | Rename section |
| "Cannot read property 'operator' of undefined" | Console/Crash | Malformed condition | Fix condition syntax |
| "Maximum call stack exceeded" | Console/Crash | Circular condition reference | Remove circular dependency |
| "publishButtonBehaviour is undefined" | Not shown (defaults) | Missing property | Optional, defaults to "always" |
| "Cannot find viewset" | Console | Form ID mismatch | Check visible_types and viewset IDs |
| White screen (no error) | Form view | Condition compilation failed | Check all conditions in JSON |

### Common Configuration Mistakes

```json
// WRONG: Field IDs not globally unique
{
  "fviews": {
    "section-1": {"fields": ["description"]},
    "section-2": {"fields": ["description"]}  // ERROR: Duplicate field ID
  }
}

// WRONG: Malformed condition
{
  "condition": {
    "field": "my-field",  // ERROR: Missing operator
    "value": true
  }
}

// WRONG: Reference to non-existent field
{
  "condition": {
    "operator": "equal",
    "field": "nonexistent-field",  // ERROR: Field doesn't exist
    "value": "something"
  }
}

// CORRECT: Proper structure
{
  "fviews": {
    "section-1": {"fields": ["description-1"]},
    "section-2": {"fields": ["description-2"]}
  },
  "condition": {
    "operator": "equal",
    "field": "existing-field",
    "value": "expected-value"
  }
}
```

## Implementation Notes

### Technical Constraints
- **No virtualization**: All fields render simultaneously (React without windowing)
- **No lazy loading**: All sections in DOM even in tabs mode
- **Global namespace**: Field IDs must be unique across entire notebook
- **Section IDs global**: Must be unique across all forms, not just within form
- **No pagination**: Forms render completely regardless of size
- **Memory limits**: Device-dependent, typically issues beyond 200 fields total
- **Sync limitations**: Reciprocal relationships delayed until online
- **No conflict resolution**: Last-write-wins for concurrent edits

### Platform-Specific Limitations

#### Web Browser
- Sticky headers not supported consistently
- Performance varies significantly by browser
- Memory limits around 500-1000 fields total
- Local storage required for state persistence

#### iOS Application
- Tab gestures may conflict with system gestures
- Hardware keyboard support inconsistent
- Memory pressure earlier than desktop
- GPS/Camera features available

#### Android Application  
- Hardware back button behavior inconsistent
- Material Design compliance partial
- Performance similar to iOS
- Variable device capabilities

### Known Critical Issues
- **Malformed conditions crash forms**: No graceful error handling
- **Circular relationships possible**: No prevention mechanism
- **Orphaned children on delete**: Soft delete doesn't cascade
- **No schema migration**: Structure changes risk data loss
- **Silent failures common**: Missing fields/sections ignored
- **Performance cliffs undocumented**: No warnings before degradation
- **Designer GUI limitations**: Many features require JSON editing

### Designer Limitations Requiring JSON Editing
- Section reordering within forms
- Field reordering within sections  
- Complex conditional logic
- Vocabulary pairs for relationships
- Performance optimizations
- Some validation rules
- Export configurations

### Architecture Decisions and Rationale
- **Global field IDs**: Simplifies field reference resolution
- **No virtualization**: Simpler implementation, acceptable for intended scale
- **Soft delete only**: Preserves data integrity and audit trail
- **Client-side validation**: Enables offline functionality
- **Flat export format**: Maximum compatibility with analysis tools
- **Last-write-wins**: Simplest conflict resolution for distributed system

## Best Practices

### Structural Design
1. **Plan before building**: Structure cannot be safely modified after data collection
2. **Globally unique IDs**: Prefix field IDs with section/form identifier
3. **Shallow hierarchies**: Maximum 3-4 levels for usability
4. **Logical grouping**: 5-10 related fields per section
5. **Separate media forms**: Isolate photos/files for performance

### Performance Optimization
1. **Field limits**: Maximum 50 fields per section, 100 total per form
2. **Conditional restraint**: Maximum 20 conditional fields per form
3. **Tab mode for large forms**: Reduces visible field count
4. **Avoid deep nesting**: Each level adds complexity
5. **Test on target devices**: Mobile performance varies significantly

### User Experience
1. **Progressive disclosure**: Use conditions to show advanced fields
2. **Consistent navigation**: Maintain patterns across forms
3. **Clear labeling**: Section and form names describe content
4. **Logical flow**: Order sections by workflow
5. **Required field minimization**: Only mandate essential data

### Data Management  
1. **HRID configuration**: Include device/user prefix for uniqueness
2. **Relationship planning**: Document parent-child structures
3. **Export consideration**: Design with CSV limitations in mind
4. **Orphan management**: Plan for soft-delete scenarios
5. **Backup strategy**: Regular JSON exports for recovery

### Development Workflow
1. **Incremental building**: Test each form before adding next
2. **JSON validation**: Validate structure before import
3. **Performance testing**: Load test with realistic data volumes
4. **Platform testing**: Verify on all target devices
5. **Documentation**: Record structural decisions and rationale

### Team Coordination
1. **ID naming conventions**: Establish and document standards
2. **Section templates**: Create reusable section patterns
3. **Vocabulary standardization**: Agree on relationship terms
4. **Testing protocols**: Define acceptance criteria
5. **Change management**: Version control notebook definitions

## See Also

### Essential Prerequisites
- [Field Type Reference](./field-types.md) - Individual field configuration
- [RelationshipField Documentation](./relationship-field.md) - Parent-child and linked relationships
- [TemplatedStringField](./templated-string.md) - HRID generation

### Related Configuration Guides
- [Conditional Logic Guide](./conditional-logic.md) - Advanced condition syntax
- [Validation Framework](./validation.md) - Field validation rules
- [Designer Interface Guide](./designer.md) - GUI capabilities and limitations

### System Architecture
- [State Management](./state-management.md) - Redux store structure
- [Synchronization Architecture](./sync.md) - Multi-device coordination
- [Database Schema](./database.md) - PouchDB/CouchDB structure
- [Export Formats](./export.md) - CSV and JSON specifications

### Performance and Optimization
- [Performance Tuning Guide](./performance.md) - Optimization strategies
- [Mobile Deployment](./mobile.md) - Platform-specific considerations
- [Offline Capabilities](./offline.md) - Disconnected operation

### Troubleshooting Resources
- [Common Errors](./errors.md) - Error message reference
- [Migration Guide](./migration.md) - Schema change strategies
- [Debug Tools](./debug.md) - Browser developer tools usage

---

**Document Version**: 3.0  
**Last Updated**: August 2025  
**Validation**: Technical answers verified through 40-question investigation
**Status**: Production Ready

*Critical Warning: This documentation reflects actual system behavior as of August 2025, including known issues and limitations. Some behaviors differ from original design intentions. Test thoroughly in your deployment environment before production use.*

<!-- concat:pattern:patterns -->
# IMPORTANT - System-Wide Patterns for Documentation Consolidation

**Purpose**: Track system-level patterns, design philosophy, and common limitations discovered during field documentation that require centralized documentation in Phase 2.

**Last Updated**: January 2025  
**Phase**: Discovered during Phase 1 (Field Documentation), to be addressed in Phase 2 (Structural Documentation)

### 2.7 Static Configuration Limitation

**Pattern**: Most fields limited to static configuration with no dynamic data loading.

**Affected Fields**:
- Select/RadioGroup: Static options only
- AdvancedSelect: Static hierarchy only
- MultiSelect: Static options only
- Vocabularies: No external API loading
- Validation: No async validation

**Missing Capabilities**:
- No REST API integration for options
- No conditional vocabulary loading
- No user-role-based options
- No location-based filtering
- No progressive loading

**Documentation Needed**:
- Static configuration requirements
- Workarounds for dynamic needs
- Update strategies for vocabularies
- Implications for long projects

---

## 1. Core System Architecture Patterns

### 1.1 Distributed, Offline-First Architecture

**Pattern**: All field types operate within a distributed, offline-capable system with eventual consistency.

**Implications Across Fields**:
- Relationships: Reciprocal updates delayed until sync
- Auto-incrementers: Sequence conflicts when multiple offline users
- Validation: Client-side only, no server verification
- Media fields: Local storage until sync opportunity
- All fields: Last-write-wins conflict resolution

**Documentation Needed**:
- "Working with Distributed Data Collection" guide
- Sync behaviour expectations
- Conflict resolution strategies
- Multi-user coordination patterns
- Why last-write-wins is intentional, not a bug

### 1.2 Schema Evolution Flexibility

**Pattern**: System intentionally allows post-deployment schema changes to accommodate emergent field research.

**Implications Across Fields**:
- Type changes can break existing data (string‚Üínumber)
- Multiple‚Üísingle loses data silently
- Validation additions may invalidate existing records
- Vocabulary modifications don't update existing data
- Required fields added later create incomplete records

**Documentation Needed**:
- "Schema Evolution and Field Research Reality" guide
- Safe vs breaking changes matrix
- Backup and versioning strategies
- Testing changes before deployment
- When to modify vs start fresh

### 1.4 Auto-Increment Coordination

**Pattern**: Auto-increment ranges require manual coordination between devices.

**Critical Issues**:
- Local-only storage (not synchronized)
- No device-specific namespacing
- No conflict detection for duplicates
- No range sharing mechanism
- Complete reliance on human coordination

**Impact on System**:
- Duplicate IDs when ranges overlap
- HRIDs can become non-unique
- Relationships may reference wrong records
- Data integrity compromised silently

**Documentation Needed**:
- Multi-device coordination protocols
- Range allocation strategies
- HRID uniqueness patterns
- Team communication requirements
- Recovery from duplicate scenarios

**Pattern**: Not all configuration options available in Designer GUI; JSON editing often required.

**Affected Fields**:
- RelationshipField: Vocabulary pairs
- AdvancedSelect: Hierarchy structure
- MapFormField: Advanced map options
- Conditional logic: Complex conditions
- Validation: Custom rules

**Documentation Needed**:
- "Designer Limitations and JSON Workflows" guide
- Which features require JSON
- Safe JSON editing practices
- Migration and validation tools

---

## 2. Common Technical Limitations

### 2.1 Performance Boundaries

**Pattern**: All complex fields have undocumented performance cliffs and hard-coded limits.

**Specific Thresholds**:
- Relationships: 50 comfortable, 200 unusable
- Select/MultiSelect: 100 options degraded
- AdvancedSelect: 100 nodes noticeable lag, 1000 nodes frozen
- TakePhoto: 20 photos performance cliff, 50 hard failure
- MapFormField: GPU acceleration actively disabled
- TakePoint: Continuous GPS causes battery drain
- Conditional logic: Multiple controllers lag

**Hard-Coded Limits Discovered**:
- TakePhoto: Maximum 20 images enforced
- AdvancedSelect: 300px fixed height viewport
- MapFormField: Single feature limitation (auto-clears previous)

**Documentation Needed**:
- Performance planning guide with specific thresholds
- Hard limit documentation
- Optimisation strategies
- Alternative patterns for large datasets
- Battery impact warnings for GPS fields

### 2.2 Validation Limitations

**Pattern**: Validation is limited to Yup schema, no custom functions. Type declarations often don't match enforcement.

**Common Gaps**:
- No cross-field validation
- No async validation
- No conditional requirements
- No mathematical validation
- No relationship consistency checks
- Generic error messages only

**Type Declaration vs Enforcement Mismatches**:
- ControlledNumber: Declares "faims-core::Integer" but accepts decimals
- BasicAutoIncrementer: Returns strings despite numeric appearance
- Designer enforces empty strings where nulls expected
- Mixed string/integer storage prevents field type changes

**Documentation Needed**:
- Validation capabilities matrix
- Type enforcement reality vs declarations
- Workaround patterns
- Error message customisation

### 2.3 Database API Access & Re-importation

**Pattern**: After sync, data is in CouchDB and accessible via standard APIs, but lacks guardrails.

**The Real Challenge**:
- CouchDB API allows direct database manipulation
- External systems (RSpace ELN, QGIS) can read/write
- No import validator to ensure schema compliance
- Missing JSON schema documentation
- Risk of database corruption through malformed imports

**Integration Points Under Development**:
- RSpace ELN (cloud-based electronic lab notebook)
- QGIS (desktop GIS software)
- Other external systems via CouchDB API

**What's Needed**:
- JSON database schema documentation
- Import validators/guardrails
- Schema requirements documentation
- API usage guidelines
- Round-trip integrity checks

**This is NOT about**:
- CSV re-import (that's a separate issue)
- Export format limitations
- File format conversions

**Documentation Needed**:
- CouchDB JSON schema specifications
- Field type requirements in database
- Relationship integrity rules
- Required properties per document type
- API best practices for external systems

### 2.4 CSV Export Limitations (Separate Issue)

**Pattern**: CSV exports lose structure and cannot be re-imported with relationships intact.

**Specific Issues**:
- Relationships export as strings, can't re-import
- Hierarchies flatten
- Metadata (annotations) lost
- Media files referenced not embedded
- No CSV import that reconstructs relationships

**This is separate from CouchDB API access** - even with API access, CSV round-trip doesn't work.

**Documentation Needed**:
- CSV format specifications
- Manual reconstruction procedures
- Which data is preserved vs lost

**Pattern**: Multiple fields fail silently without user feedback.

**Common Silent Failures**:
- FileUploader: Upload errors give no feedback
- TakePhoto: Size/count parameters silently ignored
- Select/RadioGroup: Validation errors not displayed
- AdvancedSelect: Cannot clear selection once made
- MapFormField: No validation error display
- Configuration parameters accepted but ignored

**Security Gaps**:
- FileUploader: No file type validation or virus scanning
- FileUploader: Accepts executable files without warning
- TakePhoto: EXIF data stripped inconsistently
- No MIME type restrictions enforced

**Documentation Needed**:
- Error handling expectations
- Security considerations guide
- Workarounds for missing feedback
- Data validation best practices

### 2.5 Component Architecture Issues

**Pattern**: Component duplication and architectural confusion creates inconsistency.

**Specific Issues**:
- TextField/FAIMSTextField duality with unclear deprecation
- MultipleTextField vs TextField with multiline:true
- Component reference bugs (LocationPermissionIssue shown for camera)
- TakePhoto and FileUploader completely separate despite overlap
- AdvancedSelect recursive rendering without optimization

**Rendering Problems**:
- AdvancedSelect: Renders entire tree immediately (no virtualization)
- MapFormField: GPU acceleration disabled harming performance
- TakePhoto: Memory leaks in preview generation loops
- No lazy loading across complex components

**Documentation Needed**:
- Component selection decision tree
- Deprecation roadmap
- Performance implications of component choices
- Memory management strategies

### 3.1 Mobile-Desktop Divergence

**Pattern**: Significant capability differences between platforms.

**Common Issues**:
- Fixed widths break mobile (500px)
- Touch targets too small (<44px)
- Camera/GPS mobile-only
- Keyboard types vary
- Offline behaviour differs

**Documentation Needed**:
- Platform capability matrix
- Responsive design requirements
- Progressive enhancement strategies

### 3.2 Accessibility Systematic Gaps

**Pattern**: Most fields fail WCAG 2.1 standards.

**Common Failures**:
- Touch targets undersized
- Missing ARIA labels
- No keyboard navigation
- Poor error announcement
- Color contrast issues

**Documentation Needed**:
- Accessibility compliance status
- Workarounds for critical issues
- Roadmap for improvements

---

## 4. Design Philosophy Implications

### 4.1 Flexibility Over Rigidity

**Principle**: System prioritizes adaptability for emergent research over data integrity guarantees.

**Trade-offs**:
- Can adapt to discoveries BUT can break existing data
- Can modify in field BUT requires careful planning
- Can work offline BUT creates sync conflicts
- Can handle complexity BUT has performance limits

**Documentation Approach**:
- Acknowledge trade-offs explicitly
- Provide clear guidance on risks
- Offer mitigation strategies
- Don't hide limitations

### 4.2 Archaeological/Research-Driven Design

**Principle**: Features designed for research realities, not ideal scenarios.

**Examples**:
- Annotations for field notes (margins)
- Uncertainty flags throughout
- Flexible relationships
- Schema evolution support
- Offline-first architecture

**Documentation Approach**:
- Explain research scenarios
- Provide discipline-specific examples
- Acknowledge messiness of fieldwork

---

## 5. Repeated Warnings Across Fields

### Common Warnings to Centralize

1. **"Changes to this configuration may affect existing data"**
2. **"Performance degrades with large datasets"**
3. **"Offline edits may create conflicts requiring resolution"**
4. **"Designer cannot configure this - JSON editing required"**
5. **"Mobile experience differs from desktop"**
6. **"Validation occurs client-side only"**
7. **"Export format requires manual reconstruction"**
8. **"Battery usage may be significant"** (GPS/camera fields)
9. **"Error messages may not display properly"** (choice fields)

### Field Category Patterns

**Choice Fields (RadioGroup, Select, Checkbox) - Shared Limitations:**
- All lack proper error display (varying degrees)
- All missing comprehensive accessibility support
- All limited to static options (no dynamic loading)
- All have performance issues with large option sets
- Designer cannot preview any of them properly
- None support field type conversion after deployment

**Media Fields (TakePhoto, FileUploader) - Shared Issues:**
- Security validation gaps
- Silent failure modes
- Metadata handling inconsistencies
- Performance limits undocumented

**Location Fields (MapFormField, TakePoint) - Common Problems:**
- Battery impact not documented
- GPS accuracy variations
- Metadata export limitations
- Platform-specific behaviors

### Field-Specific Variations

Track which warnings apply to which fields:
- Performance warnings: Relationship, Select, MultiSelect, AdvancedSelect
- JSON-only warnings: Relationship, AdvancedSelect, MapFormField
- Mobile issues: All fields with complex UI
- Export limitations: Relationship, AdvancedSelect, Media fields

---

## 6. Documentation Structure Recommendations

### Phase 2 Priorities

1. **System Architecture Documentation** (Week 1)
   - Distributed systems guide
   - Schema evolution guide
   - Platform capabilities matrix

2. **Common Patterns Documentation** (Week 2)
   - Performance planning
   - Validation strategies
   - Export/import workflows

3. **Field Documentation Consolidation** (Weeks 3-4)
   - Remove redundant warnings
   - Add cross-references to system docs
   - Standardize terminology
   - **Unified documentation for related fields** (e.g., all date fields together)

### Cross-Referencing Strategy

Each field should reference system docs:
```markdown
> **System Consideration**: This field operates within Fieldmark's 
> distributed architecture. See [Working with Distributed Data] for 
> sync behaviour and conflict resolution.
```

### Warning Standardization

Create standard warning blocks:
```markdown
> ‚ö†Ô∏è **Schema Change Warning**: Modifying this configuration after 
> data collection may result in data loss. See [Schema Evolution Guide] 
> for safe change practices.
```

## 10. Compound Failure Modes

### Systemic Interactions

When multiple documented issues combine, they create emergent failure modes worse than individual problems:

1. **Auto-increment + Relationships**: Duplicate IDs from poor coordination corrupt relationship networks
2. **Type Mismatches + Schema Evolution**: String/integer inconsistencies prevent field type changes
3. **Performance + Offline**: Large forms become unusable precisely when offline (no server optimization)
4. **Silent Failures + Distributed System**: Errors propagate across devices without detection
5. **Export Limitations + Validation**: Can't reimport exported data due to validation changes

### Cascading Effects

**Example Cascade**: 
1. Auto-increment conflict creates duplicate IDs
2. Relationships reference wrong records
3. Export flattens relationship structure
4. Can't detect error in CSV
5. Reimport fails or corrupts data further

### Risk Multiplication

Individual bugs become critical when combined:
- 10 relationship fields √ó 30 relationships each = 300 metadata fetches
- Add 5 MultiSelect fields with 50 options = 400+ UI elements
- Add offline sync overhead = 30+ second load times
- Result: Form unusable in field conditions

**Documentation Needed**:
- Common failure cascades
- Risk assessment matrices
- Mitigation strategies for compound issues
- Testing protocols for interaction effects

---

## 11. Questions for Technical Team

### Architecture Clarifications Needed

1. Is last-write-wins the only conflict resolution strategy?
2. Are there any server-side validations we're missing?
3. What's the roadmap for Designer GUI enhancements?
4. Are performance thresholds being addressed?
5. Is WCAG compliance planned?

### Documentation Priorities

1. Which limitations are being fixed vs documented?
2. What level of technical detail for JSON editing?
3. Should we document workarounds or wait for fixes?
4. How much about future roadmap to include?

---

## 8. Action Items for Consolidation

### Immediate (During Field Documentation)
- [ ] Flag system patterns in each field doc
- [ ] Track repeated warnings
- [ ] Note Designer limitations
- [ ] Document performance thresholds

### Phase 2 (Structural Documentation)
- [ ] Create system architecture guides
- [ ] Consolidate common warnings
- [ ] Build cross-reference network
- [ ] Standardize terminology

### Phase 3 (Refinement)
- [ ] Remove redundancy from field docs
- [ ] Ensure consistent messaging
- [ ] Validate all cross-references
- [ ] Test with users

---

## 9. Critical Insights Summary

### What We've Learned

1. **The system is well-architected for research** but implementation has gaps
2. **Flexibility is intentional** but requires user education
3. **Distributed behaviour is complex** but necessary for fieldwork
4. **Performance limits exist** and many are hard-coded, not configurable
5. **Platform differences are significant** but manageable with planning
6. **Type enforcement is inconsistent** creating migration barriers
7. **Silent failures are common** requiring defensive design
8. **Security gaps exist** particularly in file handling
9. **Choice fields share systematic problems** suggesting architectural issues
10. **Battery and resource impacts** are undocumented for field deployment

### Documentation Philosophy

- Be honest about limitations and hard limits
- Explain the why behind design choices
- Provide practical workarounds
- Document battery and performance impacts explicitly
- Warn about security considerations
- Focus on research success, not just technical correctness
- Group similar limitations (e.g., all choice fields)

### Emerging Meta-Patterns

1. **Implementation vs Architecture Gap**: Good architecture undermined by implementation bugs
2. **Progressive Degradation**: Fields work well up to specific thresholds, then fail dramatically
3. **Desktop-First Design**: Mobile often an afterthought despite "mobile-first" claims
4. **Validation Display Crisis**: Systematic failure across multiple field categories
5. **Configuration Ignored**: Many parameters accepted but not honored

---

*This tracking document should be continuously updated as more patterns emerge during field documentation. It will form the foundation for Phase 2's structural documentation work.*

*Last comprehensively updated: January 2025*
*Sessions reviewed for patterns:*
- RelationshipField discovery and documentation
- AdvancedSelect complete documentation  
- MultiSelect documentation research
- RichText field discovery (revealed StaticImage doesn't exist)
- RadioGroup, Select, Checkbox documentation
- TakePhoto, FileUploader, MapFormField, TakePoint documentation
- ControlledNumber documentation
- BasicAutoIncrementer synchronization analysis
- Date/Time fields unified documentation
- Choice fields consolidated analysis
- All text fields (TextField, MultilineText, Email, TemplatedString, QRCodeFormField, Address)
- All number fields (NumberField, NumberInput, ControlledNumber, BasicAutoIncrementer)

*Total fields analyzed: ALL existing field types (24 total - StaticImage was a hallucination)*


<!-- ============================================ -->
<!-- TECHNICAL REFERENCES -->
<!-- ============================================ -->


<!-- concat:reference:component-namespace-reference -->
# Component Namespace Reference
## Critical Configuration for All Fieldmark v3 Components

### Quick Reference Table

| Component Category | Namespace | Components |
|-------------------|-----------|------------|
| **Text Fields** | `formik-material-ui` | TextField, MultipleTextField |
| **Custom Text** | `faims-custom` | SingleLineTextField, TemplatedStringField, Address, QRCodeFormField |
| **Number Fields** | `faims-custom` | NumberField, BasicAutoIncrementer |
| **DateTime Fields** | `faims-custom` | DateTime, DateTimeNow |
| **Selection Fields** | `faims-custom` | Checkbox, MultiSelect, RadioGroup, Select, AdvancedSelect |
| **Media Fields** | `faims-custom` | TakePhoto, FileUploader |
| **Location Fields** | `faims-custom` / `mapping-plugin` | TakePoint (custom) / MapFormField (plugin) |
| **Relationship** | `faims-custom` | RelatedRecordSelector |

### The Golden Rule

**When in doubt, use `faims-custom`**

Over 90% of Fieldmark components use the `faims-custom` namespace. Only basic text fields use `formik-material-ui`.

### Complete Component List by Namespace

#### faims-custom Components

**Text & String Fields:**
- `SingleLineTextField` - Basic text input
- `TemplatedStringField` - Auto-generated from template
- `Address` - Structured address with components
- `QRCodeFormField` - Barcode/QR scanner

**Number Fields:**
- `NumberField` - Numeric input with validation
- `BasicAutoIncrementer` - Auto-incrementing identifier

**Date & Time Fields:**
- `DateTime` - Date and time picker
- `DateTimeNow` - Capture current timestamp

**Selection Fields:**
- `Checkbox` - Boolean toggle
- `MultiSelect` - Multiple choice selection
- `RadioGroup` - Single choice from options (DEPRECATED)
- `Select` - Dropdown single selection
- `AdvancedSelect` - Hierarchical tree selection (BETA)

**Media Fields:**
- `TakePhoto` - Camera capture
- `FileUploader` - File upload

**Location Fields:**
- `TakePoint` - GPS coordinate capture (`faims-custom`)
- `MapFormField` - Map-based location selection (`mapping-plugin`)

**Relationship Fields:**
- `RelatedRecordSelector` - Link to other records

#### formik-material-ui Components

**Basic Text Only:**
- `TextField` - Standard Material-UI text field
- `MultipleTextField` - Multi-line text area

### Common Namespace Errors

#### Error: "Component not found: [component-name]"

**Cause 1: Wrong Namespace**
```json
// ‚ùå WRONG
{
  "component-namespace": "material-ui",
  "component-name": "Select"
}

// ‚úÖ CORRECT
{
  "component-namespace": "faims-custom",
  "component-name": "Select"
}
```

**Cause 2: Missing Namespace**
```json
// ‚ùå WRONG - No namespace specified
{
  "component-name": "Checkbox"
}

// ‚úÖ CORRECT - Namespace required
{
  "component-namespace": "faims-custom",
  "component-name": "Checkbox"
}
```

**Cause 3: Typo in Namespace**
```json
// ‚ùå WRONG - Common typos
{
  "component-namespace": "faims-custom-ui"     // Extra suffix
  "component-namespace": "faims_custom"        // Underscore
  "component-namespace": "faimsCustom"         // Camel case
  "component-namespace": "FAIMS-CUSTOM"        // Wrong case
}

// ‚úÖ CORRECT - Exact spelling
{
  "component-namespace": "faims-custom"        // All lowercase, hyphenated
}
```

### Case Sensitivity Rules

Component names are **STRICTLY CASE-SENSITIVE**:

| ‚ùå Wrong | ‚úÖ Correct | Notes |
|---------|-----------|-------|
| checkbox | Checkbox | Capital C |
| multiselect | MultiSelect | Capital M and S |
| radiogroup | RadioGroup | Capital R and G |
| select | Select | Capital S |
| advancedselect | AdvancedSelect | Capital A and S |
| datetime | DateTime | Capital D and T |
| datetimenow | DateTimeNow | Capital D, T, and N |
| numberfield | NumberField | Capital N and F |
| takepoint | TakePoint | Capital T and P |
| takephoto | TakePhoto | Capital T and P |

### Designer Name vs JSON Name

The Designer UI uses different display names than the JSON component names:

| Designer Shows | JSON Uses | Namespace |
|---------------|-----------|-----------|
| "Checkbox" | `Checkbox` | `faims-custom` |
| "Select Multiple" | `MultiSelect` | `faims-custom` |
| "Select one option" | `RadioGroup` | `faims-custom` |
| "Select Field" | `Select` | `faims-custom` |
| "Select Field (Hierarchical)" | `AdvancedSelect` | `faims-custom` |
| "Text Field" | `TextField` | `formik-material-ui` |
| "Text Area" | `MultipleTextField` | `formik-material-ui` |
| "Number Input" | `NumberField` | `faims-custom` |
| "Date and Time" | `DateTime` | `faims-custom` |
| "Current Date/Time" | `DateTimeNow` | `faims-custom` |
| "Take Photo" | `TakePhoto` | `faims-custom` |
| "Upload File" | `FileUploader` | `faims-custom` |
| "GPS Point" | `TakePoint` | `faims-custom` |
| "Map Location" | `MapFormField` | `mapping-plugin` |

### Namespace Evolution

#### Historical Context
- **v1-v2**: Mixed namespaces (`material-ui`, `formik-material-ui`, custom components)
- **v3**: Standardized on `faims-custom` for most components
- **Current**: Two namespaces only (`faims-custom` and `formik-material-ui`)

#### Migration Notes
If migrating from older notebooks:
- `material-ui` ‚Üí `formik-material-ui` (for TextField only)
- `faims-custom-ui` ‚Üí `faims-custom`
- Custom component names ‚Üí Check current list

### Debugging Namespace Issues

#### Quick Diagnostic Steps

1. **Check exact spelling**: `faims-custom` (all lowercase, hyphen)
2. **Verify case**: Component names use PascalCase
3. **Confirm pairing**: Component name matches namespace
4. **Test minimal**: Try simplest possible configuration

#### Test Configuration
```json
{
  "test-field": {
    "component-namespace": "faims-custom",
    "component-name": "Checkbox",
    "type-returned": "faims-core::Bool",
    "component-parameters": {
      "name": "test-field",
      "label": "Test"
    }
  }
}
```

### Platform-Specific Notes

#### Web/Desktop
- All namespaces work identically
- No platform-specific namespace requirements

#### iOS/Android  
- Same namespace requirements
- Native components still use faims-custom namespace
- No special mobile namespaces

#### PWA
- Identical namespace behavior
- Offline capability doesn't affect namespaces

### Best Practices

1. **Always specify namespace** - Never omit even if it seems to work
2. **Copy exact names** - Don't type manually, copy from reference
3. **Use consistent format** - All fields in a form should follow same pattern
4. **Check Designer output** - Designer always uses correct namespace
5. **Validate early** - Test one field before building entire form

### Common Patterns

#### Standard Field Definition
```json
{
  "field-name": {
    "component-namespace": "faims-custom",
    "component-name": "ComponentName",
    "type-returned": "faims-core::Type",
    "component-parameters": {
      // parameters
    }
  }
}
```

#### When to Use formik-material-ui
Only for these specific cases:
- Basic single-line text input without special features
- Multi-line text area without special features
- When explicitly avoiding custom validation or behavior

### Error Prevention Checklist

- [ ] Namespace is exactly `faims-custom` or `formik-material-ui`
- [ ] Component name matches reference table exactly
- [ ] Case sensitivity verified (PascalCase for components)
- [ ] No typos in namespace (hyphen not underscore)
- [ ] Namespace specified for every field
- [ ] Designer name not used in JSON

### Related Documentation

- Individual field references for component parameters
- Type-returned reference for data types
- Validation reference for validation schemas
- Designer documentation for UI mapping

### Version
Last updated: 2025-09-03
Applies to: Fieldmark v3 (all versions)
Component library: @faims3/data-model

<!-- concat:reference:meta-properties-reference -->
# Meta Properties Reference
## Universal Metadata Configuration for All Fieldmark v3 Fields

### Overview

The `meta` property provides standardized metadata options that work identically across ALL field types. These properties control annotations, uncertainty markers, persistence, and display behaviors.

### Standard Meta Structure

```json
{
  "field-name": {
    "component-namespace": "...",
    "component-name": "...",
    "type-returned": "...",
    "component-parameters": {...},
    "validationSchema": [...],
    "initialValue": "...",
    "meta": {
      "annotation": {
        "include": true,
        "label": "Notes"
      },
      "uncertainty": {
        "include": true,
        "label": "Uncertain"
      },
      "persistent": false,
      "displayParent": false
    }
  }
}
```

### Meta Properties Explained

#### annotation
**Purpose**: Adds a free-text notes field alongside the main field

**Structure**:
```json
"annotation": {
  "include": true,    // Boolean: whether to show annotation field
  "label": "Notes"    // String: label for the annotation field
}
```

**Behavior**:
- Creates an additional text input below the main field
- Stores text in a parallel data structure
- Exports as separate column in CSV
- No validation applied to annotation text
- No character limit

**Common Labels**:
- "Notes" - General purpose
- "Comments" - General purpose
- "Annotation" - Default if label omitted
- "[Field] notes" - Context-specific (e.g., "Location notes")
- "Additional information" - Verbose option

#### uncertainty
**Purpose**: Adds a checkbox to mark data as uncertain/questionable

**Structure**:
```json
"uncertainty": {
  "include": true,        // Boolean: whether to show uncertainty checkbox
  "label": "Uncertain"    // String: label for the checkbox
}
```

**Behavior**:
- Creates a checkbox beside/below the main field
- Stores boolean value in parallel structure
- Exports as separate boolean column
- When checked, may trigger visual indicators (field-dependent)
- No validation impact (uncertain data still validates)

**Common Labels**:
- "Uncertain" - Default
- "?" - Minimal
- "Questionable" - Explicit
- "Approximate" - For measurements
- "Needs verification" - Process-oriented
- "Low confidence" - Confidence scale

#### persistent
**Purpose**: Controls whether field value persists across record creation

**Values**:
- `true` - Field retains value when creating new record
- `false` - Field clears to initialValue (default)

**Structure**:
```json
"persistent": true  // or false
```

**Use Cases for persistent: true**:
- Location fields (likely same site)
- Date fields (same day's work)
- Team member fields
- Project phase fields
- Site/area identifiers

**Use Cases for persistent: false**:
- Unique identifiers
- Measurements
- Observations
- Photos
- Specimen data

#### displayParent
**Purpose**: Shows parent record context in related record forms

**Values**:
- `true` - Display parent record information
- `false` - Hide parent context (default)

**Structure**:
```json
"displayParent": true  // or false
```

**Behavior**:
- Only relevant for fields in child records
- Shows parent record's human-readable ID
- Helps maintain context during data entry
- No impact on data storage

### Designer Integration

The Designer interface provides toggles for:
- **Annotation** - Maps to `meta.annotation.include`
- **Uncertainty** - Maps to `meta.uncertainty.include`

The Designer does NOT provide controls for:
- Custom annotation labels (uses "Annotation")
- Custom uncertainty labels (uses "?")
- `persistent` property
- `displayParent` property

These require JSON editing.

### Default Values

If `meta` property is omitted entirely:
```json
// These defaults are applied:
"meta": {
  "annotation": {"include": false},
  "uncertainty": {"include": false},
  "persistent": false,
  "displayParent": false
}
```

### Partial Specification

You can specify only needed properties:
```json
// Only annotation:
"meta": {
  "annotation": {"include": true, "label": "Field notes"}
}

// Only persistence:
"meta": {
  "persistent": true
}

// Multiple properties:
"meta": {
  "annotation": {"include": true, "label": "Comments"},
  "persistent": true
}
```

### Data Storage

#### Database Storage
Meta properties create parallel data structures:
```json
{
  "field-name": "actual value",
  "field-name_annotation": "annotation text",
  "field-name_uncertainty": true/false
}
```

#### CSV Export
Each meta property creates additional columns:
- Main field: `field-name`
- Annotation: `field-name_annotation`
- Uncertainty: `field-name_uncertainty`

#### JSON Export
Preserves full structure with meta values inline.

### Common Patterns

#### Field with Full Meta
```json
{
  "species-identification": {
    "component-namespace": "faims-custom",
    "component-name": "Select",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Species",
      "ElementProps": {"options": [...]}
    },
    "meta": {
      "annotation": {"include": true, "label": "Identification notes"},
      "uncertainty": {"include": true, "label": "Tentative ID"},
      "persistent": false
    }
  }
}
```

#### Persistent Configuration Fields
```json
{
  "team-member": {
    "component-namespace": "faims-custom",
    "component-name": "Select",
    "type-returned": "faims-core::String",
    "component-parameters": {
      "label": "Recording Team Member",
      "ElementProps": {"options": [...]}
    },
    "meta": {
      "persistent": true  // Keeps value for next record
    }
  }
}
```

#### Measurement with Uncertainty
```json
{
  "artifact-length": {
    "component-namespace": "faims-custom",
    "component-name": "NumberField",
    "type-returned": "faims-core::Number",
    "component-parameters": {
      "label": "Length (mm)"
    },
    "meta": {
      "uncertainty": {"include": true, "label": "Approximate"},
      "annotation": {"include": true, "label": "Measurement notes"}
    }
  }
}
```

### Field Type Compatibility

Meta properties work with ALL field types:
- ‚úÖ Text fields (all variants)
- ‚úÖ Number fields (all variants)
- ‚úÖ DateTime fields (all variants)
- ‚úÖ Selection fields (all variants)
- ‚úÖ Media fields (all variants)
- ‚úÖ Location fields (all variants)
- ‚úÖ Relationship fields

### Display Behavior

#### Annotation Field Placement
- Usually appears below main field
- Full width of container
- Multi-line text input
- No character counter
- No validation indicators

#### Uncertainty Checkbox Placement
- Typically right-aligned
- Same row as field label (desktop)
- Below field (mobile)
- May show warning icon when checked

### Performance Considerations

- Meta properties have minimal performance impact
- Annotation fields add ~2KB per field to payload
- Uncertainty adds ~10 bytes per field
- Persistent fields require state management overhead
- No impact on validation performance

### Best Practices

#### When to Use Annotations
- Fields requiring explanation
- Subjective observations
- Exceptional cases
- Quality notes
- Method descriptions

#### When to Use Uncertainty
- Estimated measurements
- Tentative identifications
- Incomplete data
- Conflicting information
- Low-confidence observations

#### When to Use Persistent
- Site/context that continues across records
- Team members recording multiple items
- Date when recording in single session
- Equipment/method that remains constant

#### When NOT to Use Persistent
- Unique identifiers
- Measurements that vary
- Observations that change
- Auto-generated values
- Photos/media

### Common Issues

#### Annotation Text Lost
- **Cause**: Field name changed
- **Fix**: Annotation stored with field name key

#### Uncertainty Not Showing
- **Cause**: Missing include property
- **Fix**: Set `"include": true`

#### Persistent Not Working
- **Cause**: Form reset between records
- **Fix**: Check form submission mode

#### Labels Not Updating
- **Cause**: Designer overwrites on save
- **Fix**: Edit JSON after Designer save

### Migration Notes

#### From Older Versions
- v1-v2: `annotation: true` ‚Üí `annotation: {"include": true}`
- v2-v3: No changes to meta structure

#### Designer Round-Trip
Designer preserves JSON meta properties it doesn't understand, but:
- Resets custom labels to defaults
- Ignores persistent/displayParent
- May reorder properties

### Related Documentation
- Field-specific documentation for display variations
- Export documentation for CSV column naming
- Validation reference (meta properties don't affect validation)

### Version
Last updated: 2025-09-03
Applies to: Fieldmark v3 (all versions)
Meta structure version: 1.0 (stable since v2)

<!-- concat:reference:formik-integration-reference -->
# Formik Integration Reference
## How Fieldmark v3 Fields Integrate with Formik

### Overview

Fieldmark v3 uses Formik as its form state management library. Understanding how fields integrate with Formik is essential for troubleshooting validation issues, implementing custom fields, and optimizing form performance. This document consolidates the universal Formik behaviors that apply to all field types.

### Component Namespaces and Formik

Fieldmark components fall into two main categories regarding Formik integration:

#### Formik-Wrapped Components (`formik-material-ui`)
These components have built-in Formik integration via the `useField` hook:
- **TextField**: Base text input (used for Email)
- **MultipleTextField**: Multi-line text area
- **Deprecated Number Field**: Uses TextField with type="number"

These components automatically:
- Connect to Formik's form state
- Handle value updates through `field.onChange`
- Manage blur events via `field.onBlur`
- Display validation errors from `meta.error`
- Track touched state via `meta.touched`

#### Custom Components (`faims-custom`)
These components implement their own Formik integration:
- All selection fields (Checkbox, RadioGroup, Select, MultiSelect, AdvancedSelect)
- All datetime fields (DateTimeNow, DateTimePicker, DatePicker, MonthPicker)
- All number fields (NumberField, ControlledNumber, BasicAutoIncrementer)
- Enhanced text fields (FAIMSTextField, TemplatedStringField, AddressField)
- Display components (RichText)

Custom components must manually:
- Call `setFieldValue` to update form state
- Call `setFieldTouched` to mark fields as interacted
- Read validation state from Formik context
- Implement error display logic

#### Special Cases
- **QRCodeFormField** (`qrcode` namespace): Implements partial Formik integration
- **RichText**: No Formik integration (display only, no data binding)

### Validation Lifecycle

#### 1. Mount Phase
When a field component mounts:
```javascript
// Formik initializes field with:
- value: initialValue from field config
- touched: false
- error: undefined (even if validation would fail)
```

**Important**: Validation runs on mount but errors are hidden until the field is touched. This prevents showing errors for empty required fields on initial form load.

#### 2. Change Event
When user modifies field value:
```javascript
// Component calls:
setFieldValue(fieldName, newValue)
// This triggers:
1. Value update in Formik state
2. Field marked as touched
3. Validation schema execution
4. Error state update if validation fails
```

**Field Type Variations**:
- **Text fields**: Validate on every keystroke
- **Selection fields**: Validate on selection change
- **Number fields**: Validate after parsing attempt
- **Date fields**: Validate after date parsing

#### 3. Blur Event
When user leaves field (focus lost):
```javascript
// Component calls:
setFieldTouched(fieldName, true)
// This triggers:
1. Touched state set to true
2. Re-validation of field
3. Error display if validation fails
```

**Critical**: Fields must be "touched" for errors to display. Common issue: users submit forms without touching required fields, causing silent validation failures.

#### 4. Submit Phase
When form is submitted:
```javascript
// Formik automatically:
1. Marks all fields as touched
2. Runs all validation schemas
3. Displays all errors
4. Prevents submission if any validation fails
```

### Formik State Structure

Each field maintains this state in Formik:

```javascript
{
  values: {
    fieldName: currentValue  // The field's current value
  },
  errors: {
    fieldName: errorMessage  // Validation error message (if any)
  },
  touched: {
    fieldName: boolean       // Whether user has interacted with field
  }
}
```

### Validation Schema Integration

Formik validates using Yup schemas defined in field configuration:

```javascript
validationSchema: [
  ["yup.string"],           // Type validation
  ["yup.required"],         // Required validation
  ["yup.min", 5],          // Minimum length
  ["yup.matches", regex]    // Pattern validation
]
```

**Execution Order**:
1. Type validation first (string, number, bool, etc.)
2. Then constraint validations in array order
3. First failure stops validation chain
4. Error message from failed validation displayed

### Common Formik Integration Issues

#### Issue: Field Not Showing Errors
**Cause**: Field not marked as touched
**Solution**: Ensure field blur event calls `setFieldTouched`
**User Workaround**: Click field then click away to trigger touched state

#### Issue: Validation Not Running
**Cause**: Component not calling Formik handlers
**Solution**: Verify `setFieldValue` called on changes
**Debug**: Check Formik state in React DevTools

#### Issue: Stale Values in Dependent Fields
**Cause**: Async validation or state updates
**Solution**: Use Formik's `validateField` after dependent updates
**Pattern**:
```javascript
await setFieldValue('field1', value)
await validateField('dependentField')
```

#### Issue: Submit Without Validation
**Cause**: Custom submit handler bypassing Formik
**Solution**: Use Formik's `handleSubmit` or `submitForm`
**Never**: Directly access values without validation

### Performance Considerations

#### Validation Debouncing
For fields with expensive validation:
```javascript
// Problem: Validation runs on every keystroke
validationSchema: [["yup.test", expensiveValidation]]

// Solution: Debounce validation
const debouncedValidation = debounce(expensiveValidation, 300)
validationSchema: [["yup.test", debouncedValidation]]
```

#### Field Arrays and Dynamic Forms
When using field arrays:
- Each array item maintains separate Formik state
- Validation runs for entire array on any change
- Consider pagination for large arrays (>50 items)

#### Conditional Fields
Hidden fields still maintain Formik state:
- Values persist when fields are hidden
- Validation still runs on hidden fields
- Use `when` conditions in Yup for conditional validation

### Field-Specific Formik Behaviors

#### Text Fields
- **TextField/MultipleTextField**: Native Formik integration
- **FAIMSTextField**: Custom integration with enhanced features
- **TemplatedString**: Updates when dependencies change
- **Address**: Complex object value requires special handling

#### Number Fields
- **Dual validation**: HTML5 + Yup validation
- **Parse on every keystroke**: May cause validation noise
- **Null vs empty**: Different handling between field types

#### DateTime Fields
- **Format parsing**: Multiple attempts on each change
- **Picker events**: May bypass normal change flow
- **Timezone handling**: Affects value comparison

#### Selection Fields
- **Binary state**: No partial validation states
- **Array values**: MultiSelect requires array handling
- **Empty state**: Difficult to detect unselected state

### Custom Field Implementation

When creating custom fields that integrate with Formik:

```javascript
import { useField } from 'formik';

function CustomField({ name, ...props }) {
  // Hook into Formik
  const [field, meta, helpers] = useField(name);
  
  return (
    <div>
      <input
        {...field}
        {...props}
        onChange={(e) => {
          // Custom logic here
          helpers.setValue(e.target.value);
        }}
        onBlur={() => {
          helpers.setTouched(true);
        }}
      />
      {meta.touched && meta.error && (
        <div className="error">{meta.error}</div>
      )}
    </div>
  );
}
```

### Debugging Formik Integration

#### Check Formik State
```javascript
// In browser console with React DevTools:
$r.props.formik.values     // Current values
$r.props.formik.errors     // Current errors
$r.props.formik.touched    // Touched fields
```

#### Monitor State Changes
```javascript
// Add to form component:
useEffect(() => {
  console.log('Formik state:', formik.values);
}, [formik.values]);
```

#### Validation Debugging
```javascript
// Test validation schema:
const schema = yup.string().required();
schema.validateSync(value);  // See validation result
```

### Best Practices

1. **Always handle touched state**: Fields must be marked touched for UX
2. **Validate on blur minimum**: Provides feedback after interaction
3. **Debounce expensive validation**: Prevent performance issues
4. **Clear error display**: Ensure errors are visible and clear
5. **Test validation flow**: Verify mount ‚Üí change ‚Üí blur ‚Üí submit cycle
6. **Handle async validation**: Use proper Promise handling
7. **Document validation rules**: Help users understand requirements

### Formik Configuration in Notebooks

Notebooks configure Formik behavior at the form level:

```json
{
  "forms": {
    "formName": {
      "views": { ... },
      "sections": { ... },
      // Formik configuration happens implicitly through field definitions
    }
  }
}
```

Field-level Formik configuration:
```json
{
  "fieldName": {
    "initialValue": "",           // Formik initial value
    "validationSchema": [...],    // Yup validation rules
    "component-parameters": {
      // Component-specific Formik integration
    }
  }
}
```

### Troubleshooting Checklist

When fields aren't behaving correctly with Formik:

- [ ] Field value updates in Formik state on change
- [ ] Field marked as touched on blur
- [ ] Validation errors appear after touch
- [ ] Submit triggers validation for all fields
- [ ] Conditional fields validate correctly
- [ ] Dependent fields update when triggers change
- [ ] Error messages display to users
- [ ] Required fields prevent submission
- [ ] Initial values set correctly
- [ ] Field resets work properly

### Related Documentation
- [Validation Timing Reference](validation-timing-reference.md) for detailed timing behavior
- [Component Namespace Reference](component-namespace-reference.md) for component types
- Individual field documentation for field-specific behaviors
- Designer documentation for configuration interface

### Version
Last updated: 2025-09-03
Applies to: Fieldmark v3 (all versions)
Formik version: 2.x (as bundled with Fieldmark)

<!-- concat:reference:platform-behaviors-reference -->
# Platform Behaviors Reference - Fieldmark v3

## Overview {essential}

This reference document consolidates platform-specific behaviors across all Fieldmark v3 field types. Understanding these platform differences is critical for successful deployment and user experience optimization.

## Platform Characteristics Summary {essential}

| Platform | Performance | UI Framework | Primary Constraints |
|----------|-------------|--------------|-------------------|
| iOS | Moderate | Native WebView | Memory limits, permission cascades |
| Android | Variable | Chrome WebView | Device fragmentation, background restrictions |
| Web Desktop | Fast | Browser native | Network latency, no offline |
| Web Mobile | Slow | Mobile browser | Limited memory, touch UI |

## iOS Specific Behaviors {important}

### System Characteristics
- **Rendering Engine**: WebKit/Safari
- **Memory Limit**: ~200MB before crash
- **JavaScript Execution**: Single-threaded with 10s timeout
- **Local Storage**: 50MB IndexedDB limit
- **Performance**: ~2x slower than native apps

### UI Behaviors
- **System Font**: San Francisco (affects text measurements)
- **Touch Targets**: Minimum 44px WCAG requirement (Fieldmark uses 36px)
- **Keyboard**: Automatic avoidance with viewport adjustment
- **Safe Area**: Automatic constraints for notch/home indicator
- **Picker Controls**: Always full-screen modal
- **Back Navigation**: Swipe gestures enabled

### Permission Handling
```
Permission Request Flow:
1. System prompt (one-time)
2. Settings ‚Üí Privacy if denied
3. Cannot re-prompt programmatically
4. Must guide user to Settings app
```

#### Camera Permissions
- Prompt appears on first camera field interaction
- Combined photo library and camera access
- HEIC images automatically converted to JPG
- Memory spikes during image processing

#### Location Permissions
- Three levels: Never, While Using, Always
- "While Using" sufficient for all Fieldmark features
- Background GPS drains battery significantly
- Accuracy stabilization requires 30-60 seconds
- Altitude always returns 0 in simulator

### File Handling
- No direct file system access
- Photos through UIImagePicker only
- Downloads go to Files app
- Cannot access arbitrary paths
- Share sheet for exports

## Android Specific Behaviors {important}

### System Characteristics
- **Rendering Engine**: Chrome WebView (version varies)
- **Memory Management**: Aggressive background killing
- **Storage**: External storage with scoped access
- **Performance**: Highly device-dependent
- **API Variations**: Significant across Android versions

### UI Behaviors
- **System Fonts**: Roboto (may vary by manufacturer)
- **Touch Targets**: Material Design 48dp recommendation
- **Back Button**: Hardware/software handling required
- **Keyboard**: Behavior varies by manufacturer
- **Navigation**: Bottom bar interference possible
- **Orientation**: Manual handling required

### Permission Handling
```
Runtime Permission Model:
1. Request at feature use
2. Can re-request if denied
3. "Don't ask again" checkbox
4. Rationale UI recommended
```

#### Storage Permissions
- Storage Access Framework (Android 10+)
- Legacy external storage (Android 9-)
- MediaStore for images/videos
- Document provider for files
- Path vs URI confusion common

#### Location Permissions
- Fine vs Coarse location
- Background location separate permission
- Battery optimization interference
- GPS wake-up delays (5-10 seconds)
- Network location fallback

### File Handling
- File size limits vary by device
- URI vs file path issues
- MediaStore integration required
- Content resolver for access
- Temporary file cleanup needed

## Web Desktop Specific Behaviors {important}

### Browser Support Matrix
| Browser | Support Level | Known Issues |
|---------|--------------|--------------|
| Chrome | Full | None |
| Safari | Good | IndexedDB limits |
| Firefox | Good | Camera API differences |
| Edge | Full | Legacy mode issues |

### Capabilities
- **Drag and Drop**: Full support for file fields
- **Clipboard**: Full read/write access
- **File System**: Limited to downloads folder
- **Multi-window**: Supported with session sharing
- **DevTools**: Full debugging capabilities

### Performance
- No memory constraints (system-dependent)
- Faster processing than mobile
- Better network handling
- No battery considerations
- Multiple concurrent operations

### Limitations
- No native GPS (IP/WiFi geolocation only)
- No camera access without HTTPS
- Local storage varies by browser
- No offline without service worker
- Print formatting inconsistent

## Web Mobile Specific Behaviors {important}

### Characteristics
- Limited memory (similar to native apps)
- Touch-optimized UI required
- No app store distribution
- PWA capabilities available
- Viewport management critical

### Browser Variations
- Safari iOS: Most restrictive
- Chrome Android: Most capable
- Firefox Mobile: Limited usage
- Samsung Internet: Custom behaviors

### Limitations
- No background processing
- Limited file system access
- Reduced performance vs native
- No push notifications (iOS)
- Share API limited

## Cross-Platform Considerations {essential}

### Performance Scaling
```
Relative Performance (normalized to Web Desktop = 1.0):
- Web Desktop: 1.0x (baseline)
- iOS Native: 0.5x
- Android High-end: 0.6x
- Android Mid-range: 0.3x
- Android Low-end: 0.15x
- Web Mobile: 0.2x
```

### Feature Availability Matrix

| Feature | iOS | Android | Web Desktop | Web Mobile |
|---------|-----|---------|-------------|------------|
| Camera | ‚úÖ | ‚úÖ | ‚úÖ* | ‚úÖ* |
| GPS | ‚úÖ | ‚úÖ | ‚ö†Ô∏è | ‚ö†Ô∏è |
| File Upload | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Offline | ‚úÖ | ‚úÖ | ‚ö†Ô∏è | ‚ö†Ô∏è |
| Background Sync | ‚úÖ | ‚ö†Ô∏è | ‚ùå | ‚ùå |

*Requires HTTPS
‚ö†Ô∏è Limited functionality
‚ùå Not available

### Memory Management Strategies

#### Mobile Platforms
- Regular garbage collection
- Limit active field count
- Cleanup on navigation
- Monitor memory usage
- Restart app if degraded

#### Desktop Platforms
- Less critical but monitor
- Browser tab memory limits
- Clear caches periodically
- Watch for memory leaks
- Profile with DevTools

## Platform Detection Patterns {important}

### User Agent Detection
```javascript
// Simplified platform detection
const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
const Android = /Android/.test(navigator.userAgent);
const Mobile = /Mobile/.test(navigator.userAgent);
```

### Feature Detection
```javascript
// Preferred approach
const hasTouch = 'ontouchstart' in window;
const hasGPS = 'geolocation' in navigator;
const hasCamera = 'mediaDevices' in navigator;
```

## Platform-Specific Workarounds {comprehensive}

### iOS Workarounds
- HEIC conversion handling
- Safari IndexedDB limits
- Viewport keyboard issues
- Touch target sizing
- Memory limit monitoring

### Android Workarounds
- Storage permission flows
- Background service limits
- WebView version detection
- Manufacturer quirks
- Battery optimization

### Web Workarounds
- Polyfills for missing APIs
- Browser capability detection
- CORS handling
- Local storage fallbacks
- Print style sheets

## Testing Recommendations {essential}

### Minimum Test Devices
- iOS: iPhone SE (lowest spec)
- iOS: iPad (newest + 2 years old)
- Android: Low-end device (Go edition)
- Android: Flagship device
- Desktop: Chrome, Safari, Firefox

### Critical Test Scenarios
1. Memory pressure conditions
2. Slow network (3G simulation)
3. Permission denial flows
4. Background/foreground transitions
5. Orientation changes
6. Multi-tasking scenarios

## See Also {comprehensive}

### Field-Specific Platform Behaviors
- [Display Fields](../field-categories/display-field-v05.md#platform-behaviors)
- [Location Fields](../field-categories/location-fields-v05.md#platform-behaviors)
- [Media Fields](../field-categories/media-fields-v05.md#platform-behaviors)
- [Relationship Fields](../field-categories/relationship-field-v05.md#platform-behaviors)

### Related References
- [Performance Thresholds Reference](./performance-thresholds-reference.md)
- [Security Considerations Reference](./security-considerations-reference.md)
- [Troubleshooting Framework Reference](./troubleshooting-framework-reference.md)

## Metadata {comprehensive}
- **Document Version**: v01
- **Last Updated**: 2025-01-03
- **Status**: Initial extraction from field documentation
- **Purpose**: Consolidate platform-specific behaviors across all field types
- **Maintenance**: Update when new platform behaviors discovered

<!-- concat:reference:performance-thresholds-reference -->
# Performance Thresholds Reference
## Empirically Tested Estimates for Fieldmark v3 Components

### Important Disclaimer

**These thresholds are ESTIMATES based on empirical observations, not guaranteed limits.** Performance varies significantly based on:
- Device specifications (CPU, RAM, storage)
- Browser type and version
- Network conditions
- Operating system
- Concurrent applications
- Data complexity

**Approach all thresholds with caution.** What works on a high-end device may fail on older hardware. Always test on your target devices under realistic conditions.

### We Welcome Your Feedback

These estimates are continuously refined based on user experiences. **Please share your observations:**
- If you encounter performance issues below these thresholds
- If you successfully exceed these thresholds
- Device-specific limitations you discover
- Optimization techniques that work for you

Contact the Fieldmark team or submit feedback through your project coordinator to help improve these guidelines.

### Overview

This document consolidates estimated performance thresholds and boundaries for Fieldmark v3 fields. These values are based on empirical testing across various devices and conditions. They should be used as conservative guidelines for notebook design, with actual limits varying based on deployment context.

### Testing Checklist

Use this checklist to verify your notebook stays within estimated performance boundaries:

- [ ] Forms have fewer than 50 fields per page
- [ ] Selection fields have fewer than 20 options (if using markdown)
- [ ] Text fields contain less than 10,000 characters
- [ ] No more than 10 validation rules per field
- [ ] Forms are paginated if exceeding thresholds
- [ ] Export datasets under 65,000 rows for Excel compatibility
- [ ] File uploads under 10MB per file
- [ ] Total form size under 100MB including attachments

## Field Count Thresholds (Estimates)

### Per Form/Page Limits

**Note:** These are conservative estimates. Your specific hardware may support more or fewer fields.

| Field Count | Performance Impact | User Experience | Recommendation |
|-------------|-------------------|-----------------|----------------|
| 1-20 fields | Optimal | Instant render (<500ms) | Ideal for mobile |
| 20-50 fields | Good | Fast render (<1s) | Acceptable for all platforms |
| 50-100 fields | Degraded | Noticeable delay (1-3s) | Consider pagination |
| 100-500 fields | Poor | Significant delay (3-10s) | Must paginate |
| 500-1000 fields | Critical | Very slow (10-30s) | Redesign required |
| >1000 fields | Failure | Browser crash likely | Not supported |

### Memory Consumption (Approximate)

**Note:** Memory usage varies by browser implementation and available system resources.

| Component Type | Memory Per Field | 100 Fields | 1000 Fields | Browser Limit |
|---------------|------------------|------------|-------------|---------------|
| Text fields | ~8KB | 800KB | 8MB | ~4GB typical |
| Number fields | ~8KB | 800KB | 8MB | ~4GB typical |
| Selection fields | ~12KB + options | 1.2MB+ | 12MB+ | Varies by options |
| Date fields | ~2MB (picker resources) | 200MB | 2GB | Critical at 100 fields |
| Media fields | ~5MB (camera access) | 500MB | 5GB | Critical at 20 fields |
| Map fields | ~10MB (map tiles) | 1GB | 10GB | Critical at 10 fields |

## Text Field Thresholds (Estimates)

### Character Limits

**Note:** These limits are approximations. Actual performance depends on character complexity and rendering requirements.

| Character Count | Field Type | Performance | Export Impact | Mobile Impact |
|----------------|------------|-------------|---------------|---------------|
| 0-50 | TextField | Optimal | None | Optimal |
| 50-500 | TextField/MultipleTextField | Optimal | None | Good |
| 500-1000 | MultipleTextField | Good | None | Good |
| 1000-5000 | MultipleTextField | Good | CSV may need escaping | Scrolling needed |
| 5000-10000 | MultipleTextField | Degraded | CSV reader issues possible | Performance lag |
| >10000 | MultipleTextField | Poor | Export problems likely | Severe lag |
| ~1MB | Any text field | Critical | CouchDB document limit | App crash |

### MultilineText Row Configuration

| Row Count | Use Case | Performance | Mobile Usability |
|-----------|----------|-------------|------------------|
| 3 rows | Brief notes | Optimal | Perfect |
| 4-5 rows | Standard descriptions | Optimal | Good |
| 6-8 rows | Detailed observations | Good | Requires scrolling |
| 10+ rows | Extended narratives | Good | Poor (excessive scrolling) |

## Selection Field Thresholds (Estimates)

### Option Count Limits

**Note:** Markdown processing adds variable overhead depending on markdown complexity.

| Option Count | Without Markdown | With Markdown | User Experience | Mobile Impact |
|-------------|------------------|---------------|-----------------|---------------|
| 1-5 options | Instant | Instant | Optimal | Perfect |
| 5-10 options | Instant | Fast (<100ms) | Optimal | Good |
| 10-20 options | Fast | Noticeable lag | Good | Scrolling needed |
| 20-50 options | Fast | Significant lag (>500ms) | Degraded | Poor scrolling |
| 50-100 options | Good | Poor (>1s) | Poor | Very poor |
| >100 options | Slow | Unusable | Redesign needed | Not viable |

**Note**: Markdown processing adds significant overhead. Consider disabling markdown for large option lists.

### AdvancedSelect Hierarchy Limits

| Node Count | Depth | Performance | Memory Usage | Recommendation |
|------------|-------|-------------|--------------|----------------|
| <50 nodes | 1-3 levels | Optimal | <1MB | Ideal |
| 50-100 nodes | 1-4 levels | Good | 1-2MB | Acceptable |
| 100-500 nodes | 2-5 levels | Degraded | 2-10MB | Consider alternatives |
| >500 nodes | Any | Poor | >10MB | Use search instead |

## Number Field Thresholds (Estimates)

### Validation Complexity

**Note:** Validation performance heavily depends on rule complexity, not just count.

| Validation Rules | Blur Response Time | User Experience | Recommendation |
|-----------------|-------------------|-----------------|----------------|
| 1-3 rules | <10ms | Instant | Optimal |
| 3-5 rules | 10-30ms | Fast | Good |
| 5-10 rules | 30-50ms | Noticeable | Acceptable |
| 10-15 rules | 50-200ms | Sluggish | Simplify if possible |
| >15 rules | >200ms | Poor | Must simplify |

### Numeric Precision Limits

| Value Range | Storage | Display | Excel Export | JavaScript Precision |
|------------|---------|---------|--------------|---------------------|
| -2^53 to 2^53 | Safe | Accurate | Accurate | Full precision |
| 15-17 digits | Safe | Accurate | Scientific notation | Full precision |
| >17 digits | Unsafe | Rounded | Loss of precision | Precision lost |
| Scientific notation | As string | Preserved | May convert | Preserved as string |

## DateTime Field Thresholds (Estimates)

### Form Limits

**Note:** Date picker resources vary significantly by platform and browser.

| Date Fields Per Form | Render Time | Memory Usage | Mobile Viability |
|---------------------|-------------|--------------|------------------|
| 1-10 fields | <500ms | 20MB | Excellent |
| 10-20 fields | 500ms-1s | 40MB | Good |
| 20-50 fields | 1-2s | 100MB | Degraded |
| 50-100 fields | 2-5s | 200MB | Poor |
| >100 fields | >5s | Browser limit | Not recommended |

### Processing Overhead

| Operation | Time Per Field | 100 Fields | Impact |
|-----------|---------------|------------|---------|
| Timezone conversion (DateTimeNow) | ~100ms | 10s | Significant for bulk operations |
| Picker rendering | 100-300ms | 10-30s | Affects initial load |
| Validation check | <5ms | 500ms | Minimal |
| Database indexing | ~500ms | 50s | One-time cost |

## Media Field Thresholds (Estimates)

### File Size Limits

**Note:** Upload times are highly dependent on network quality and server processing.

| File Size | Upload Time (3G) | Upload Time (WiFi) | Storage Impact | Recommendation |
|-----------|------------------|-------------------|----------------|----------------|
| <1MB | <5s | <1s | Minimal | Optimal |
| 1-5MB | 5-30s | 1-5s | Manageable | Good |
| 5-10MB | 30-60s | 5-10s | Significant | Maximum recommended |
| 10-50MB | 1-5min | 10-60s | Heavy | Requires warning |
| >50MB | >5min | >60s | Critical | Not recommended |

### Image Capture Specifications

| Resolution | File Size | Processing Time | Use Case |
|------------|-----------|-----------------|----------|
| 640x480 | ~200KB | <100ms | Thumbnails |
| 1280x720 (720p) | ~500KB | 200ms | Documentation |
| 1920x1080 (1080p) | ~1MB | 500ms | Standard quality |
| 3840x2160 (4K) | ~5MB | 2s | High quality |
| Original | Varies | Varies | Archival |

## Export Performance (Estimates)

### CSV Export Limits

**Note:** Export performance depends on data complexity, not just row count.

| Row Count | Generation Time | File Size | Excel Compatibility | Browser Handling |
|-----------|-----------------|-----------|-------------------|------------------|
| <1000 | <1s | <1MB | Perfect | Instant |
| 1000-10000 | 1-5s | 1-10MB | Good | Fast |
| 10000-65000 | 5-30s | 10-100MB | Last Excel limit | May timeout |
| 65000-100000 | 30-60s | 100MB+ | Requires splitting | Likely timeout |
| >100000 | >60s | >100MB | Database tools needed | Will timeout |

### JSON Export Performance

| Record Count | Generation Time | File Size | Memory Required | Recommendation |
|-------------|-----------------|-----------|-----------------|----------------|
| <100 | Instant | <100KB | Minimal | Optimal |
| 100-1000 | <2s | 100KB-1MB | <10MB | Good |
| 1000-10000 | 2-10s | 1-10MB | 10-100MB | Consider pagination |
| >10000 | >10s | >10MB | >100MB | Must paginate |

## Synchronization Thresholds (Estimates)

### Sync Payload Sizes

**Note:** Sync performance varies greatly with network latency and server load.

| Data Volume | Sync Time (3G) | Sync Time (WiFi) | Battery Impact | Recommendation |
|------------|----------------|------------------|----------------|----------------|
| <1MB | <10s | <2s | Minimal | Optimal |
| 1-10MB | 10-60s | 2-10s | Noticeable | Good |
| 10-50MB | 1-5min | 10-60s | Significant | Schedule for WiFi |
| 50-100MB | 5-10min | 1-5min | Heavy drain | WiFi only |
| >100MB | >10min | >5min | Critical | Requires chunking |

## Platform-Specific Thresholds (Estimates)

### Mobile Device Limits (iOS/Android)

**Note:** Mobile limits vary dramatically across device generations and manufacturers.

| Resource | Threshold | Impact | Mitigation |
|----------|-----------|---------|------------|
| RAM usage | >500MB | App termination risk | Reduce form complexity |
| Storage | >1GB | Sync issues | Implement cleanup |
| CPU usage | >80% for 30s | System throttling | Optimize operations |
| Battery drain | >10% per hour | User complaints | Reduce background ops |
| Network timeout | >30s | Connection drops | Implement retry logic |

### Browser-Specific Limits

| Browser | Memory Limit | Local Storage | IndexedDB | Session Storage |
|---------|-------------|---------------|-----------|-----------------|
| Chrome | 4GB typical | 10MB | 50% of disk | 10MB |
| Firefox | 2GB typical | 10MB | 50% of disk | 10MB |
| Safari | 2GB typical | 5MB | 1GB | 5MB |
| Edge | 4GB typical | 10MB | 50% of disk | 10MB |
| Mobile browsers | 512MB-1GB | 5-10MB | 50-500MB | 5MB |

## Performance Optimization Triggers

These estimated thresholds suggest when optimization should be considered:

### Must Optimize When:

1. **Form render time >3 seconds** ‚Üí Implement pagination
2. **Field blur lag >50ms** ‚Üí Simplify validation
3. **Option count >20 with markdown** ‚Üí Disable markdown or reduce options
4. **Text field >10,000 characters** ‚Üí Consider file attachment instead
5. **Memory usage >500MB mobile** ‚Üí Reduce form complexity
6. **Export time >30 seconds** ‚Üí Implement server-side export
7. **Sync payload >50MB** ‚Üí Implement incremental sync

### Warning Thresholds:

1. **Form render 1-3 seconds** ‚Üí Monitor and plan optimization
2. **Field blur lag 30-50ms** ‚Üí Review validation complexity
3. **Option count 10-20** ‚Üí Consider user experience
4. **Memory usage 200-500MB** ‚Üí Begin optimization planning
5. **Export time 10-30 seconds** ‚Üí Warn users about delay

## Testing Recommendations

**Remember:** These estimates are intentionally conservative. Your specific deployment may perform better or worse. Always conduct thorough testing on your actual target devices before deployment.

### Load Testing Scenarios

1. **Minimum viable test**: 10 fields, 5 records
2. **Standard test**: 50 fields, 100 records
3. **Stress test**: 100 fields, 1000 records
4. **Failure test**: 500 fields, 10000 records

### Device Testing Matrix

| Test Scenario | High-end Device | Mid-range Device | Low-end Device |
|--------------|-----------------|------------------|----------------|
| Small form (10 fields) | Must pass | Must pass | Must pass |
| Medium form (50 fields) | Must pass | Must pass | Should pass |
| Large form (100 fields) | Must pass | Should pass | May fail |
| Complex form (validation) | Must pass | Should pass | May fail |

### Network Testing Conditions

1. **WiFi**: Full functionality required
2. **4G/LTE**: Core functionality required
3. **3G**: Basic functionality required
4. **Offline**: Data entry must work
5. **Intermittent**: Graceful degradation required

## Best Practices

### Design Guidelines

1. **Prefer pagination**: Keep forms under 50 fields per page
2. **Simplify validation**: Maximum 5 rules per field
3. **Limit options**: Under 20 for selection fields
4. **Optimize media**: Compress images before upload
5. **Plan exports**: Implement pagination for large datasets

### Monitoring Metrics

Track these metrics in production:

1. Form render time (target: <1s)
2. Field validation time (target: <30ms)
3. Export generation time (target: <10s)
4. Sync completion rate (target: >95%)
5. Memory usage (target: <200MB mobile)
6. Battery drain (target: <5% per hour active use)

### Related Documentation

- Designer Limitations Reference for configuration constraints
- Data Export Reference for export-specific details
- Validation Timing Reference for validation performance
- Individual field documentation for field-specific thresholds

## Location Field Thresholds (Estimates)

### GPS Acquisition Times (TakePoint)

**Note:** GPS acquisition varies significantly based on environmental factors, satellite visibility, and device hardware.

| Platform | Cold Start | Warm Start | Indoor | Environmental Factors |
|----------|------------|------------|--------|----------------------|
| iOS | 3-8s | 1-3s | 15-30s | Best accuracy, A-GPS assisted |
| Android | 5-15s | 2-5s | 20-45s | Variable by device/manufacturer |
| Web | 2-5s | 1-2s | 10-20s | Browser-based, lower accuracy |

**Factors affecting acquisition:**
- Cold start: First GPS use after reboot or location services re-enabled
- Warm start: GPS used within last hour
- Indoor: Significant signal degradation through buildings
- Urban canyon: Tall buildings create multipath interference

### Map Performance (MapFormField)

**Note:** Performance degrades exponentially with vertex count. Mobile devices particularly affected.

| Vertices | Desktop | iOS | Android | Performance Impact |
|----------|---------|-----|---------|-------------------|
| <100 | Instant | Instant | Instant | Optimal - recommended for all platforms |
| 100-300 | <100ms | <200ms | <300ms | Good - acceptable for most uses |
| 300-500 | <200ms | <400ms | <600ms | Acceptable - noticeable on older devices |
| 500-1000 | <500ms | <1s | 1-2s | Poor - significant lag, avoid on mobile |
| 1000-2000 | 1-2s | 2-4s | 4-8s | Critical - high crash risk |
| >2000 | 2-5s | Crash risk | Crash likely | Not supported |

**Additional constraints:**
- GPU acceleration disabled for compatibility
- No WebGL fallback implemented
- Memory not released between edits

### Battery Consumption (Location Features)

**Note:** Battery drain estimates based on typical usage patterns. Actual consumption varies by device age and battery health.

| Operation | Battery/Hour | Continuous Use | Notes |
|-----------|--------------|----------------|-------|
| TakePoint (high accuracy) | 8-12% | Not recommended | GPS constantly active |
| TakePoint (balanced) | 4-6% | Acceptable | Standard accuracy mode |
| MapFormField (active drawing) | 2-3% | Sustainable | CPU for rendering only |
| MapFormField (map visible) | <1% | Negligible | Static map display |
| Combined usage | 10-15% | Limited time | Both features active |

**Battery optimization tips:**
- Space TakePoint captures at least 60 seconds apart
- Use `enableHighAccuracy: false` when 10-15m accuracy acceptable
- Close map view when not actively drawing
- Consider external battery pack for all-day fieldwork

### Storage Requirements (Offline Maps)

| Coverage Area | Zoom Levels | Approximate Size | Download Time (4G) |
|--------------|-------------|------------------|-------------------|
| City district (25 km¬≤) | 10-18 | 50-100 MB | 1-2 minutes |
| Survey area (100 km¬≤) | 12-19 | 100-200 MB | 2-4 minutes |
| Regional (1000 km¬≤) | 8-16 | 200-500 MB | 5-10 minutes |
| Country subset | 6-14 | 500MB-1GB | 10-20 minutes |

**Storage considerations:**
- Browser storage typically limited to 50% of free disk space
- Mobile apps may have lower limits (varies by OS)
- Tile cache persists until explicitly cleared
- Consider selective download of work areas only

### Location Data Limits

| Metric | TakePoint | MapFormField | Impact |
|--------|-----------|--------------|---------|
| Points per notebook | 1000-2000 | N/A | Performance degrades beyond |
| Vertices per feature | N/A | 500 optimal, 2000 max | Drawing responsiveness |
| Coordinate precision | 14+ decimals shown | User-controlled | False precision displayed |
| GPS timeout | 10s default, 45s max | N/A | Acquisition wait time |
| Accuracy display | Always shown | Not captured | Metres to 1 decimal |

### Version
Last updated: 2025-09-04
Applies to: Fieldmark v3 (all versions)
Performance metrics: Empirically estimated August 2025
Location metrics: Added January 2025

### Feedback and Contributions

These thresholds are living estimates that improve with community input. Please report your experiences to help refine these guidelines for future users. Remember: your mileage may vary - always test on your actual deployment hardware.

<!-- concat:reference:accessibility-reference -->
# Accessibility Reference
## WCAG Compliance and Touch Target Standards for Fieldmark v3

### Overview

This document consolidates accessibility standards, WCAG compliance status, and touch target requirements for all Fieldmark v3 fields. Accessibility in fieldwork applications presents unique challenges: gloved hands, bright sunlight, muddy screens, and physical fatigue all impact usability. These guidelines address both standard WCAG compliance and field-specific accessibility needs.

### Touch Target Standards

#### Minimum Size Requirements

| Standard | Minimum Size | Applies To | Fieldmark Status |
|----------|-------------|------------|------------------|
| **WCAG 2.1 (2.5.5)** | 44√ó44 CSS pixels | All interactive elements | ‚ö†Ô∏è Partial compliance |
| **iOS HIG** | 44√ó44 points | All touch targets | ‚ùå Many fields below minimum |
| **Material Design** | 48√ó48 dp | All touch targets | ‚ùå Most fields below minimum |
| **Field Best Practice** | 56√ó56 pixels | Primary actions in field | ‚ùå Not met by default |

#### Current Touch Target Sizes

| Field Type | Default Size | Compliant? | Issue |
|------------|--------------|------------|-------|
| **TextField** | ~36px height | ‚ùå No | Below all standards |
| **Number spinners** | ~20√ó20px | ‚ùå No | Far too small for field use |
| **Checkbox** | 24√ó24px | ‚ùå No | Icon only, label not clickable |
| **Radio buttons** | 24√ó24px | ‚ùå No | Small target, label not clickable |
| **Select dropdown** | ~36px height | ‚ùå No | Below minimum |
| **Date pickers** | Platform varies | ‚úÖ Usually | Native pickers generally compliant |
| **Camera button** | Platform varies | ‚úÖ Yes | Native camera UI compliant |
| **QR scanner** | Full screen | ‚úÖ Yes | Entire screen is target |

#### Touch Target Solutions

**CSS Override for Larger Targets**:
```css
/* Minimum WCAG compliance */
.MuiInputBase-root {
  min-height: 44px !important;
}

/* Field-optimized (gloves, fatigue) */
.MuiInputBase-root {
  min-height: 56px !important;
  font-size: 16px !important; /* Prevents zoom on iOS */
}

/* Number field spinners */
.MuiInputBase-root input[type="number"]::-webkit-inner-spin-button,
.MuiInputBase-root input[type="number"]::-webkit-outer-spin-button {
  height: 44px;
  width: 44px;
}
```

### WCAG 2.1 Compliance Status

#### Level A Compliance

| Criterion | Requirement | Fieldmark Status | Issues |
|-----------|-------------|------------------|--------|
| **1.1.1** | Non-text Content | ‚úÖ Pass | Icons have labels |
| **1.3.1** | Info and Relationships | ‚ö†Ô∏è Partial | Some fields lack proper ARIA |
| **1.4.1** | Use of Color | ‚úÖ Pass | Not solely color-dependent |
| **2.1.1** | Keyboard | ‚úÖ Pass | All fields keyboard accessible |
| **2.4.3** | Focus Order | ‚úÖ Pass | Logical tab order |
| **3.1.1** | Language of Page | ‚úÖ Pass | HTML lang attribute set |
| **3.3.1** | Error Identification | ‚ö†Ô∏è Partial | Some fields don't show errors |
| **3.3.2** | Labels or Instructions | ‚úÖ Pass | All fields have labels |
| **4.1.1** | Parsing | ‚úÖ Pass | Valid HTML |
| **4.1.2** | Name, Role, Value | ‚ö†Ô∏è Partial | Some custom fields lack ARIA |

#### Level AA Compliance

| Criterion | Requirement | Fieldmark Status | Issues |
|-----------|-------------|------------------|--------|
| **1.3.5** | Identify Input Purpose | ‚úÖ Pass | Semantic HTML used |
| **1.4.3** | Contrast (Minimum) | ‚ö†Ô∏è Partial | Some states below 4.5:1 |
| **1.4.4** | Resize Text | ‚úÖ Pass | Text scalable to 200% |
| **1.4.5** | Images of Text | ‚úÖ Pass | No text images used |
| **1.4.10** | Reflow | ‚ö†Ô∏è Partial | Some layouts break |
| **1.4.11** | Non-text Contrast | ‚ùå Fail | Spinner controls below 3:1 |
| **2.4.5** | Multiple Ways | N/A | Single page app |
| **2.4.6** | Headings and Labels | ‚úÖ Pass | Descriptive labels |
| **2.4.7** | Focus Visible | ‚úÖ Pass | Browser default focus |
| **2.5.5** | Target Size | ‚ùå Fail | Most fields below 44√ó44px |
| **3.3.3** | Error Suggestion | ‚ö†Ô∏è Partial | Generic error messages |
| **3.3.4** | Error Prevention | ‚ö†Ô∏è Partial | Limited validation |
| **4.1.3** | Status Messages | ‚ùå Fail | No aria-live regions |

### Field-Specific Accessibility Issues

#### Text Fields
- **Touch targets**: Default height ~36px (below 44px minimum)
- **Screen reader**: Labels announced properly
- **Keyboard**: Full navigation support
- **Issues**: Multiline text scrolling not announced

#### Number Fields
- **Spinners**: ~20√ó20px - far too small
- **Screen reader**: Type="number" provides semantic meaning
- **Keyboard**: Arrow keys adjust values
- **Issues**: No announcement of value changes via spinner

#### DateTime Fields
- **Native pickers**: Generally accessible
- **Platform variance**: Different interfaces confuse users
- **Screen reader**: Date format not always announced
- **Issues**: "Now" button location varies, may be missed

#### Selection Fields
- **Checkbox/Radio**: 24√ó24px icons too small
- **Labels not clickable**: Must hit exact icon
- **Screen reader**: Options announced
- **Issues**: Select and AdvancedSelect don't show error messages visually

#### Media Fields
- **Camera/QR**: Native UI generally accessible
- **Touch targets**: Full screen for capture
- **Issues**: Web platform shows disabled state without explanation

### Screen Reader Support

#### Tested Screen Readers
- **iOS**: VoiceOver
- **Android**: TalkBack
- **Windows**: NVDA, JAWS
- **macOS**: VoiceOver

#### Common Issues
1. **Error announcements**: Validation errors not always announced
2. **Dynamic content**: Field updates not announced
3. **Helper text**: Not consistently associated with fields
4. **State changes**: Touched/untouched state not conveyed
5. **Complex fields**: Address, AdvancedSelect structure not clear

#### ARIA Implementation Gaps
```html
<!-- Current (missing ARIA) -->
<input type="text" />

<!-- Needed for proper announcement -->
<input 
  type="text"
  aria-label="Field name"
  aria-describedby="helper-text error-message"
  aria-invalid="true"
  aria-required="true"
/>
<span id="helper-text">Helper text</span>
<span id="error-message" role="alert">Error message</span>
```

### Keyboard Navigation

#### Standard Keyboard Support
- **Tab**: Navigate between fields
- **Shift+Tab**: Navigate backwards
- **Enter**: Submit form or activate buttons
- **Space**: Toggle checkboxes, activate buttons
- **Arrow keys**: Navigate radio groups, adjust numbers
- **Escape**: Close dropdowns and pickers

#### Field-Specific Keyboard Behaviors
| Field Type | Keys | Action | Issues |
|------------|------|--------|--------|
| TextField | All keys | Standard typing | None |
| Number | ‚Üë‚Üì | Increment/decrement | Step size not configurable |
| DateTime | Various | Platform-dependent | Inconsistent across browsers |
| Select | ‚Üë‚Üì | Navigate options | Can't type to search |
| RadioGroup | ‚Üë‚Üì‚Üê‚Üí | Navigate options | Must use arrows, not Tab |
| Checkbox | Space | Toggle | Enter key doesn't work |
| MultiSelect | ‚Üë‚Üì Space | Select multiple | Complex interaction pattern |

### Color and Contrast

#### Current Contrast Ratios
| Element | Foreground | Background | Ratio | WCAG AA | WCAG AAA |
|---------|------------|------------|-------|---------|----------|
| Label text | #000000 | #FFFFFF | 21:1 | ‚úÖ Pass | ‚úÖ Pass |
| Input text | #000000 | #FFFFFF | 21:1 | ‚úÖ Pass | ‚úÖ Pass |
| Helper text | #666666 | #FFFFFF | 5.7:1 | ‚úÖ Pass | ‚ùå Fail |
| Error text | #F44336 | #FFFFFF | 3.5:1 | ‚ùå Fail | ‚ùå Fail |
| Disabled | #9E9E9E | #FFFFFF | 2.8:1 | N/A | N/A |
| Focus ring | #1976D2 | #FFFFFF | 4.5:1 | ‚úÖ Pass | ‚ùå Fail |

#### Color Blind Considerations
- Error states rely on red color (problematic for protanopia)
- Success states use green (problematic for deuteranopia)
- No patterns or icons to supplement color coding
- Recommendation: Add icons to validation states

### Platform-Specific Accessibility

#### iOS/iPadOS
- **VoiceOver**: Generally well-supported
- **Touch targets**: Many below 44√ó44pt minimum
- **Zoom**: Supported but may cause layout issues
- **Voice Control**: Limited support for custom fields

#### Android
- **TalkBack**: Good support for standard fields
- **Touch targets**: Below 48dp Material Design standard
- **Magnification**: Supported
- **Switch Access**: Not tested

#### Web Desktop
- **Screen readers**: Variable support
- **Keyboard**: Full support
- **High contrast mode**: Not optimized
- **Browser zoom**: Supported to 200%

### Field Operation Accessibility

Fieldwork presents unique accessibility challenges:

#### Environmental Factors
- **Bright sunlight**: Low contrast text hard to read
- **Rain/mud**: Precise touch targets impossible
- **Cold**: Reduced finger dexterity
- **Gloves**: Require larger touch targets
- **Fatigue**: Fine motor control degraded

#### Recommended Adaptations
1. **Increase all touch targets to 56√ó56px minimum**
2. **Use high contrast mode in bright conditions**
3. **Provide voice input alternatives**
4. **Minimize required precision interactions**
5. **Reduce scrolling requirements**
6. **Cache data aggressively for poor connectivity**

### Voice Input Support

#### Voice Dictation Compatibility
| Field Type | iOS Siri | Android | Dragon | Issues |
|------------|----------|----------|---------|--------|
| Text | ‚úÖ Full | ‚úÖ Full | ‚úÖ Full | None |
| Number | ‚ö†Ô∏è Partial | ‚ö†Ô∏è Partial | ‚ö†Ô∏è Partial | Natural language not parsed |
| Email | ‚úÖ Full | ‚úÖ Full | ‚úÖ Full | May need spelling |
| Date | ‚ùå Poor | ‚ùå Poor | ‚ùå Poor | Format not recognized |
| Selection | ‚ùå No | ‚ùå No | ‚ùå No | Can't select options |

#### Voice Command Support
- Currently no custom voice commands implemented
- Relies on platform-level voice control
- Limited interaction with custom components

### Testing Recommendations

#### Automated Testing
```javascript
// Using axe-core for automated accessibility testing
const axe = require('axe-core');

describe('Accessibility', () => {
  it('should have no violations', async () => {
    const results = await axe.run();
    expect(results.violations).toHaveLength(0);
  });
});
```

#### Manual Testing Checklist
- [ ] Test with screen reader on each platform
- [ ] Navigate using keyboard only
- [ ] Verify touch targets with measurement tool
- [ ] Test with platform zoom at 200%
- [ ] Verify color contrast ratios
- [ ] Test in high contrast mode
- [ ] Use with voice control
- [ ] Test with gloves/stylus
- [ ] Verify in bright sunlight
- [ ] Test with slow connection

#### User Testing
- Include users with disabilities in field trials
- Test with actual fieldwork conditions
- Document accessibility barriers encountered
- Prioritize fixes based on impact

### Compliance Roadmap

#### Priority 1: Critical (Safety/Legal)
1. Fix touch targets below 44√ó44px
2. Add aria-live regions for errors
3. Improve error message contrast
4. Fix label click areas

#### Priority 2: High (Usability)
1. Improve screen reader announcements
2. Add keyboard shortcuts
3. Enhance focus indicators
4. Implement skip navigation

#### Priority 3: Medium (Enhancement)
1. Add voice commands
2. Improve high contrast support
3. Create accessibility preferences
4. Add haptic feedback

### Implementation Guidelines

#### For Developers
1. Always include ARIA labels
2. Test with screen readers
3. Ensure 44√ó44px minimum touch targets
4. Provide keyboard alternatives
5. Use semantic HTML elements
6. Test contrast ratios
7. Include focus indicators

#### For Designers
1. Design for 56√ó56px touch targets in field
2. Don't rely solely on color
3. Provide clear visual hierarchy
4. Consider gloved hand interaction
5. Test in bright light conditions
6. Plan for offline/slow connectivity

#### For Project Managers
1. Budget for accessibility testing
2. Include users with disabilities in trials
3. Document accessibility requirements
4. Plan for progressive enhancement
5. Consider field conditions in requirements

### Known Limitations

#### Cannot Be Fixed
- Platform picker variations
- Native component accessibility bugs
- Third-party library limitations

#### Require Significant Rework
- Touch target sizes (CSS framework change)
- ARIA implementation (component rewrites)
- Screen reader support (architecture changes)

#### Workarounds Available
- Use external keyboard for precision
- Increase browser/OS zoom
- Use stylus for small targets
- Enable high contrast mode

### Resources

#### Testing Tools
- axe DevTools (browser extension)
- WAVE (WebAIM evaluation tool)
- Lighthouse (Chrome DevTools)
- Color contrast analyzers
- Screen reader testing guides

#### Standards Documentation
- WCAG 2.1 Guidelines
- iOS Human Interface Guidelines
- Material Design Accessibility
- ARIA Authoring Practices Guide

### Related Documentation
- Individual field documentation for specific issues
- Performance Thresholds Reference for interaction timing
- Designer Limitations Reference for configuration constraints
- Platform behavior documentation

### Version
Last updated: 2025-09-03
Applies to: Fieldmark v3 (all versions)
WCAG version: 2.1
Testing date: August 2025

<!-- concat:reference:migration-strategies-reference -->
# Migration Strategies Reference - Fieldmark v3

## Overview {essential}

This reference provides universal migration methodologies that apply across all field type changes, configuration updates, and schema modifications in Fieldmark v3. For field-specific migration scenarios, consult the relevant field documentation.

## Migration Planning Framework {essential}

### Pre-Migration Checklist
- [ ] **Identify scope** - Which forms, fields, and records affected
- [ ] **Assess risk** - Data loss potential, user impact, rollback complexity
- [ ] **Backup data** - Complete export before any changes
- [ ] **Document current state** - Screenshots, JSON exports, configuration
- [ ] **Test migration path** - Verify in development environment
- [ ] **Prepare rollback plan** - Know how to revert if needed
- [ ] **Schedule window** - Minimize user disruption
- [ ] **Communicate changes** - Notify all stakeholders

### Risk Assessment Matrix

| Migration Type | Risk Level | Backup Required | Testing Required | Rollback Difficulty |
|---------------|------------|-----------------|------------------|-------------------|
| Add new field | Low | Optional | Minimal | Easy |
| Modify validation | Medium | Yes | Moderate | Easy |
| Change field type | High | Critical | Extensive | Moderate |
| Restructure relationships | Critical | Critical | Extensive | Difficult |
| Delete fields | Critical | Critical | Moderate | Impossible |

## Universal Migration Patterns {essential}

### Pattern 1: Parallel Field Migration
**When to use**: Changing field types or major restructuring

```
1. Create new field alongside old field
2. Run both fields in parallel during transition
3. Migrate data progressively
4. Hide old field once migration complete
5. Delete old field after verification period
```

**Benefits**: 
- No data loss
- Gradual transition
- Easy rollback
- User training period

### Pattern 2: In-Place Modification
**When to use**: Minor configuration changes, validation updates

```
1. Export current configuration
2. Test modifications in development
3. Apply changes during maintenance window
4. Monitor for issues
5. Rollback if problems detected
```

**Benefits**:
- Faster implementation
- Less complexity
- Immediate effect

**Risks**:
- Potential data loss
- Harder rollback
- User disruption

### Pattern 3: Staged Migration
**When to use**: Large-scale changes affecting multiple forms

```
1. Divide migration into phases
2. Complete Phase 1, verify, stabilize
3. Proceed to next phase only after validation
4. Maintain compatibility between phases
5. Complete final cutover
```

**Benefits**:
- Reduced risk
- Learning between phases
- Easier troubleshooting
- Gradual user adaptation

## Backup and Recovery Procedures {essential}

### Backup Strategies

#### Complete Project Backup
```bash
# Export all project data
1. Navigate to Project Settings
2. Export ‚Üí Download all data (CSV)
3. Export ‚Üí Download project configuration (JSON)
4. Store in version-controlled location
5. Verify export integrity
```

#### Selective Field Backup
```json
// Save specific field configurations
{
  "backup_date": "2025-01-03",
  "field_name": "original-field",
  "configuration": {
    // Complete field JSON
  },
  "sample_data": [
    // Representative data samples
  ]
}
```

### Recovery Procedures

#### Rollback Decision Tree
```
Issue Detected
‚îú‚îÄ Data corruption?
‚îÇ  ‚îî‚îÄ YES ‚Üí Immediate rollback
‚îÇ
‚îú‚îÄ Functional failure?
‚îÇ  ‚îú‚îÄ Critical? ‚Üí Immediate rollback
‚îÇ  ‚îî‚îÄ Minor? ‚Üí Hotfix attempt
‚îÇ
‚îî‚îÄ Performance issue?
   ‚îú‚îÄ Severe? ‚Üí Rollback
   ‚îî‚îÄ Moderate? ‚Üí Optimize first
```

#### Rollback Steps
1. **Stop all user access** - Maintenance mode
2. **Restore configuration** - Upload backed-up JSON
3. **Verify structure** - Check all fields present
4. **Restore data** - Import CSV if needed
5. **Test functionality** - Verify core features
6. **Re-enable access** - Remove maintenance mode

## Testing Methodologies {important}

### Test Environment Setup
```
Production ‚Üí Export ‚Üí Test Environment
                         ‚Üì
                    Migration Test
                         ‚Üì
                    Validation
                         ‚Üì
                 Decision Point ‚Üí Proceed/Revise
```

### Test Coverage Requirements

| Migration Component | Test Type | Required Coverage |
|-------------------|-----------|-------------------|
| Field structure | Unit | 100% |
| Data integrity | Integration | 100% |
| Validation rules | Functional | 100% |
| User workflows | E2E | Critical paths |
| Performance | Load | Representative load |
| Platform compatibility | Cross-platform | All target platforms |

### Validation Checklist
- [ ] All existing data accessible
- [ ] New fields function correctly
- [ ] Validation rules apply properly
- [ ] Export/import maintains integrity
- [ ] Sync operations complete
- [ ] Performance acceptable
- [ ] Mobile platforms stable
- [ ] User permissions preserved

## Data Preservation Strategies {important}

### Preventing Data Loss

#### Pre-Migration Preservation
1. **Export everything** - Even seemingly unrelated data
2. **Document relationships** - Parent-child, linked records
3. **Capture metadata** - Timestamps, user info, annotations
4. **Screenshot complex data** - Visual layouts, configurations
5. **Version control** - Track all configuration changes

#### During Migration
```javascript
// Maintain data integrity
1. Use transactions where possible
2. Validate at each step
3. Log all operations
4. Maintain audit trail
5. Verify counts match
```

#### Post-Migration Verification
- Record counts match pre-migration
- All relationships preserved
- Metadata intact
- No orphaned records
- Validation still passes
- Export format unchanged

### Handling Data Format Changes

#### Type Conversion Matrix
| From Type | To Type | Data Preservation Method |
|-----------|---------|-------------------------|
| Text | Number | Parse with fallback |
| Number | Text | ToString with format |
| Single | Multiple | Wrap in array |
| Multiple | Single | Take first/concatenate |
| Rich text | Plain text | Strip HTML/Markdown |
| Date | Text | ISO format string |

## Communication Templates {important}

### Pre-Migration Notice
```markdown
Subject: Scheduled Field Migration - [Date]

Team,

We will be migrating [field/form names] on [date] at [time].

**What's Changing:**
- [Specific changes]

**Impact:**
- Expected downtime: [duration]
- Affected users: [groups]
- Data effects: [any data changes]

**Action Required:**
- Complete pending work by [deadline]
- Export any critical data before [time]

**Questions:** Contact [person]
```

### Post-Migration Report
```markdown
Subject: Migration Complete - [Field/Form]

Status: ‚úÖ Successful / ‚ö†Ô∏è Partial / ‚ùå Rolled Back

**Completed Changes:**
- [What was done]

**Issues Encountered:**
- [Any problems and resolutions]

**Verification Steps:**
- [How users can verify]

**Support:** [Contact for issues]
```

## Version Compatibility Management {comprehensive}

### Compatibility Matrix

| Fieldmark Version | Migration Support | Breaking Changes | Notes |
|------------------|-------------------|------------------|--------|
| v3.0.x | Baseline | - | Starting point |
| v3.1.x | Enhanced backup | Field type changes | Test thoroughly |
| v3.2.x | Batch operations | Validation syntax | Review all validations |
| v3.3.x | Current | Namespace updates | Update components |

### Version-Specific Considerations
- Always migrate to latest stable version first
- Test on version before implementing
- Check release notes for migration guides
- Maintain version documentation

## Common Migration Pitfalls {comprehensive}

### Top 10 Pitfalls to Avoid

1. **No backup** - Always backup, even for "simple" changes
2. **Untested migration** - Never migrate without testing
3. **Peak time migration** - Schedule during low usage
4. **No rollback plan** - Always have escape route
5. **Poor communication** - Over-communicate changes
6. **Ignoring dependencies** - Check all relationships
7. **Skipping verification** - Always verify post-migration
8. **Rushed timeline** - Allow buffer time
9. **Single person knowledge** - Document for team
10. **No monitoring** - Watch for delayed issues

### Recovery from Failed Migrations

#### Immediate Actions
1. **Don't panic** - Follow rollback plan
2. **Communicate** - Inform users immediately
3. **Assess damage** - What data affected?
4. **Execute rollback** - Use prepared procedure
5. **Document failure** - For post-mortem

#### Post-Recovery Analysis
- What went wrong?
- What wasn't tested?
- How to prevent recurrence?
- Update procedures
- Share learnings

## Migration Timing Best Practices {important}

### Optimal Windows
- **Best**: Weekend early morning (minimal users)
- **Good**: After hours weekday (low activity)
- **Acceptable**: Lunch hour (brief changes only)
- **Avoid**: Monday morning, end of month, deadlines

### Time Estimation Formula
```
Migration Time = 
  Export Time +
  (Backup Time √ó 2) +
  Migration Execution +
  (Verification Time √ó 2) +
  Buffer (50% of total)
```

## Automated Migration Support {comprehensive}

### Scripting Patterns
```python
# Migration script template
def migrate_field(old_config, new_config):
    # 1. Validate inputs
    validate_configs(old_config, new_config)
    
    # 2. Create backup
    backup_id = create_backup(old_config)
    
    try:
        # 3. Execute migration
        apply_changes(new_config)
        
        # 4. Verify
        if not verify_migration():
            raise MigrationError("Verification failed")
            
        # 5. Commit
        commit_changes()
        
    except Exception as e:
        # 6. Rollback
        restore_backup(backup_id)
        raise
```

### Automation Opportunities
- Configuration validation
- Backup creation
- Data export/import
- Verification checks
- Rollback procedures
- Communication notifications

## See Also {comprehensive}

### Field-Specific Migration Scenarios
- [Display Field Migrations](../field-categories/display-field-v05.md#migration-scenarios)
- [Location Field Migrations](../field-categories/location-fields-v05.md#migration-scenarios)
- [Media Field Migrations](../field-categories/media-fields-v05.md#migration-scenarios)
- [Relationship Field Migrations](../field-categories/relationship-field-v05.md#migration-scenarios)

### Related References
- [Platform Behaviors Reference](./platform-behaviors-reference.md)
- [Performance Thresholds Reference](./performance-thresholds-reference.md)
- [Troubleshooting Framework Reference](./troubleshooting-framework-reference.md)
- [Data Export Reference](./data-export-reference.md)

## Metadata {comprehensive}
- **Document Version**: v01
- **Last Updated**: 2025-01-03
- **Status**: Initial creation
- **Purpose**: Universal migration methodologies for Fieldmark v3
- **Maintenance**: Update with new patterns and lessons learned

<!-- concat:reference:troubleshooting-framework-reference -->
# Troubleshooting Framework Reference - Fieldmark v3

## Overview {essential}

This reference provides a systematic framework for diagnosing and resolving issues across all Fieldmark v3 field types. Use this guide to establish consistent troubleshooting approaches and escalation paths.

## Quick Diagnosis Framework {essential}

### Universal Diagnostic Steps
1. **Identify Symptoms** - What exactly is the user experiencing?
2. **Check Console** - Browser/app console for JavaScript errors
3. **Verify Platform** - iOS, Android, or Web-specific issue?
4. **Test Isolation** - Does it occur in a minimal test case?
5. **Check Configuration** - Valid JSON and parameters?
6. **Review Logs** - Sync logs, network requests, validation errors
7. **Document Pattern** - Reproducible steps and conditions

## Common Issue Categories {essential}

### Category Matrix
| Category | Frequency | Impact | Typical Resolution Time |
|----------|-----------|--------|------------------------|
| Configuration | High | Medium | 5-15 minutes |
| Platform-specific | Medium | High | 15-30 minutes |
| Performance | Medium | High | 30-60 minutes |
| Data validation | High | Low | 5-10 minutes |
| Sync/Network | Low | Critical | Variable |
| Permissions | Medium | Critical | 10-20 minutes |

## Universal Error Patterns {important}

### JavaScript Errors
| Error Pattern | Common Cause | Quick Fix |
|--------------|--------------|-----------|
| `Cannot read property of undefined` | Missing null checks | Add optional chaining |
| `Maximum call stack exceeded` | Infinite loop/recursion | Check conditions |
| `Out of memory` | Large data/images | Reduce size/pagination |
| `Network timeout` | Slow connection | Retry/offline mode |
| `Permission denied` | Missing permissions | Check platform settings |

### Silent Failures
**Indicators:**
- No error message but unexpected behavior
- Console warnings without errors
- Partial functionality
- Platform-specific differences

**Common Causes:**
- Sanitization removing content
- Validation preventing saves
- Platform API differences
- Race conditions

## Diagnostic Tools and Techniques {important}

### Browser DevTools
```javascript
// Essential console commands
console.log('Component state:', this.state);
console.table(validationErrors);
console.time('Operation'); // ... console.timeEnd('Operation');
debugger; // Breakpoint
```

### Network Inspection
- Check request/response payloads
- Verify API endpoints
- Monitor request timing
- Identify failed requests
- Check CORS headers

### Mobile Debugging
#### iOS
- Safari Web Inspector
- Console.app for native logs
- Simulator vs device testing
- Memory profiler

#### Android
- Chrome DevTools remote
- adb logcat filtering
- Android Studio profiler
- WebView debugging

## Issue Resolution Framework {important}

### Severity Levels
1. **Critical** - Data loss, app crash, security issue
2. **High** - Feature unusable, widespread impact
3. **Medium** - Workaround available, limited impact
4. **Low** - Cosmetic, rare occurrence

### Resolution Workflow
```mermaid
graph TD
    A[Issue Reported] --> B{Critical?}
    B -->|Yes| C[Immediate Hotfix]
    B -->|No| D[Diagnose Root Cause]
    D --> E{Known Issue?}
    E -->|Yes| F[Apply Known Fix]
    E -->|No| G[Investigate]
    G --> H{Reproducible?}
    H -->|Yes| I[Create Fix]
    H -->|No| J[Gather More Info]
    I --> K[Test Fix]
    K --> L[Deploy]
    F --> L
    C --> L
```

## Common Troubleshooting Scenarios {comprehensive}

### Scenario 1: Field Not Displaying
**Diagnostic Path:**
1. Check console for errors
2. Verify component name spelling
3. Confirm namespace correct
4. Check conditions if applicable
5. Verify JSON syntax
6. Test in different notebook

**Common Fixes:**
- Correct component-name case
- Fix namespace typo
- Resolve condition logic
- Fix JSON syntax error

### Scenario 2: Validation Always Failing
**Diagnostic Path:**
1. Check validation schema syntax
2. Verify field type matches validation
3. Test with minimal validation
4. Check for conflicting validations
5. Review initialValue compatibility

**Common Fixes:**
- Match array/string validation to field
- Correct yup method names
- Fix validation parameters
- Align with multiple setting

### Scenario 3: Performance Degradation
**Diagnostic Path:**
1. Profile with DevTools
2. Count active components
3. Measure data size
4. Check render frequency
5. Monitor memory usage

**Common Fixes:**
- Reduce active field count
- Implement pagination
- Optimize images/data
- Add debouncing
- Clear unused data

### Scenario 4: Platform-Specific Issues
**Diagnostic Path:**
1. Identify affected platforms
2. Check platform-specific APIs
3. Review permission states
4. Test on multiple devices
5. Check version compatibility

**Common Fixes:**
- Add platform detection
- Implement fallbacks
- Request permissions properly
- Update WebView/browser
- Add polyfills

## Error Message Decoder {comprehensive}

### Field-Agnostic Error Messages
| Error Message | Likely Cause | Resolution |
|--------------|--------------|------------|
| "Required field" | Validation without value | Provide value or remove validation |
| "Invalid type" | Type mismatch | Check type-returned vs validation |
| "Component not found" | Wrong name/namespace | Verify component registration |
| "Permission denied" | Platform permission | Request in app settings |
| "Network error" | Connection issue | Check connectivity/CORS |
| "Memory exhausted" | Too much data | Reduce/paginate data |
| "Sync conflict" | Concurrent edits | Choose version/merge |
| "Invalid configuration" | JSON syntax/schema | Validate JSON structure |

## Prevention Strategies {important}

### Design-Time Prevention
- Validate JSON before deployment
- Test on minimum spec devices
- Set realistic data limits
- Plan for offline scenarios
- Document known limitations

### Runtime Prevention
- Add comprehensive error handling
- Implement retry mechanisms
- Provide user feedback
- Add performance monitoring
- Include diagnostic logging

### Testing Prevention
- Cross-platform testing
- Edge case coverage
- Performance testing
- Permission denial testing
- Network condition testing

## Escalation Procedures {essential}

### When to Escalate
- Data loss occurring
- Security vulnerability found
- Widespread platform issue
- No known workaround
- Regression from update

### Escalation Path
1. **Level 1**: Check documentation and known issues
2. **Level 2**: Community forum/discussion
3. **Level 3**: GitHub issue creation
4. **Level 4**: Direct support contact

### Information to Provide
```markdown
## Issue Report Template
**Environment:**
- Platform: [iOS/Android/Web]
- Version: [Fieldmark version]
- Device: [Model/Browser]

**Issue:**
- Expected: [What should happen]
- Actual: [What does happen]
- Steps: [How to reproduce]

**Diagnostics:**
- Console errors: [Any errors]
- Network failures: [Failed requests]
- Configuration: [Relevant JSON]

**Attempts:**
- Tried: [What you've tried]
- Result: [What happened]
```

## Quick Reference Tables {essential}

### Diagnostic Command Reference
| Platform | Command | Purpose |
|----------|---------|---------|
| All | `console.log()` | Debug output |
| Web | `debugger;` | Breakpoint |
| iOS | `Safari Inspector` | Remote debug |
| Android | `chrome://inspect` | Remote debug |
| All | `JSON.stringify()` | Inspect objects |

### Time to Resolution Guidelines
| Issue Type | Target Time | Maximum Time |
|------------|-------------|--------------|
| Configuration | 15 min | 1 hour |
| Validation | 10 min | 30 min |
| Platform | 30 min | 2 hours |
| Performance | 1 hour | 4 hours |
| Data corruption | Immediate | 1 hour |

## See Also {comprehensive}

### Field-Specific Troubleshooting
- [Display Field Troubleshooting](../field-categories/display-field-v05.md#troubleshooting-guide)
- [Location Fields Troubleshooting](../field-categories/location-fields-v05.md#troubleshooting-guide)
- [Media Fields Troubleshooting](../field-categories/media-fields-v05.md#troubleshooting-guide)
- [Relationship Field Troubleshooting](../field-categories/relationship-field-v05.md#troubleshooting-guide)

### Related References
- [Platform Behaviors Reference](./platform-behaviors-reference.md)
- [Performance Thresholds Reference](./performance-thresholds-reference.md)
- [Validation Timing Reference](./validation-timing-reference.md)
- [Error Recovery Patterns](./error-recovery-patterns.md)

## Metadata {comprehensive}
- **Document Version**: v01
- **Last Updated**: 2025-01-03
- **Status**: Initial framework creation
- **Purpose**: Standardize troubleshooting approaches across all field types
- **Maintenance**: Update with new issue patterns and resolutions

<!-- concat:reference:data-export-reference -->
# Data Export Reference
## Universal Export Behavior for All Fieldmark v3 Fields

### Overview

Fieldmark supports two primary export formats: CSV (for spreadsheets) and JSON (for data interchange). Export behavior is consistent across field types, with specific handling for data types and special characters.

### Export Formats

#### CSV Export
- **Format**: Comma-separated values with headers
- **Encoding**: UTF-8 with BOM
- **Line endings**: Unix (LF) or Windows (CRLF)
- **Quote character**: Double quotes (")
- **Escape character**: Double quotes ("")
- **Null representation**: Empty cell

#### JSON Export  
- **Format**: Valid JSON with proper escaping
- **Encoding**: UTF-8
- **Structure**: Nested objects preserving relationships
- **Null representation**: `null` value
- **Arrays**: Preserved as JSON arrays
- **Objects**: Preserved as nested objects

### Field Type Export Mapping

#### Text Fields
| Field Type | CSV Export | JSON Export | Special Considerations |
|------------|------------|-------------|------------------------|
| TextField | Plain text string | String | Quoted if contains commas |
| MultipleTextField | Text with line breaks | String | May break CSV readers |
| FAIMSTextField | Plain text string | String | Same as TextField |
| TemplatedString | Generated value only | String | Template not exported |
| Email | Plain text string | String | No validation on export |
| Address | JSON string in cell | Object | Requires parsing |
| QRCode | Scanned value | String | No scan metadata |
| RichText | **Not exported** | **Not exported** | Definition only |

#### Number Fields
| Field Type | CSV Export | JSON Export | Special Considerations |
|------------|------------|-------------|------------------------|
| NumberField | Numeric value | Number | Scientific notation possible |
| ControlledNumber | Numeric value | Number | Same as NumberField |
| BasicAutoIncrementer | String with zeros | String | Excel strips leading zeros |
| Integer fields | Integer value | Number | No decimal places |

#### DateTime Fields
| Field Type | CSV Export | JSON Export | Special Considerations |
|------------|------------|-------------|------------------------|
| DateTime | ISO 8601 string | String | With timezone |
| DateTimeNow | ISO 8601 string | String | Capture timestamp |
| DatePicker | YYYY-MM-DD | String | No time component |
| MonthPicker | YYYY-MM | String | Excel misinterprets |

#### Selection Fields
| Field Type | CSV Export | JSON Export | Special Considerations |
|------------|------------|-------------|------------------------|
| Checkbox | true/false | Boolean | Not "TRUE"/"FALSE" |
| RadioGroup | Selected value | String | Single value only |
| Select | Selected value | String | Value not label |
| MultiSelect | Comma-joined | Array | Nested commas problematic |
| AdvancedSelect | Path string | String | " > " delimiter |

#### Media Fields
| Field Type | CSV Export | JSON Export | Special Considerations |
|------------|------------|-------------|------------------------|
| TakePhoto | Filename(s) | Array | No binary data |
| FileUploader | Filename(s) | Array | Paths only |

#### Location Fields
| Field Type | CSV Export | JSON Export | Special Considerations |
|------------|------------|-------------|------------------------|
| TakePoint | Lat,Long string | Object | GeoJSON format |
| MapFormField | GeoJSON string | Object | Complex structure |

### Meta Properties Export

Meta properties create additional columns/fields:

#### CSV Additional Columns
- `fieldname_annotation` - Annotation text
- `fieldname_uncertainty` - true/false
- `fieldname_timestamp` - If timestamped

#### JSON Additional Properties
```json
{
  "fieldname": "value",
  "fieldname_annotation": "annotation text",
  "fieldname_uncertainty": true,
  "fieldname_timestamp": "2024-03-15T10:30:00Z"
}
```

### Special Character Handling

#### CSV Special Characters
| Character | Handling | Example |
|-----------|----------|---------|
| Comma (,) | Quote entire field | `"Smith, John"` |
| Quote (") | Double the quote | `"She said ""Hello"""` |
| Newline | Quote entire field | `"Line 1\nLine 2"` |
| Tab | Quote entire field | `"Col1\tCol2"` |
| Leading = | Quote to prevent formula | `"=1+2"` |

#### JSON Special Characters
Automatically escaped per JSON specification:
- `"` becomes `\"`
- `\` becomes `\\`
- Newline becomes `\n`
- Tab becomes `\t`
- Unicode properly encoded

### Excel/Spreadsheet Issues

#### Common Problems
1. **Leading zeros stripped**: BasicAutoIncrementer "00042" becomes 42
2. **Scientific notation**: Large numbers like 123456789012345
3. **Date auto-conversion**: 2024-03 becomes March 3, 2024
4. **Formula injection**: Fields starting with =, +, -, @
5. **Regional settings**: DD/MM vs MM/DD confusion
6. **Unicode corruption**: Special characters mangled

#### Prevention Strategies
1. **Use Text Import Wizard**: Don't double-click CSV
2. **Set column types**: Explicitly set text for IDs
3. **Pre-format columns**: Format before pasting
4. **Use JSON for complex data**: Avoids Excel parsing
5. **Document formats**: Provide import instructions

### Null and Empty Value Handling

#### CSV Representation
| Value Type | Representation | Notes |
|------------|----------------|-------|
| null | Empty cell | No quotes |
| Empty string | `""` | Two quotes |
| Zero | `0` | Numeric zero |
| false | `false` | Boolean false |
| Empty array | Empty cell | Lost on import |
| Empty object | `{}` | JSON string |

#### JSON Representation
| Value Type | Representation | Notes |
|------------|----------------|-------|
| null | `null` | JSON null |
| Empty string | `""` | Empty string |
| Zero | `0` | Numeric zero |
| false | `false` | Boolean false |
| Empty array | `[]` | Empty array |
| Empty object | `{}` | Empty object |

### Array Export Behavior

#### MultiSelect Arrays
**CSV**: Comma-joined with issues
```csv
"Option1,Option2,Option3"
```
**Problem**: If options contain commas: `"Red, Green, and Blue,Yellow"`

**JSON**: Proper array
```json
["Option1", "Option2", "Option3"]
```

#### File Arrays (Media)
**CSV**: Semicolon-separated
```csv
"photo1.jpg;photo2.jpg;photo3.jpg"
```

**JSON**: Array of objects
```json
[
  {"filename": "photo1.jpg", "size": 1234567},
  {"filename": "photo2.jpg", "size": 2345678}
]
```

### Hierarchical Data Export

#### AdvancedSelect Paths
**CSV**: Delimited string
```csv
"Kingdom > Phylum > Class > Order > Family > Genus > Species"
```

**JSON**: Same (not hierarchical)
```json
"Kingdom > Phylum > Class > Order > Family > Genus > Species"
```

#### Address Components
**CSV**: JSON in cell
```csv
"{""line1"":""123 Main St"",""city"":""Sydney"",""postcode"":""2000""}"
```

**JSON**: Nested object
```json
{
  "line1": "123 Main St",
  "city": "Sydney",
  "postcode": "2000"
}
```

### Export Performance

#### Performance by Record Count
| Records | CSV Generation | JSON Generation | Download Time |
|---------|---------------|-----------------|---------------|
| <100 | Instant | Instant | <1s |
| 100-1000 | <2s | <1s | 1-5s |
| 1000-10000 | 5-10s | 2-5s | 5-30s |
| >10000 | May timeout | 10-30s | >30s |

#### Memory Considerations
- CSV: Entire file in memory
- JSON: Streamed if supported
- Large exports: Use pagination
- Binary data: Never inline

### Platform-Specific Behavior

#### Web Browser
- Download to default folder
- Memory limited by browser
- May show progress bar

#### Mobile App
- Save to app storage first
- Then share/export
- Memory constraints tighter

#### API Export
- Supports streaming
- Pagination available
- Format negotiation

### Best Practices

#### For Developers
1. **Document export format**: Provide examples
2. **Include import instructions**: Especially for Excel
3. **Test with special characters**: Commas, quotes, newlines
4. **Validate round-trip**: Export ‚Üí Import ‚Üí Export
5. **Consider data types**: Preserve types where possible

#### For Users
1. **Use JSON for complex data**: Preserves structure
2. **Use CSV for simple tables**: Excel-compatible
3. **Document Excel settings**: Regional, date formats
4. **Backup before import**: Excel auto-conversion is destructive
5. **Use Text Import Wizard**: Never double-click CSV

### Common Export Issues

#### Issue: Commas in MultiSelect Options
**Problem**: CSV parsing breaks
**Solution**: Use different delimiter or JSON export

#### Issue: Excel Stripping Zeros
**Problem**: IDs like "00042" become 42
**Solution**: Import as text or use TemplatedString wrapper

#### Issue: Date Format Confusion  
**Problem**: MM/DD vs DD/MM
**Solution**: Use ISO 8601 format (YYYY-MM-DD)

#### Issue: Large Numbers in Excel
**Problem**: Converted to scientific notation
**Solution**: Format as text before import

#### Issue: Unicode Characters Lost
**Problem**: Excel default encoding
**Solution**: Specify UTF-8 on import

### Export Validation

#### Checklist for Testing
- [ ] Null values export correctly
- [ ] Special characters preserved
- [ ] Arrays handled appropriately
- [ ] Dates in correct format
- [ ] Numbers maintain precision
- [ ] Meta properties included
- [ ] Unicode preserved
- [ ] Large datasets work

### Related Documentation
- Field-specific export notes in category docs
- Meta Properties Reference for annotation/uncertainty export
- Platform specifications for device-specific limits
- API documentation for programmatic export

### Version
Last updated: 2025-09-03
Applies to: Fieldmark v3 (all versions)
Export version: 2.0 (current format)

<!-- concat:reference:designer-limitations-reference -->
# Designer Limitations Reference
## Universal Constraints for All Fieldmark v3 Fields

### Overview

The Fieldmark Designer web application provides a visual interface for creating and configuring notebooks. While Designer handles most common configuration needs, certain advanced features and testing capabilities require direct JSON editing or can only be verified after deployment.

### Testing & Preview Limitations

#### Cannot Test Before Deployment
- **Field appearance**: No preview of how fields will render on different platforms
- **Conditional logic**: Conditions must be tested in deployed notebooks, not Designer preview
- **Validation behavior**: Cannot verify validation schemas work as intended
- **Mobile usability**: No way to test touch interactions or mobile-specific behaviors
- **Export formats**: Cannot preview CSV/JSON export behavior with sample data

#### Testing Workflow Impact
1. Make changes in Designer
2. Deploy to test server
3. Test on actual devices
4. Return to Designer for corrections
5. Repeat deployment cycle

This iterative process significantly impacts development time, especially for complex forms with conditional logic or platform-specific requirements.

### Validation Customization Constraints

#### Error Message Limitations
- **Cannot customize validation messages**: Stuck with Yup validation library defaults
  - Example: "This field is required" cannot be changed to "Please enter specimen ID"
  - Example: Email validation shows generic "Invalid email" rather than context-specific message
- **Cannot control error display positioning**: Errors always appear below fields
- **Cannot style error messages**: Red text styling is fixed
- **Cannot create contextual help**: Errors cannot reference other field values

#### Cross-Field Validation
Designer cannot create validation rules that reference multiple fields:
- Password confirmation matching
- Date range validation (start date before end date)
- Conditional required fields based on other field values
- Sum validation across numeric fields
- Duplicate checking across array fields

These require JSON editing with custom Yup schemas.

### Performance & Warning Gaps

#### No Performance Indicators
Designer provides no warnings when configurations will cause issues:
- **Option count limits**: No warning when Select/RadioGroup exceeds 20 options (causes lag with markdown processing)
- **Character limits**: No indication when text fields approach performance thresholds
- **Memory usage**: No warnings about large file uploads or image captures
- **Render complexity**: No indication when forms become too complex for mobile devices

#### Missing Accessibility Warnings
- No WCAG compliance indicators
- No color contrast warnings
- No touch target size validation (44√ó44px minimum)
- No screen reader compatibility checks
- No keyboard navigation testing

#### Platform-Specific Issues Not Flagged
- QRCodeFormField required on web (will block form submission)
- Address field initialization errors
- Browser-specific validation conflicts
- Mobile keyboard behavior issues

### Field Management Restrictions

#### Type Conversion Limitations
- **Cannot convert between field types**: Must delete and recreate
  - Example: Cannot change RadioGroup to Select
  - Example: Cannot convert TextField to MultipleTextField
  - Data migration must be handled externally

#### Bulk Operations Not Supported
- Cannot edit multiple fields simultaneously
- Cannot copy validation rules between fields
- Cannot apply consistent styling across field groups
- Cannot search and replace across field labels/helpers

#### Configuration Constraints
- **Character limits**: Cannot enforce maximum character counts
- **Input patterns**: Cannot restrict input format (phone numbers, postal codes)
- **Input masks**: Cannot create formatted input (credit cards, dates)
- **Auto-formatting**: Cannot enable automatic formatting as user types

### Advanced Features Requiring JSON

Despite Designer improvements, some features still require JSON editing:

#### Complex Hierarchies
While AdvancedSelect provides a JSON editor window, complex hierarchies still require careful manual construction:
- Multi-level taxonomies
- Conditional branches in hierarchies
- Large option trees (>100 nodes)

#### Component Parameters
Many component-specific parameters are not exposed in Designer:
- Platform-specific configurations
- Advanced Material-UI properties
- Custom CSS classes
- Performance optimizations

#### Meta Properties
While basic meta properties are available, advanced configurations require JSON:
- Custom annotation labels
- Conditional meta property display
- Meta property validation rules

### Workaround Strategies

#### For Testing Limitations
1. Maintain a staging deployment for rapid testing
2. Use device emulators for basic mobile testing
3. Create test notebooks with all field types
4. Document test cases for manual verification

#### For Validation Constraints
1. Use helper text to clarify requirements
2. Document validation rules in field labels
3. Create separate documentation for complex validation
4. Train users on expected formats

#### For Performance Issues
1. Monitor browser console during testing
2. Test with maximum expected data volumes
3. Document performance thresholds
4. Plan for progressive form complexity

### Impact on Development Workflow

These limitations affect different user groups:

**Notebook Designers**: Must plan for multiple deployment cycles and maintain external documentation for complex requirements.

**Developers**: Need to switch between Designer and JSON editing, maintaining synchronization between visual and code representations.

**End Users**: May encounter generic error messages and validation behaviors that don't match their domain expectations.

### Best Practices

1. **Start Simple**: Build basic structure in Designer, enhance with JSON
2. **Test Early**: Deploy frequently to catch issues before complex dependencies develop
3. **Document Thoroughly**: Maintain external documentation for validation rules and conditional logic
4. **Plan Iterations**: Budget time for the deploy-test-refine cycle
5. **Use Templates**: Create reusable patterns for common configurations

### Related Documentation
- Component Namespace Reference for JSON component names
- Validation Timing Reference for validation behavior
- Meta Properties Reference for annotation/uncertainty configuration
- Individual field documentation for field-specific limitations

### Version
Last updated: 2025-09-03
Applies to: Fieldmark v3 Designer (all versions)
Designer version: Current web interface

<!-- concat:reference:security-considerations-reference -->
# Security Considerations Reference
## Universal Security Guidelines for Fieldmark v3

### Overview

This document consolidates security considerations for all Fieldmark v3 field types. Security in Fieldmark operates on multiple levels: client-side validation (easily bypassed), server-side validation (essential), and data sanitization (critical for preventing attacks). Understanding these layers is essential for deploying secure notebooks.

### Critical Security Vulnerabilities

#### XSS (Cross-Site Scripting) Risks

**Most Critical Vulnerability - TemplatedString Fields**:
- **Issue**: HTML escaping is DISABLED in TemplatedString fields (formUtilities.ts line 27)
- **Risk Level**: CRITICAL
- **Attack Vector**: User input in templates executes as HTML/JavaScript
- **Impact**: Complete session hijacking, data theft, form manipulation
- **Example Attack**:
  ```json
  // Template configuration:
  { "template": "Record: {{user_text_field}}" }
  
  // If user enters in text field:
  <script>alert('XSS')</script>
  
  // Result: Script EXECUTES when template renders
  ```

**Mitigation Requirements**:
1. NEVER include user-input text fields in TemplatedString templates
2. Only use controlled vocabularies (Select, RadioGroup) in templates
3. Use static values or system-generated fields only
4. If user input is essential, implement server-side sanitization

**Safe Pattern**:
```json
{
  "template": "{{site_type}}-{{counter}}-{{date}}",
  // Where:
  // site_type = Select field with predefined options
  // counter = BasicAutoIncrementer
  // date = DatePicker (system controlled)
}
```

**Unsafe Patterns to Avoid**:
```json
// ALL OF THESE CREATE XSS VULNERABILITIES:
{ "template": "Site: {{site_name}}" }      // If site_name is TextField
{ "template": "Notes: {{description}}" }    // If description is MultipleTextField
{ "template": "ID: {{custom_id}}" }         // If custom_id allows user input
{ "template": "{{any_user_editable_field}}" } // ANY user-editable field
```

#### SQL Injection Prevention

**Risk Areas**:
- All text input fields (TextField, MultipleTextField, Email, Address)
- QRCode scanner input
- Imported data from CSV/JSON

**Current State**:
- NO input sanitization at field level
- NO parameterized queries enforced
- Backend validation responsibility

**Required Protections**:
1. Implement parameterized queries in all backend operations
2. Never concatenate user input into SQL strings
3. Validate data types before database operations
4. Use prepared statements for all queries
5. Implement stored procedures where appropriate

#### JSON Injection Risks

**Affected Fields**:
- Address fields (store complex JSON)
- Any field with JSON storage

**Attack Vectors**:
```javascript
// Malicious input in Address field:
{
  "line1": "123 Main\"};alert('XSS');//",
  "city": "Sydney",
  "__proto__": {"isAdmin": true}  // Prototype pollution
}
```

**Protections**:
1. Validate JSON structure before storage
2. Use JSON schema validation
3. Sanitize all string values within JSON
4. Never use eval() or Function() with JSON data

### Field-Specific Security Considerations

#### Text Fields (TextField, MultipleTextField)
- No character limit enforcement at database level
- No input pattern validation beyond client-side
- HTML special characters stored raw
- Recommendation: Implement server-side length limits and pattern validation

#### TemplatedString Fields
- **CRITICAL**: HTML escaping disabled
- Template injection possible through field references
- No recursive reference protection
- Recommendation: Whitelist allowed template variables

#### RichText Fields
- DOMPurify sanitization at runtime
- External images blocked (hardcoded empty array)
- Script tags stripped but other vectors possible
- Tables removed despite Designer support
- Recommendation: Never include user content in RichText

#### QRCodeFormField
- No validation of scanned content
- Accepts any barcode format
- Raw data stored without sanitization
- Recommendation: Validate expected format server-side

#### Address Fields
- Complex JSON structure allows nested attacks
- Race conditions can corrupt data
- No format validation
- Recommendation: Implement JSON schema validation

#### Number Fields
- JavaScript precision limits can cause data corruption
- No server-side range validation
- Scientific notation can bypass validations
- Recommendation: Validate numeric ranges server-side

#### DateTime Fields
- Future dates accepted (backdating possible)
- No temporal sequence validation
- Timezone information leaks user location
- Format string injection possible
- Recommendation: Implement audit trails server-side

#### Selection Fields
- Option values not validated for special characters
- Markdown in options can introduce vectors
- No uniqueness validation on values
- Recommendation: Sanitize option values before storage

### Data Validation Layers

#### Client-Side (Weak)
- Yup validation schemas
- HTML5 input validation
- JavaScript validation logic
- **Easily bypassed** using browser developer tools
- Should be considered UX enhancement only

#### Server-Side (Essential)
- Must duplicate ALL client-side validation
- Implement additional security checks
- Type validation before database operations
- Range and format enforcement
- Rate limiting for rapid submissions

#### Database Level (Critical)
- Constraints on field lengths
- Data type enforcement
- Foreign key relationships
- Stored procedure validation
- Trigger-based audit trails

### Security Best Practices

#### Input Handling
1. **Never trust client data** - Validate everything server-side
2. **Whitelist over blacklist** - Define allowed patterns explicitly
3. **Fail securely** - Reject suspicious input rather than attempting to clean
4. **Log security events** - Track validation failures for analysis
5. **Rate limit** - Prevent rapid submission attacks

#### Template Security
1. **No user input in templates** - Only system-controlled fields
2. **Validate template syntax** - Prevent template injection
3. **Limit template complexity** - Avoid nested conditionals
4. **Audit template changes** - Track who modifies templates
5. **Test with malicious input** - Include security testing in QA

#### Testing for Security

**Test with these malicious inputs**:
```javascript
// XSS attempts
<script>alert('XSS')</script>
<img src=x onerror=alert('XSS')>
javascript:alert('XSS')
<svg onload=alert('XSS')>

// SQL injection attempts
'; DROP TABLE records; --
' OR '1'='1
admin'--
' UNION SELECT * FROM users--

// Template injection
{{constructor.constructor('alert(1)')()}}
${alert('XSS')}
{{__proto__.isAdmin = true}}

// JSON injection
{"__proto__": {"isAdmin": true}}
{"line1": "test\"};alert('x');//"}
```

### Authentication & Authorization

#### Current Limitations
- No field-level permissions
- No encryption at rest for sensitive fields
- No audit trail for data changes
- Session tokens in local storage (XSS accessible)

#### Recommendations
1. Implement field-level encryption for sensitive data
2. Add audit logging for all data modifications
3. Use httpOnly cookies for session management
4. Implement role-based field access
5. Add data classification levels

### Data Protection

#### Sensitive Data Handling
- PII (Personally Identifiable Information) stored in plain text
- No automatic data masking
- Export functions include all field data
- No redaction capabilities

#### Recommended Protections
1. Identify sensitive fields during design
2. Implement encryption for sensitive data
3. Add data masking for display
4. Control export permissions
5. Implement data retention policies

### Security Incident Response

#### If XSS is Discovered
1. Immediately disable affected templates
2. Audit all TemplatedString configurations
3. Review server logs for exploitation
4. Reset all user sessions
5. Implement content security policy headers

#### If Injection is Suspected
1. Review server logs for unusual patterns
2. Audit database for unauthorized changes
3. Validate all recent data entries
4. Implement additional validation
5. Consider security audit

### Compliance Considerations

#### GDPR/Privacy
- Right to deletion not automatically supported
- No automatic PII detection
- Export includes all user data
- No consent management

#### Security Standards
- No automatic OWASP compliance checking
- Limited security headers by default
- No built-in penetration testing
- Manual security review required

### Security Checklist

Before deploying any notebook:
- [ ] No user text fields in TemplatedString templates
- [ ] Server-side validation implemented for all fields
- [ ] SQL queries use parameterized statements
- [ ] JSON structures validated before storage
- [ ] Rate limiting configured
- [ ] Security headers implemented
- [ ] Audit logging enabled
- [ ] Sensitive data identified and protected
- [ ] Export permissions configured
- [ ] Security testing completed

### Reporting Security Issues

If you discover a security vulnerability:
1. Do NOT publish details publicly
2. Contact the Fieldmark security team immediately
3. Provide detailed reproduction steps
4. Allow time for patching before disclosure
5. Follow responsible disclosure practices

### Related Documentation
- Individual field documentation for field-specific security notes
- Designer Limitations Reference for configuration constraints
- Validation Timing Reference for validation behavior
- Performance Thresholds Reference for DoS prevention

### Version
Last updated: 2025-09-03
Applies to: Fieldmark v3 (all versions)
Security review: Required before production deployment

<!-- concat:reference:validation-timing-reference -->
# Validation Timing Reference
## Universal Behavior for All Fieldmark v3 Fields

### Core Validation Lifecycle

All Fieldmark fields follow the same validation timing pattern, regardless of field type:

#### 1. On Mount
- **What happens**: Validation runs immediately when form loads
- **Error display**: Hidden (field remains "pristine")
- **Field state**: Untouched, even if invalid
- **Purpose**: Establishes initial validation state without alarming users

#### 2. On Change
- **What happens**: Validation runs synchronously on every value change
- **Error display**: Immediate (if component supports error display)
- **Field state**: Transitions from "pristine" to "touched"
- **Purpose**: Provides real-time feedback during data entry

#### 3. On Blur
- **What happens**: Re-validates when user leaves field
- **Error display**: Shows/updates error messages
- **Field state**: Confirms "touched" status
- **Purpose**: Final validation before moving to next field

#### 4. On Submit
- **What happens**: All fields validated regardless of touched state
- **Error display**: All errors shown, even for untouched fields
- **Field state**: All fields marked as touched
- **Purpose**: Ensures complete form validation before submission

### Platform-Specific Behaviors

#### Mobile (iOS/Android)
- **Blur delay**: May not trigger until next field receives focus
- **Virtual keyboard**: Can interfere with blur events
- **Touch vs click**: Touch events may process differently

#### Desktop (Web)
- **Standard behavior**: Blur triggers immediately on focus loss
- **Tab navigation**: Triggers blur/focus in sequence
- **Mouse clicks**: Immediate blur when clicking outside

### Field-Specific Variations

While the core timing is universal, some fields have additional considerations:

#### Text Fields
- **Keystroke validation**: Validates on every character entry
- **Performance impact**: Can cause lag with complex regex patterns
- **Debouncing**: Not implemented - every keystroke triggers validation

#### Number Fields
- **Parse on change**: Attempts to parse numeric value on each keystroke
- **Invalid character handling**: May prevent entry rather than show error
- **Format validation**: Checks decimal places, ranges continuously

#### DateTime Fields
- **Format parsing**: Complex date parsing on each change
- **Picker integration**: Native pickers may bypass change events
- **Manual entry**: Validates partial dates during typing

#### Selection Fields (Checkbox, Radio, Select, MultiSelect)
- **Immediate validation**: Selection changes trigger instant validation
- **No keystroke issues**: Binary state changes only
- **Error display limitations**: Some components cannot display errors

#### Media Fields
- **Async validation**: File uploads validate after upload completes
- **Size checks**: Pre-upload validation for file size
- **Type validation**: MIME type checked before processing

### Error Display Capabilities by Component

| Field Type | Shows Errors | When Displayed | Where Displayed |
|------------|--------------|----------------|-----------------|
| TextField | ‚úÖ Yes | On blur | Below field |
| NumberField | ‚úÖ Yes | On blur | Below field |
| DateTime | ‚úÖ Yes | On blur | Below field |
| Checkbox | ‚úÖ Yes | On blur | Below field |
| RadioGroup | ‚úÖ Yes | On blur | Below group |
| Select | ‚ùå No | Never | N/A - blocks submission |
| MultiSelect | ‚ö†Ô∏è Partial | On blur | Below field (limited) |
| AdvancedSelect | ‚ùå No | Never | N/A - blocks submission |

### State Management

#### Field States
1. **Pristine**: Never touched by user
2. **Touched**: User has interacted with field
3. **Dirty**: Value differs from initial value
4. **Valid**: Passes all validation rules
5. **Invalid**: Fails one or more validation rules

#### State Transitions
```
Mount ‚Üí Pristine + (Valid|Invalid hidden)
    ‚Üì
User Interaction ‚Üí Touched + (Valid|Invalid shown)
    ‚Üì
Value Change ‚Üí Dirty + Revalidation
    ‚Üì
Blur ‚Üí Error Display Update
    ‚Üì
Submit ‚Üí All Touched + All Errors Shown
```

### Common Validation Issues

#### Race Conditions
- Rapid field navigation may skip blur events
- Async validation may complete out of order
- Submit during validation may use stale state

#### Performance Problems
- Complex regex on text fields
- Large option lists in selection fields
- Multiple dependent field validations

#### Mobile-Specific Issues
- Virtual keyboard covering error messages
- Blur events not firing between fields
- Touch targets too small for error icons

### Best Practices

#### For Developers
1. Keep validation rules simple and fast
2. Avoid complex regex patterns on text fields
3. Use type-appropriate fields (email vs text)
4. Provide clear helperText to prevent errors
5. Test on mobile devices for blur behavior

#### For Users
1. Tab through fields on desktop for best experience
2. Wait for validation to complete before submitting
3. Check for hidden errors on untouched required fields
4. Use native pickers when available (dates, times)

### Integration with Formik

All validation timing is controlled by Formik's validation strategy:

```javascript
// Formik configuration (not user-configurable)
validateOnMount: true     // Runs validation on form load
validateOnChange: true    // Validates on every field change
validateOnBlur: true      // Validates when field loses focus
```

### Validation Schema Execution Order

1. **Type validation** (yup.string, yup.number, etc.)
2. **Required validation** (yup.required)
3. **Format validation** (yup.email, yup.matches)
4. **Range validation** (yup.min, yup.max)
5. **Custom validation** (yup.test)

### Related Documentation

- Field-specific validation rules: See individual field documentation
- Validation schema syntax: See JSON Patterns Cookbook
- Error message customization: Not supported (uses Yup defaults)
- Form-level validation: See notebook-structure.md

### Version
Last updated: 2025-09-03
Applies to: Fieldmark v3 (all versions)
Component library: Formik + Material-UI + Yup

<!-- ============================================ -->
<!-- DOCUMENT METADATA -->
<!-- ============================================ -->

## Document Metadata

- **Generated**: 2025-09-05T23:11:04+10:00
- **Total Lines**: 27620
- **Field Documents**: 8
- **Pattern Documents**: 8
- **Reference Documents**: 13
- **Format**: LLM-optimized concatenated reference

## Quick Jump Index

### Field Types
- [Text & Input Fields](#text-input-fields)
- [Selection & Choice Fields](#selection-fields)
- [Date & Time Fields](#datetime-fields)
- [Numeric Fields](#number-fields)
- [Display Fields](#display-fields)
- [Location Fields](#location-fields)
- [Media Fields](#media-fields)
- [Relationship Fields](#relationship-fields)

### Patterns
- [Field Selection](#field-selection-best-practices)
- [Validation](#validation)
- [Conditional Logic](#conditional-logic)
- [Navigation](#navigation)
- [Notebook Structure](#notebook-structure)
- [Common Patterns](#patterns)

### References
- [Component Namespace](#component-namespace-reference)
- [Platform Behaviors](#platform-behaviors-reference)
- [Performance Thresholds](#performance-thresholds-reference)
- [Designer Limitations](#designer-limitations-reference)
- [Security Considerations](#security-considerations-reference)
